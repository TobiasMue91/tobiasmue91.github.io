<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéôÔ∏è</text></svg>">
    <title>Professional Voice Recorder</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #4cc9f0;
            --success: #4ade80;
            --danger: #f43f5e;
            --warning: #fbbf24;
            --bg-light: #f8fafc;
            --bg-dark: #0f172a;
            --text-light: #f8fafc;
            --text-dark: #1e293b;
            --card-light: #ffffff;
            --card-dark: #1e293b;
            --border-light: #e2e8f0;
            --border-dark: #475569;
            --transition: all 0.3s ease;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-light);
            color: var(--text-dark);
            margin: 0;
            padding: 0;
            transition: var(--transition);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-light)
        }

        .container {
            max-width: 800px;
            width: 92%;
            margin: 2rem auto;
            padding: 0 1rem
        }

        .header {
            text-align: center;
            margin-bottom: 1.5rem;
            position: relative
        }

        .header h1 {
            font-size: 1.75rem;
            margin-bottom: 0.5rem;
            font-weight: 700
        }

        .header p {
            color: #64748b;
            margin-top: 0;
            font-size: 0.95rem
        }

        .dark-mode .header p {
            color: #94a3b8
        }

        .card {
            background: var(--card-light);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: var(--shadow);
            margin-bottom: 1.5rem;
            transition: var(--transition)
        }

        .dark-mode .card {
            background: var(--card-dark)
        }

        .recorder-card {
            position: relative;
            overflow: hidden
        }

        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center
        }

        .settings-row label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500
        }

        .settings-group {
            flex: 1;
            min-width: 120px
        }

        .select-wrapper {
            position: relative;
            width: 100%
        }

        select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 8px;
            background-color: #f1f5f9;
            border: 1px solid #cbd5e1;
            font-size: 0.9rem;
            appearance: none;
            padding-right: 2rem;
            cursor: pointer;
            color: var(--text-dark);
            transition: var(--transition)
        }

        .dark-mode select {
            background-color: #334155;
            border-color: #475569;
            color: var(--text-light)
        }

        .select-wrapper::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid #64748b;
            pointer-events: none
        }

        .toolbar {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin: 1.5rem 0
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.25rem;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            outline: none;
            flex: 1 0 auto;
            min-width: 100px;
            max-width: 200px
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.25)
        }

        .btn:active:not(:disabled) {
            transform: translateY(0)
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none
        }

        .btn-record {
            background: var(--primary)
        }

        .btn-pause {
            background: var(--warning);
            color: #000
        }

        .btn-resume {
            background: var(--accent)
        }

        .btn-stop {
            background: var(--danger)
        }

        .btn-icon {
            font-size: 1.1rem;
            line-height: 1
        }

        .timer-display {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin: 1.5rem 0;
            font-variant-numeric: tabular-nums
        }

        .dark-mode .timer-display {
            color: var(--text-light)
        }

        .visualizer-container {
            position: relative;
            height: 100px;
            width: 100%;
            border-radius: 8px;
            background-color: #f1f5f9;
            overflow: hidden;
            margin: 1.5rem 0
        }

        .dark-mode .visualizer-container {
            background-color: #334155
        }

        #waveform {
            width: 100%;
            height: 100%;
            display: block
        }

        .volume-meter {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 82px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden
        }

        .volume-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: var(--primary);
            transition: height 0.1s
        }

        .recordings-container {
            margin-top: 2rem
        }

        .recordings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem
        }

        .recordings-actions {
            display: flex;
            gap: 0.5rem
        }

        .recordings-list {
            list-style: none;
            padding: 0;
            margin: 0
        }

        .recording-item {
            background: rgba(241, 245, 249, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            border: 1px solid var(--border-light);
            transition: var(--transition)
        }

        .dark-mode .recording-item {
            background: rgba(51, 65, 85, 0.5);
            border-color: var(--border-dark)
        }

        .recording-item:hover {
            border-color: var(--primary)
        }

        .recording-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap
        }

        .recording-title {
            font-weight: 600;
            margin: 0;
            flex: 1;
            min-width: 200px;
            word-break: break-word;
            font-size: 1rem
        }

        .recording-meta {
            color: #64748b;
            font-size: 0.85rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap
        }

        .dark-mode .recording-meta {
            color: #94a3b8
        }

        .recording-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap
        }

        .recording-btn {
            padding: 0.4rem 0.75rem;
            font-size: 0.85rem;
            border-radius: 6px;
            background: #e2e8f0;
            border: none;
            color: var(--text-dark);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.25rem
        }

        .dark-mode .recording-btn {
            background: #475569;
            color: var(--text-light)
        }

        .recording-btn:hover:not(:disabled) {
            background: #cbd5e1
        }

        .dark-mode .recording-btn:hover:not(:disabled) {
            background: #64748b
        }

        .recording-btn-play {
            background: var(--primary);
            color: white
        }

        .recording-btn-play:hover:not(:disabled) {
            background: var(--secondary)
        }

        .recording-btn-delete {
            background: #fee2e2;
            color: #ef4444
        }

        .dark-mode .recording-btn-delete {
            background: #451a1a;
            color: #fca5a5
        }

        .recording-btn-delete:hover:not(:disabled) {
            background: #fecaca
        }

        .dark-mode .recording-btn-delete:hover:not(:disabled) {
            background: #7f1d1d
        }

        .audio-player {
            width: 100%;
            margin-top: 0.5rem
        }

        .no-recordings {
            text-align: center;
            padding: 2rem;
            color: #64748b;
            font-style: italic
        }

        .dark-mode .no-recordings {
            color: #94a3b8
        }

        .theme-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            color: var(--text-dark)
        }

        .dark-mode .theme-toggle {
            color: var(--text-light)
        }

        .toaster {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            color: #1e293b;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            display: flex;
            align-items: center;
            gap: 0.75rem
        }

        .toaster.show {
            transform: translateY(0)
        }

        .toaster-icon {
            font-size: 1.5rem
        }

        .toaster-error {
            background: #fef2f2;
            color: #b91c1c;
            border-left: 4px solid #ef4444
        }

        .toaster-success {
            background: #f0fdf4;
            color: #166534;
            border-left: 4px solid #22c55e
        }

        .dark-mode .toaster-error {
            background: #451a1a;
            color: #fca5a5
        }

        .dark-mode .toaster-success {
            background: #14532d;
            color: #86efac
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto
        }

        .modal-content {
            background: var(--card-light);
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            transform: translateY(20px);
            transition: transform 0.3s
        }

        .dark-mode .modal-content {
            background: var(--card-dark)
        }

        .modal.active .modal-content {
            transform: translateY(0)
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0
        }

        .modal-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            color: var(--text-dark)
        }

        .dark-mode .modal-close {
            color: var(--text-light)
        }

        .modal-body {
            margin-bottom: 1.5rem
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem
        }

        .form-group {
            margin-bottom: 1.25rem
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            font-size: 1rem;
            background: #f8fafc;
            transition: var(--transition)
        }

        .dark-mode .form-input {
            background: #334155;
            border-color: #475569;
            color: var(--text-light)
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.25)
        }

        .keyboard-shortcuts {
            margin-top: 1rem
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-light)
        }

        .dark-mode .shortcut-row {
            border-color: var(--border-dark)
        }

        .key {
            background: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-family: monospace
        }

        .dark-mode .key {
            background: #475569
        }

        .error-message {
            color: var(--danger);
            font-size: 0.9rem;
            margin-top: 0.5rem
        }

        .processing-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem
        }

        .processing-option {
            display: flex;
            align-items: center;
            gap: 0.5rem
        }

        .processing-option label {
            font-size: 0.9rem;
            cursor: pointer
        }

        .processing-option input {
            accent-color: var(--primary);
            cursor: pointer
        }

        .tooltip {
            position: relative;
            display: inline-block
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
            transform: translateY(0)
        }

        .tooltip-text {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: rgba(15, 23, 42, 0.9);
            color: white;
            text-align: center;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            z-index: 1;
            opacity: 0;
            transition: all 0.3s;
            white-space: nowrap;
            width: max-content;
            max-width: 200px;
            font-size: 0.85rem
        }

        .dark-mode .tooltip-text {
            background: rgba(241, 245, 249, 0.9);
            color: #0f172a
        }

        @keyframes pulse {
            0% {
                transform: scale(1)
            }
            50% {
                transform: scale(1.05)
            }
            100% {
                transform: scale(1)
            }
        }

        .recording-animation {
            animation: pulse 1.5s infinite
        }

        .hidden {
            display: none !important
        }

        @media (max-width: 640px) {
            .timer-display {
                font-size: 2.5rem
            }

            .toolbar {
                gap: 0.5rem
            }

            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.9rem
            }

            .recordings-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem
            }

            .recording-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem
            }

            .recording-title {
                font-size: 0.95rem
            }

            .recording-meta {
                font-size: 0.8rem
            }

            .recording-actions {
                flex-wrap: wrap;
                justify-content: flex-start
            }

            .recording-btn {
                font-size: 0.8rem;
                padding: 0.3rem 0.6rem
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Professional Voice Recorder</h1>
        <p>High-quality audio recording in your browser</p>
        <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">‚òÄÔ∏è</button>
    </div>

    <div class="card recorder-card">
        <div class="timer-display" id="timer">00:00:00</div>

        <div class="visualizer-container">
            <canvas id="waveform"></canvas>
            <div class="volume-meter">
                <div class="volume-level" id="volume-level"></div>
            </div>
        </div>

        <div class="settings-row">
            <div class="settings-group">
                <label for="format">Format</label>
                <div class="select-wrapper">
                    <select id="format">
                        <option value="audio/webm">WebM</option>
                        <option value="audio/mp4">MP4</option>
                        <option value="audio/ogg">OGG</option>
                    </select>
                </div>
            </div>

            <div class="settings-group">
                <label for="bitrate">Quality</label>
                <div class="select-wrapper">
                    <select id="bitrate">
                        <option value="128000">Standard (128 kbps)</option>
                        <option value="192000" selected>High (192 kbps)</option>
                        <option value="256000">Premium (256 kbps)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="processing-options">
            <div class="processing-option">
                <input type="checkbox" id="noise-reduction" checked>
                <label for="noise-reduction">Noise Reduction</label>
                <div class="tooltip">
                    <span class="tooltip-text">Reduces background noise in your recording</span>
                </div>
            </div>
            <div class="processing-option">
                <input type="checkbox" id="auto-gain">
                <label for="auto-gain">Auto Gain</label>
                <div class="tooltip">
                    <span class="tooltip-text">Automatically adjusts volume levels</span>
                </div>
            </div>
        </div>

        <div class="toolbar">
            <button id="record" class="btn btn-record"><span class="btn-icon">‚è∫</span> Record</button>
            <button id="pause" class="btn btn-pause" disabled><span class="btn-icon">‚è∏</span> Pause</button>
            <button id="resume" class="btn btn-resume" disabled><span class="btn-icon">‚ñ∂</span> Resume</button>
            <button id="stop" class="btn btn-stop" disabled><span class="btn-icon">‚èπ</span> Stop</button>
        </div>
    </div>

    <div class="card">
        <div class="recordings-header">
            <h2>Recordings</h2>
            <div class="recordings-actions">
                <button id="clear-all" class="recording-btn">Clear All</button>
            </div>
        </div>
        <div id="recordings-container">
            <ul id="recordings-list" class="recordings-list"></ul>
            <div id="no-recordings" class="no-recordings">No recordings yet. Press Record to get started.</div>
        </div>
    </div>
</div>

<div id="rename-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Rename Recording</h3>
            <button class="modal-close" id="rename-close">√ó</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="recording-name" class="form-label">Recording Name</label>
                <input type="text" id="recording-name" class="form-input" placeholder="Enter a name for your recording">
            </div>
        </div>
        <div class="modal-footer">
            <button class="recording-btn" id="rename-cancel">Cancel</button>
            <button class="recording-btn recording-btn-play" id="rename-save">Save</button>
        </div>
    </div>
</div>

<div id="shortcuts-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Keyboard Shortcuts</h3>
            <button class="modal-close" id="shortcuts-close">√ó</button>
        </div>
        <div class="modal-body">
            <div class="keyboard-shortcuts">
                <div class="shortcut-row">
                    <span>Start/Stop Recording</span>
                    <span class="key">Space</span>
                </div>
                <div class="shortcut-row">
                    <span>Pause/Resume</span>
                    <span class="key">P</span>
                </div>
                <div class="shortcut-row">
                    <span>Toggle Dark Mode</span>
                    <span class="key">D</span>
                </div>
                <div class="shortcut-row">
                    <span>Show Shortcuts</span>
                    <span class="key">?</span>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="recording-btn recording-btn-play" id="shortcuts-ok">Got it</button>
        </div>
    </div>
</div>

<div id="toaster" class="toaster">
    <span id="toaster-icon" class="toaster-icon"></span>
    <span id="toaster-message"></span>
</div>

<script>
    // DOM Elements
    const recordBtn = document.getElementById('record');
    const pauseBtn = document.getElementById('pause');
    const resumeBtn = document.getElementById('resume');
    const stopBtn = document.getElementById('stop');
    const timerDisplay = document.getElementById('timer');
    const waveformCanvas = document.getElementById('waveform');
    const waveformCtx = waveformCanvas.getContext('2d');
    const volumeLevel = document.getElementById('volume-level');
    const formatSelect = document.getElementById('format');
    const bitrateSelect = document.getElementById('bitrate');
    const noiseReductionCheck = document.getElementById('noise-reduction');
    const autoGainCheck = document.getElementById('auto-gain');
    const recordingsList = document.getElementById('recordings-list');
    const noRecordings = document.getElementById('no-recordings');
    const clearAllBtn = document.getElementById('clear-all');
    const themeToggle = document.getElementById('theme-toggle');
    const renameModal = document.getElementById('rename-modal');
    const renameInput = document.getElementById('recording-name');
    const renameClose = document.getElementById('rename-close');
    const renameCancel = document.getElementById('rename-cancel');
    const renameSave = document.getElementById('rename-save');
    const shortcutsModal = document.getElementById('shortcuts-modal');
    const shortcutsClose = document.getElementById('shortcuts-close');
    const shortcutsOk = document.getElementById('shortcuts-ok');
    const toaster = document.getElementById('toaster');
    const toasterIcon = document.getElementById('toaster-icon');
    const toasterMessage = document.getElementById('toaster-message');

    // App state
    let mediaRecorder;
    let audioContext;
    let analyser;
    let gainNode;
    let stream;
    let recordingChunks = [];
    let recordings = [];
    let startTime = 0;
    let elapsedTime = 0;
    let timerInterval;
    let isRecording = false;
    let isPaused = false;
    let currentPlayingAudio = null;
    let currentRenameCallback = null;
    let audioDataArray;
    let canvasWidth;
    let canvasHeight;
    let animationFrame;
    let darkMode = localStorage.getItem('darkMode') === 'true';

    // Initialize app
    function init() {
        try {
            // Load recordings from localStorage
            loadRecordings();

            resizeCanvas();
            updateRecordingsList();
            updateTheme();
            setupEventListeners();

            // Show welcome message with delay
            setTimeout(() => {
                showToast('success', 'Ready to record! Press the Record button to start.');
            }, 500);

            // Show keyboard shortcuts on first visit
            if (!localStorage.getItem('shortcutsShown')) {
                setTimeout(() => {
                    showShortcutsModal();
                    localStorage.setItem('shortcutsShown', 'true');
                }, 1500);
            }
        } catch (error) {
            console.error('Initialization error:', error);
            showToast('error', 'There was a problem initializing the app. Please refresh the page.');
        }
    }

    // Load recordings from localStorage
    function loadRecordings() {
        try {
            const savedRecordings = localStorage.getItem('recordings');
            if (savedRecordings) {
                recordings = JSON.parse(savedRecordings);

                // Validate loaded recordings
                recordings = recordings.filter(recording => {
                    return recording && recording.url && recording.name && recording.timestamp;
                });
            }
        } catch (error) {
            console.error('Error loading recordings:', error);
            recordings = [];
            localStorage.removeItem('recordings');
        }
    }

    // Set up event listeners
    function setupEventListeners() {
        // Recording controls
        recordBtn.addEventListener('click', startRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        resumeBtn.addEventListener('click', resumeRecording);
        stopBtn.addEventListener('click', stopRecording);

        // Recording management
        clearAllBtn.addEventListener('click', confirmClearAll);

        // Modal controls
        renameClose.addEventListener('click', () => hideModal(renameModal));
        renameCancel.addEventListener('click', () => hideModal(renameModal));

        shortcutsClose.addEventListener('click', () => hideModal(shortcutsModal));
        shortcutsOk.addEventListener('click', () => hideModal(shortcutsModal));

        // Theme toggle
        themeToggle.addEventListener('click', toggleTheme);

        // Window resize
        window.addEventListener('resize', resizeCanvas);

        // Keyboard shortcuts
        document.addEventListener('keydown', handleKeyboardShortcuts);
    }

    // Keyboard shortcuts handler
    function handleKeyboardShortcuts(e) {
        // Ignore shortcuts when input is focused
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        switch (e.key) {
            case ' ': // Space bar - start/stop recording
                e.preventDefault();
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
                break;
            case 'p': // P - pause/resume
            case 'P':
                e.preventDefault();
                if (isRecording && !isPaused && !pauseBtn.disabled) {
                    pauseRecording();
                } else if (isRecording && isPaused && !resumeBtn.disabled) {
                    resumeRecording();
                }
                break;
            case 'd': // D - dark mode toggle
            case 'D':
                e.preventDefault();
                toggleTheme();
                break;
            case '?': // ? - show shortcuts
                e.preventDefault();
                showShortcutsModal();
                break;
        }
    }

    // Timer functions
    function startTimer() {
        startTime = Date.now() - elapsedTime;
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 100);
    }

    function pauseTimer() {
        clearInterval(timerInterval);
    }

    function resumeTimer() {
        startTime = Date.now() - elapsedTime;
        timerInterval = setInterval(updateTimer, 100);
    }

    function stopTimer() {
        clearInterval(timerInterval);
        elapsedTime = 0;
        updateTimerDisplay();
    }

    function updateTimer() {
        elapsedTime = Date.now() - startTime;
        updateTimerDisplay();
    }

    function updateTimerDisplay() {
        const totalSeconds = Math.floor(elapsedTime / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        timerDisplay.textContent =
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // Recording functions
    async function startRecording() {
        try {
            // Reset state
            recordingChunks = [];

            // Request microphone access
            stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: noiseReductionCheck.checked,
                    noiseSuppression: noiseReductionCheck.checked,
                    autoGainControl: autoGainCheck.checked
                }
            });

            // Set up audio context for visualization
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            // Apply additional audio processing if needed
            if (autoGainCheck.checked) {
                gainNode = audioContext.createGain();
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0.8;
            }

            // Set up media recorder with options
            const options = {
                mimeType: formatSelect.value,
                audioBitsPerSecond: parseInt(bitrateSelect.value)
            };

            // Check for format support
            if (MediaRecorder.isTypeSupported(options.mimeType)) {
                mediaRecorder = new MediaRecorder(stream, options);
            } else {
                // Fallback to default format
                showToast('error', `Format ${options.mimeType} not supported. Using default format.`);
                mediaRecorder = new MediaRecorder(stream);
            }

            // Start recording
            mediaRecorder.start();
            isRecording = true;
            isPaused = false;

            // Set up visualization
            audioDataArray = new Uint8Array(analyser.frequencyBinCount);
            drawWaveform();

            // Start timer
            startTimer();

            // Add recording animation
            timerDisplay.classList.add('recording-animation');

            // Update UI
            recordBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;

            // Set up data collection
            mediaRecorder.addEventListener('dataavailable', e => {
                if (e.data.size > 0) {
                    recordingChunks.push(e.data);
                }
            });

            // Handle recording stop
            mediaRecorder.addEventListener('stop', finalizeRecording);

            showToast('success', 'Recording started! Speak into your microphone.');
        } catch (error) {
            console.error('Error starting recording:', error);

            // Show user-friendly error message
            if (error.name === 'NotAllowedError') {
                showToast('error', 'Microphone access denied. Please allow access to your microphone.');
            } else if (error.name === 'NotFoundError') {
                showToast('error', 'No microphone found. Please connect a microphone and try again.');
            } else {
                showToast('error', `Could not start recording: ${error.message || 'Unknown error'}`);
            }

            // Reset UI
            resetRecordingState();
        }
    }

    function pauseRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            try {
                mediaRecorder.pause();
                pauseTimer();
                isPaused = true;

                // Update UI
                pauseBtn.disabled = true;
                resumeBtn.disabled = false;
                timerDisplay.classList.remove('recording-animation');

                showToast('success', 'Recording paused');
            } catch (error) {
                console.error('Error pausing recording:', error);
                showToast('error', 'Could not pause recording. Please try stopping instead.');
            }
        }
    }

    function resumeRecording() {
        if (mediaRecorder && mediaRecorder.state === 'paused') {
            try {
                mediaRecorder.resume();
                resumeTimer();
                isPaused = false;

                // Update UI
                pauseBtn.disabled = false;
                resumeBtn.disabled = true;
                timerDisplay.classList.add('recording-animation');

                showToast('success', 'Recording resumed');
            } catch (error) {
                console.error('Error resuming recording:', error);
                showToast('error', 'Could not resume recording. Please try stopping and starting again.');
            }
        }
    }

    function stopRecording() {
        if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
            try {
                mediaRecorder.stop();

                // Stop audio tracks
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                // Clean up
                stopTimer();
                cancelAnimationFrame(animationFrame);
                timerDisplay.classList.remove('recording-animation');

                // Reset UI
                resetRecordingState();
            } catch (error) {
                console.error('Error stopping recording:', error);
                showToast('error', 'Error stopping recording. Please refresh the page.');
                resetRecordingState();
            }
        }
    }

    function resetRecordingState() {
        // Reset recording state
        isRecording = false;
        isPaused = false;

        // Reset UI
        recordBtn.disabled = false;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;

        // Stop animation
        timerDisplay.classList.remove('recording-animation');

        // Clean up resources
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }

        // Stop visualization
        cancelAnimationFrame(animationFrame);
    }

    function finalizeRecording() {
        // Check if we have data
        if (recordingChunks.length === 0) {
            showToast('error', 'No audio data captured. Please try recording again.');
            return;
        }

        try {
            // Generate default filename
            const timestamp = new Date().toISOString();
            const defaultName = `Recording ${new Date().toLocaleString()}`;

            // Create blob
            const format = formatSelect.value.split('/')[1];
            const blob = new Blob(recordingChunks, {type: formatSelect.value});
            const audioUrl = URL.createObjectURL(blob);

            // Show rename dialog
            showRenameModal(defaultName, (name) => {
                // Save recording
                const recording = {
                    id: Date.now().toString(),
                    name: name || defaultName,
                    url: audioUrl,
                    format: format,
                    timestamp: timestamp,
                    duration: elapsedTime,
                    size: blob.size
                };

                recordings.unshift(recording);
                saveRecordings();
                updateRecordingsList();
                showToast('success', 'Recording saved successfully!');
            });
        } catch (error) {
            console.error('Error finalizing recording:', error);
            showToast('error', 'Could not save recording. Please try again.');
        }
    }

    // Recording management
    function saveRecordings() {
        try {
            localStorage.setItem('recordings', JSON.stringify(recordings));
        } catch (e) {
            console.error('Error saving to localStorage:', e);
            showToast('error', 'Could not save recordings. Local storage may be full.');

            // Try to clear some space
            if (recordings.length > 5) {
                recordings = recordings.slice(0, 5); // Keep only the latest 5
                try {
                    localStorage.setItem('recordings', JSON.stringify(recordings));
                    showToast('warning', 'Limited to the last 5 recordings due to storage constraints.');
                } catch (err) {
                    console.error('Still cannot save after reducing:', err);
                }
            }
        }
    }

    function updateRecordingsList() {
        if (recordings.length === 0) {
            recordingsList.innerHTML = '';
            noRecordings.classList.remove('hidden');
            return;
        }

        noRecordings.classList.add('hidden');
        recordingsList.innerHTML = '';

        recordings.forEach((recording, index) => {
            const formattedDuration = formatDuration(recording.duration);
            const formattedSize = formatSize(recording.size || 0);
            const date = new Date(recording.timestamp).toLocaleString();

            const li = document.createElement('li');
            li.className = 'recording-item';
            li.dataset.index = index;

            li.innerHTML = `
            <div class="recording-info">
                <h3 class="recording-title">${escapeHtml(recording.name)}</h3>
                <div class="recording-meta">
                    <span>${date}</span>
                    <span>${formattedDuration}</span>
                    <span>${formattedSize}</span>
                    <span>${(recording.format || 'audio').toUpperCase()}</span>
                </div>
            </div>
            <div class="recording-actions">
                <button class="recording-btn recording-btn-play" data-action="play">
                    <span>‚ñ∂ Play</span>
                </button>
                <button class="recording-btn" data-action="download">
                    <span>‚¨á Download</span>
                </button>
                <button class="recording-btn" data-action="rename">
                    <span>‚úè Rename</span>
                </button>
                <button class="recording-btn recording-btn-delete" data-action="delete">
                    <span>üóë Delete</span>
                </button>
            </div>
            <audio class="audio-player hidden" controls></audio>
        `;

            li.querySelectorAll('.recording-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = btn.dataset.action;
                    handleRecordingAction(action, index);
                });
            });

            recordingsList.appendChild(li);
        });
    }

    function handleRecordingAction(action, index) {
        // Validate index
        if (index < 0 || index >= recordings.length) {
            showToast('error', 'Invalid recording selected.');
            return;
        }

        const recording = recordings[index];

        switch (action) {
            case 'play':
                togglePlayback(index);
                break;
            case 'download':
                downloadRecording(index);
                break;
            case 'rename':
                showRenameModal(recording.name, (newName) => {
                    if (newName && newName.trim()) {
                        recordings[index].name = newName.trim();
                        saveRecordings();
                        updateRecordingsList();
                        showToast('success', 'Recording renamed successfully');
                    }
                });
                break;
            case 'delete':
                if (confirm('Are you sure you want to delete this recording?')) {
                    URL.revokeObjectURL(recording.url);
                    recordings.splice(index, 1);
                    saveRecordings();
                    updateRecordingsList();
                    showToast('success', 'Recording deleted');
                }
                break;
        }
    }

    function togglePlayback(index) {
        const recording = recordings[index];
        const recordingItem = recordingsList.querySelector(`[data-index="${index}"]`);

        if (!recordingItem) {
            console.error('Recording element not found for index:', index);
            return;
        }

        const audioPlayer = recordingItem.querySelector('.audio-player');
        const playButton = recordingItem.querySelector('[data-action="play"]');

        // Stop any currently playing audio
        if (currentPlayingAudio && currentPlayingAudio !== audioPlayer) {
            currentPlayingAudio.pause();
            currentPlayingAudio.currentTime = 0;
            currentPlayingAudio.classList.add('hidden');

            const oldPlayButton = currentPlayingAudio.parentNode.querySelector('[data-action="play"]');
            if (oldPlayButton) {
                oldPlayButton.innerHTML = '<span>‚ñ∂ Play</span>';
            }
        }

        if (audioPlayer.classList.contains('hidden')) {
            // Start playback
            audioPlayer.src = recording.url;
            audioPlayer.classList.remove('hidden');
            audioPlayer.play().catch(error => {
                console.error('Error playing audio:', error);
                showToast('error', 'Could not play recording. The audio may be corrupted.');
            });

            playButton.innerHTML = '<span>‚è∏ Pause</span>';
            currentPlayingAudio = audioPlayer;

            audioPlayer.onended = () => {
                playButton.innerHTML = '<span>‚ñ∂ Play</span>';
            };
        } else if (audioPlayer.paused) {
            // Resume playback
            audioPlayer.play().catch(error => {
                console.error('Error resuming audio:', error);
                showToast('error', 'Could not resume playback.');
            });
            playButton.innerHTML = '<span>‚è∏ Pause</span>';
        } else {
            // Pause playback
            audioPlayer.pause();
            playButton.innerHTML = '<span>‚ñ∂ Play</span>';
        }
    }

    function downloadRecording(index) {
        const recording = recordings[index];

        try {
            const a = document.createElement('a');
            a.href = recording.url;
            a.download = `${recording.name.replace(/[/\\?%*:|"<>]/g, '-')}.${recording.format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            showToast('success', 'Downloading recording...');
        } catch (error) {
            console.error('Error downloading recording:', error);
            showToast('error', 'Could not download recording. Please try again.');
        }
    }

    function confirmClearAll() {
        if (recordings.length === 0) return;

        if (confirm('Are you sure you want to delete all recordings? This cannot be undone.')) {
            try {
                // Clean up blob URLs
                recordings.forEach(recording => {
                    if (recording.url) {
                        URL.revokeObjectURL(recording.url);
                    }
                });

                recordings = [];
                saveRecordings();
                updateRecordingsList();
                showToast('success', 'All recordings cleared');
            } catch (error) {
                console.error('Error clearing recordings:', error);
                showToast('error', 'Could not clear all recordings. Please refresh and try again.');
            }
        }
    }

    // Visualization functions
    function resizeCanvas() {
        const visualizerContainer = document.querySelector('.visualizer-container');
        canvasWidth = visualizerContainer.clientWidth;
        canvasHeight = visualizerContainer.clientHeight;

        waveformCanvas.width = canvasWidth;
        waveformCanvas.height = canvasHeight;

        // Redraw waveform if we're recording
        if (isRecording && audioDataArray) {
            drawWaveform();
        } else {
            // Draw empty waveform
            waveformCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            waveformCtx.lineWidth = 2;
            waveformCtx.strokeStyle = darkMode ? '#4cc9f0' : '#4361ee';
            waveformCtx.beginPath();
            waveformCtx.moveTo(0, canvasHeight / 2);
            waveformCtx.lineTo(canvasWidth, canvasHeight / 2);
            waveformCtx.stroke();
        }
    }

    function drawWaveform() {
        if (!audioContext || !analyser || !audioDataArray) return;

        // Clear canvas
        waveformCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Get audio data
        analyser.getByteTimeDomainData(audioDataArray);

        // Calculate volume level for the meter
        let sum = 0;
        for (let i = 0; i < audioDataArray.length; i++) {
            sum += Math.abs((audioDataArray[i] - 128) / 128);
        }
        const volume = sum / audioDataArray.length;
        volumeLevel.style.height = `${Math.min(100, volume * 400)}%`;

        // Draw waveform
        waveformCtx.lineWidth = 2;
        waveformCtx.strokeStyle = darkMode ? '#4cc9f0' : '#4361ee';
        waveformCtx.beginPath();

        const sliceWidth = canvasWidth / audioDataArray.length;
        let x = 0;

        for (let i = 0; i < audioDataArray.length; i++) {
            const v = audioDataArray[i] / 128.0;
            const y = v * canvasHeight / 2;

            if (i === 0) {
                waveformCtx.moveTo(x, y);
            } else {
                waveformCtx.lineTo(x, y);
            }

            x += sliceWidth;
        }

        waveformCtx.lineTo(canvasWidth, canvasHeight / 2);
        waveformCtx.stroke();

        // Continue animation
        if (isRecording) {
            animationFrame = requestAnimationFrame(drawWaveform);
        }
    }

    // UI functions
    function showRenameModal(name, callback) {
        // Clear any previous handlers
        if (currentRenameCallback) {
            renameSave.removeEventListener('click', currentRenameCallback);
            renameInput.removeEventListener('keydown', currentRenameCallback);
        }

        // Set the initial value
        renameInput.value = name || '';

        // Set focus with a slight delay to ensure modal is visible
        setTimeout(() => {
            renameInput.focus();
            renameInput.select();
        }, 50);

        // Create the handler functions
        const handleSave = () => {
            callback(renameInput.value.trim());
            hideModal(renameModal);
        };

        const handleKeydown = (e) => {
            if (e.key === 'Enter') {
                handleSave();
            } else if (e.key === 'Escape') {
                hideModal(renameModal);
            }
        };

        // Store reference to callback
        currentRenameCallback = handleSave;

        // Add the event listeners
        renameSave.addEventListener('click', handleSave);
        renameInput.addEventListener('keydown', handleKeydown);

        showModal(renameModal);
    }

    function showShortcutsModal() {
        showModal(shortcutsModal);
    }

    function showModal(modal) {
        modal.classList.add('active');
    }

    function hideModal(modal) {
        modal.classList.remove('active');
    }

    function toggleTheme() {
        darkMode = !darkMode;
        localStorage.setItem('darkMode', darkMode);
        updateTheme();
    }

    function updateTheme() {
        if (darkMode) {
            document.body.classList.add('dark-mode');
            themeToggle.textContent = '‚òÄÔ∏è';
            themeToggle.setAttribute('aria-label', 'Switch to light mode');
        } else {
            document.body.classList.remove('dark-mode');
            themeToggle.textContent = 'üåô';
            themeToggle.setAttribute('aria-label', 'Switch to dark mode');
        }

        // Redraw visualization if needed
        if (waveformCanvas && waveformCtx) {
            resizeCanvas();
        }
    }

    function showToast(type, message) {
        // Clear any existing timers
        if (toaster.timeoutId) {
            clearTimeout(toaster.timeoutId);
        }

        toaster.className = `toaster toaster-${type}`;
        toasterIcon.textContent = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';
        toasterMessage.textContent = message;

        toaster.classList.add('show');

        // Set a timeout to hide the toast
        toaster.timeoutId = setTimeout(() => {
            toaster.classList.remove('show');
        }, 3000);
    }

    // Helper functions
    function formatDuration(ms) {
        if (!ms) return '00:00';

        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function formatSize(bytes) {
        if (!bytes) return '0 B';

        if (bytes < 1024) {
            return bytes + ' B';
        } else if (bytes < 1024 * 1024) {
            return (bytes / 1024).toFixed(1) + ' KB';
        } else {
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
    }

    function escapeHtml(str) {
        if (!str) return '';

        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // Browser compatibility check
    function checkBrowserCompatibility() {
        const audioCompatible = !!(window.AudioContext || window.webkitAudioContext);
        const recorderCompatible = !!window.MediaRecorder;

        if (!audioCompatible || !recorderCompatible) {
            const message = 'Your browser may not fully support all features of this application. ' +
                'For best results, please use the latest version of Chrome, Firefox, or Edge.';
            showToast('warning', message);
        }
    }

    // Initialize app on load
    window.addEventListener('DOMContentLoaded', () => {
        init();
        checkBrowserCompatibility();
    });
</script>
<script src="../logo.js"></script>
</body>
</html>