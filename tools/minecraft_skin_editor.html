<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Skin Editor - Professional</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f0f0f; color: #fff; overflow: hidden; user-select: none; }
        .container { display: grid; grid-template-rows: 56px 1fr 32px; height: 100vh; }
        .header { background: linear-gradient(to bottom, #1a1a1a, #141414); display: flex; align-items: center; padding: 0 20px; gap: 20px; border-bottom: 1px solid #2a2a2a; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        .logo { display: flex; align-items: center; gap: 10px; }
        .logo img { width: 32px; height: 32px; }
        .logo h1 { font-size: 20px; font-weight: 600; color: #fff; }
        .header-actions { margin-left: auto; display: flex; gap: 8px; }
        .btn { background: #2a2a2a; border: 1px solid #3a3a3a; color: #fff; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .btn:hover { background: #3a3a3a; border-color: #4a4a4a; transform: translateY(-1px); }
        .btn.primary { background: #5865F2; border-color: #5865F2; }
        .btn.primary:hover { background: #6974F8; border-color: #6974F8; }
        .btn svg { width: 16px; height: 16px; fill: currentColor; }
        .main { display: grid; grid-template-columns: 72px 1fr 400px; height: calc(100vh - 88px); background: #0a0a0a; }
        .toolbar { background: #141414; padding: 12px; display: flex; flex-direction: column; gap: 8px; border-right: 1px solid #2a2a2a; }
        .tool { width: 48px; height: 48px; background: #1f1f1f; border: 2px solid transparent; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; position: relative; }
        .tool:hover { background: #2a2a2a; border-color: #3a3a3a; }
        .tool.active { border-color: #5865F2; background: #2a2a2a; }
        .tool.active::after { content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 4px; height: 4px; background: #5865F2; border-radius: 50%; }
        .tool svg { width: 24px; height: 24px; fill: #aaa; }
        .tool.active svg { fill: #fff; }
        .tooltip { position: absolute; left: 60px; top: 50%; transform: translateY(-50%); background: #2a2a2a; padding: 6px 10px; border-radius: 4px; font-size: 12px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s; border: 1px solid #3a3a3a; z-index: 1000; }
        .tool:hover .tooltip { opacity: 1; }
        .editor-panel { display: flex; flex-direction: column; padding: 20px; gap: 20px; overflow: hidden; }
        .canvas-section { flex: 1; background: #141414; border-radius: 12px; padding: 20px; display: flex; flex-direction: column; gap: 15px; border: 1px solid #2a2a2a; }
        .section-header { display: flex; align-items: center; justify-content: space-between; }
        .section-title { font-size: 16px; font-weight: 600; color: #fff; }
        .view-toggle { display: flex; gap: 4px; background: #1a1a1a; padding: 2px; border-radius: 6px; }
        .view-btn { padding: 6px 12px; background: transparent; border: none; color: #aaa; cursor: pointer; border-radius: 4px; font-size: 13px; transition: all 0.2s; }
        .view-btn.active { background: #2a2a2a; color: #fff; }
        .canvas-wrapper { flex: 1; background: #0a0a0a; border-radius: 8px; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; border: 1px solid #1a1a1a; }
        .canvas-container { position: relative; }
        #skinCanvas { image-rendering: pixelated; cursor: crosshair; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        #templateOverlay { position: absolute; top: 0; left: 0; pointer-events: none; opacity: 0.3; }
        .part-label { position: absolute; background: rgba(88, 101, 242, 0.9); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; pointer-events: none; white-space: nowrap; }
        .controls-section { background: #141414; border-radius: 12px; padding: 20px; border: 1px solid #2a2a2a; }
        .color-picker-container { display: flex; gap: 15px; margin-bottom: 15px; }
        .color-wheel-wrapper { position: relative; }
        #colorWheel { width: 140px; height: 140px; border-radius: 50%; cursor: crosshair; box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        .color-info { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .current-color { width: 100%; height: 60px; border-radius: 8px; border: 2px solid #2a2a2a; position: relative; overflow: hidden; background-size: 8px 8px; background-position: 0 0, 4px 4px; }
        .current-color::before { content: ''; position: absolute; inset: 0; background: linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333), linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333); background-size: 8px 8px; background-position: 0 0, 4px 4px; }
        .current-color::after { content: ''; position: absolute; inset: 0; }
        .color-value { font-family: 'Monaco', 'Consolas', monospace; font-size: 13px; color: #aaa; margin-top: 5px; }
        .color-sliders { display: flex; flex-direction: column; gap: 8px; }
        .slider-row { display: flex; align-items: center; gap: 10px; }
        .slider-label { width: 20px; font-size: 12px; color: #888; }
        .slider { flex: 1; height: 4px; appearance: none; background: #2a2a2a; border-radius: 2px; outline: none; }
        .slider::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #5865F2; border-radius: 50%; cursor: pointer; }
        .slider::-moz-range-thumb { width: 12px; height: 12px; background: #5865F2; border-radius: 50%; cursor: pointer; border: none; }
        .recent-colors { display: flex; gap: 6px; flex-wrap: wrap; }
        .color-swatch { width: 28px; height: 28px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; position: relative; overflow: hidden; }
        .color-swatch:hover { border-color: #5865F2; transform: scale(1.1); }
        .color-swatch::before { content: ''; position: absolute; inset: 0; background: linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333), linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333); background-size: 6px 6px; background-position: 0 0, 3px 3px; }
        .options { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px; }
        .option { display: flex; align-items: center; gap: 8px; }
        .checkbox { width: 18px; height: 18px; appearance: none; background: #1a1a1a; border: 2px solid #3a3a3a; border-radius: 4px; cursor: pointer; position: relative; }
        .checkbox:checked { background: #5865F2; border-color: #5865F2; }
        .checkbox:checked::after { content: 'âœ“'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 12px; }
        .preview-panel { background: #141414; display: flex; flex-direction: column; border-left: 1px solid #2a2a2a; }
        .preview-header { padding: 20px; border-bottom: 1px solid #2a2a2a; }
        .model-toggle { display: flex; gap: 8px; background: #1a1a1a; padding: 4px; border-radius: 8px; }
        .model-btn { flex: 1; padding: 8px; background: transparent; border: none; color: #aaa; cursor: pointer; border-radius: 6px; transition: all 0.2s; }
        .model-btn.active { background: #2a2a2a; color: #fff; }
        #preview3d { flex: 1; position: relative; }
        .preview-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 8px; }
        .preview-btn { width: 36px; height: 36px; background: rgba(20, 20, 20, 0.9); border: 1px solid #3a3a3a; color: #aaa; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .preview-btn:hover { background: #2a2a2a; color: #fff; border-color: #4a4a4a; }
        .zoom-controls { position: absolute; bottom: 15px; right: 15px; display: flex; align-items: center; gap: 8px; background: rgba(20, 20, 20, 0.9); padding: 8px 12px; border-radius: 8px; border: 1px solid #2a2a2a; }
        .zoom-btn { width: 28px; height: 28px; background: #2a2a2a; border: 1px solid #3a3a3a; color: #fff; border-radius: 4px; cursor: pointer; font-size: 16px; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: #3a3a3a; }
        .zoom-value { font-size: 13px; color: #aaa; min-width: 45px; text-align: center; }
        .status-bar { background: #141414; border-top: 1px solid #2a2a2a; display: flex; align-items: center; padding: 0 20px; font-size: 13px; color: #888; gap: 20px; }
        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-separator { width: 1px; height: 16px; background: #2a2a2a; }
        input[type="file"] { display: none; }
        .loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .loader { width: 48px; height: 48px; border: 3px solid #2a2a2a; border-top-color: #5865F2; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .main { grid-template-columns: 72px 1fr 350px; }
        }
        @media (max-width: 1000px) {
            .main { grid-template-columns: 72px 1fr 300px; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="logo">
            <svg width="32" height="32" viewBox="0 0 32 32" fill="none">
                <rect width="32" height="32" rx="8" fill="#5865F2"/>
                <rect x="8" y="8" width="6" height="6" fill="white"/>
                <rect x="18" y="8" width="6" height="6" fill="white"/>
                <rect x="10" y="18" width="12" height="4" fill="white"/>
            </svg>
            <h1>Minecraft Skin Editor</h1>
        </div>
        <div class="header-actions">
            <button class="btn" onclick="newSkin()">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                New
            </button>
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                <svg viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
                Import
            </button>
            <button class="btn primary" onclick="saveSkin()">
                <svg viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
                Export
            </button>
        </div>
    </div>
    <div class="main">
        <div class="toolbar">
            <div class="tool active" data-tool="pencil" onclick="selectTool('pencil')">
                <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                <span class="tooltip">Pencil (B)</span>
            </div>
            <div class="tool" data-tool="eraser" onclick="selectTool('eraser')">
                <svg viewBox="0 0 24 24"><path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83L5.03 20H12v-2H6.41L14 10.41 21.59 18c.78-.78.78-2.05 0-2.83l-4.45-4.44c-.39-.39-.9-.59-1.41-.59z"/></svg>
                <span class="tooltip">Eraser (E)</span>
            </div>
            <div class="tool" data-tool="picker" onclick="selectTool('picker')">
                <svg viewBox="0 0 24 24"><path d="M20.71 5.63l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z"/></svg>
                <span class="tooltip">Color Picker (I)</span>
            </div>
            <div class="tool" data-tool="fill" onclick="selectTool('fill')">
                <svg viewBox="0 0 24 24"><path d="M16.56 8.94L7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12zM5.21 10L10 5.21 14.79 10H5.21zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5z"/></svg>
                <span class="tooltip">Fill (G)</span>
            </div>
            <div class="tool" data-tool="line" onclick="selectTool('line')">
                <svg viewBox="0 0 24 24"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>
                <span class="tooltip">Line (L)</span>
            </div>
            <div class="tool" data-tool="rect" onclick="selectTool('rect')">
                <svg viewBox="0 0 24 24"><path d="M3 3h18v18H3z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                <span class="tooltip">Rectangle (R)</span>
            </div>
        </div>
        <div class="editor-panel">
            <div class="canvas-section">
                <div class="section-header">
                    <h3 class="section-title">Skin Editor</h3>
                    <div class="view-toggle">
                        <button class="view-btn active" onclick="setView('edit', event)">Edit</button>
                        <button class="view-btn" onclick="setView('template', event)">Template</button>
                        <button class="view-btn" onclick="setView('preview', event)">2D Preview</button>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-container">
                        <canvas id="skinCanvas"></canvas>
                        <canvas id="templateOverlay"></canvas>
                    </div>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoom(-1)">âˆ’</button>
                        <span class="zoom-value">100%</span>
                        <button class="zoom-btn" onclick="zoom(1)">+</button>
                    </div>
                </div>
            </div>
            <div class="controls-section">
                <h3 class="section-title" style="margin-bottom: 15px;">Color & Tools</h3>
                <div class="color-picker-container">
                    <div class="color-wheel-wrapper">
                        <canvas id="colorWheel"></canvas>
                    </div>
                    <div class="color-info">
                        <div class="current-color" id="currentColor"></div>
                        <div class="color-value" id="colorValue">#FF0000</div>
                        <div class="color-sliders">
                            <div class="slider-row">
                                <span class="slider-label">A</span>
                                <input type="range" class="slider" id="alphaSlider" min="0" max="255" value="255">
                                <span id="alphaValue" style="width: 30px; text-align: right; font-size: 12px;">255</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="recent-colors" id="recentColors"></div>
                <div class="options">
                    <label class="option">
                        <input type="checkbox" class="checkbox" id="gridToggle" onchange="updateView()">
                        <span>Show Grid</span>
                    </label>
                    <label class="option">
                        <input type="checkbox" class="checkbox" id="symmetryToggle">
                        <span>X Symmetry</span>
                    </label>
                    <label class="option">
                        <input type="checkbox" class="checkbox" id="showLabels" checked onchange="updateView()">
                        <span>Show Labels</span>
                    </label>
                    <label class="option">
                        <input type="checkbox" class="checkbox" id="autoRotate">
                        <span>Auto Rotate</span>
                    </label>
                </div>
            </div>
        </div>
        <div class="preview-panel">
            <div class="preview-header">
                <h3 class="section-title">3D Preview</h3>
                <div class="model-toggle">
                    <button class="model-btn active" onclick="setModel('steve', event)">Steve</button>
                    <button class="model-btn" onclick="setModel('alex', event)">Alex</button>
                </div>
            </div>
            <div id="preview3d"></div>
            <div class="preview-controls">
                <button class="preview-btn" onclick="resetCamera()" title="Reset View">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                </button>
                <button class="preview-btn" onclick="toggleAnimation()" title="Toggle Animation">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                </button>
            </div>
        </div>
    </div>
    <div class="status-bar">
        <div class="status-item">
            <span>Position:</span>
            <span id="mousePos">- , -</span>
        </div>
        <div class="status-separator"></div>
        <div class="status-item">
            <span>Size:</span>
            <span>64 Ã— 64</span>
        </div>
        <div class="status-separator"></div>
        <div class="status-item">
            <span>Tool:</span>
            <span id="currentToolName">Pencil</span>
        </div>
    </div>
</div>
<input type="file" id="fileInput" accept="image/png" onchange="loadSkin(event)">
<script>
    const SKIN_WIDTH = 64, SKIN_HEIGHT = 64;
    const SKIN_PARTS = {
        head: { front: [8,8,8,8], right: [0,8,8,8], back: [24,8,8,8], left: [16,8,8,8], top: [8,0,8,8], bottom: [16,0,8,8] },
        body: { front: [20,20,8,12], right: [16,20,4,12], back: [32,20,8,12], left: [28,20,4,12], top: [20,16,8,4], bottom: [28,16,8,4] },
        armRight: { front: [44,20,4,12], right: [40,20,4,12], back: [52,20,4,12], left: [48,20,4,12], top: [44,16,4,4], bottom: [48,16,4,4] },
        armLeft: { front: [36,52,4,12], right: [32,52,4,12], back: [44,52,4,12], left: [40,52,4,12], top: [36,48,4,4], bottom: [40,48,4,4] },
        legRight: { front: [4,20,4,12], right: [0,20,4,12], back: [12,20,4,12], left: [8,20,4,12], top: [4,16,4,4], bottom: [8,16,4,4] },
        legLeft: { front: [20,52,4,12], right: [16,52,4,12], back: [28,52,4,12], left: [24,52,4,12], top: [20,48,4,4], bottom: [24,48,4,4] },
// Overlay parts
        headOverlay: { front: [40,8,8,8], right: [32,8,8,8], back: [56,8,8,8], left: [48,8,8,8], top: [40,0,8,8], bottom: [48,0,8,8] },
        bodyOverlay: { front: [20,36,8,12], right: [16,36,4,12], back: [32,36,8,12], left: [28,36,4,12], top: [20,32,8,4], bottom: [28,32,8,4] },
        armRightOverlay: { front: [44,36,4,12], right: [40,36,4,12], back: [52,36,4,12], left: [48,36,4,12], top: [44,32,4,4], bottom: [48,32,4,4] },
        armLeftOverlay: { front: [52,52,4,12], right: [48,52,4,12], back: [60,52,4,12], left: [56,52,4,12], top: [52,48,4,4], bottom: [56,48,4,4] },
        legRightOverlay: { front: [4,36,4,12], right: [0,36,4,12], back: [12,36,4,12], left: [8,36,4,12], top: [4,32,4,4], bottom: [8,32,4,4] },
        legLeftOverlay: { front: [4,52,4,12], right: [0,52,4,12], back: [12,52,4,12], left: [8,52,4,12], top: [4,48,4,4], bottom: [8,48,4,4] }
    };

    let canvas, ctx, templateCanvas, templateCtx, skinData, currentTool = 'pencil', currentColor = '#FF0000', currentAlpha = 255;
    let zoomLevel = 8, scene, camera, renderer, skinTexture, model, controls;
    let isDrawing = false, history = [], historyStep = -1, recentColors = [], currentView = 'edit';
    let startX, startY, isAnimating = false, modelType = 'steve';
    let animationId = null;

    const toolNames = {
        pencil: 'Pencil',
        eraser: 'Eraser',
        picker: 'Color Picker',
        fill: 'Fill',
        line: 'Line',
        rect: 'Rectangle'
    };

    function init() {
        canvas = document.getElementById('skinCanvas');
        ctx = canvas.getContext('2d', { willReadFrequently: true, imageSmoothingEnabled: false });
        templateCanvas = document.getElementById('templateOverlay');
        templateCtx = templateCanvas.getContext('2d');
        canvas.width = templateCanvas.width = SKIN_WIDTH;
        canvas.height = templateCanvas.height = SKIN_HEIGHT;
        createDefaultSkin();
        initColorWheel();
        init3DPreview();
        updateView();
        saveHistory();
        setupEventListeners();
        updateStatusBar();
        addRecentColor(currentColor);
    }

    function createDefaultSkin() {
        skinData = ctx.createImageData(SKIN_WIDTH, SKIN_HEIGHT);
// Fill with transparent background first
        for (let i = 0; i < skinData.data.length; i += 4) {
            skinData.data[i + 3] = 0; // Alpha = 0
        }
// Default Steve skin colors
        const defaultColors = {
            skin: [245, 209, 180, 255],
            hair: [60, 45, 35, 255],
            shirt: [0, 162, 232, 255],
            pants: [63, 63, 116, 255],
            shoes: [115, 115, 115, 255],
            eyes: [48, 76, 127, 255],
            white: [255, 255, 255, 255]
        };
// Head
        fillRect(8, 8, 8, 8, defaultColors.skin); // Head front
        fillRect(0, 8, 8, 8, defaultColors.skin); // Head right
        fillRect(16, 8, 8, 8, defaultColors.skin); // Head left
        fillRect(24, 8, 8, 8, defaultColors.skin); // Head back
        fillRect(8, 0, 8, 8, defaultColors.hair); // Head top
        fillRect(16, 0, 8, 8, defaultColors.skin); // Head bottom
// Add face details
        fillRect(10, 10, 1, 1, defaultColors.white); // Left eye white
        fillRect(11, 10, 1, 1, defaultColors.eyes); // Left eye
        fillRect(13, 10, 1, 1, defaultColors.white); // Right eye white
        fillRect(14, 10, 1, 1, defaultColors.eyes); // Right eye
        fillRect(10, 13, 4, 1, defaultColors.hair); // Mouth
// Body
        fillRect(20, 20, 8, 12, defaultColors.shirt); // Body front
        fillRect(16, 20, 4, 12, defaultColors.shirt); // Body right
        fillRect(28, 20, 4, 12, defaultColors.shirt); // Body left
        fillRect(32, 20, 8, 12, defaultColors.shirt); // Body back
        fillRect(20, 16, 8, 4, defaultColors.shirt); // Body top
        fillRect(28, 16, 8, 4, defaultColors.shirt); // Body bottom
// Arms
        fillRect(44, 20, 4, 12, defaultColors.skin); // Right arm front
        fillRect(40, 20, 4, 12, defaultColors.skin); // Right arm right
        fillRect(48, 20, 4, 12, defaultColors.skin); // Right arm left
        fillRect(52, 20, 4, 12, defaultColors.skin); // Right arm back
        fillRect(44, 16, 4, 4, defaultColors.skin); // Right arm top
        fillRect(48, 16, 4, 4, defaultColors.skin); // Right arm bottom
        fillRect(36, 52, 4, 12, defaultColors.skin); // Left arm front
        fillRect(32, 52, 4, 12, defaultColors.skin); // Left arm right
        fillRect(40, 52, 4, 12, defaultColors.skin); // Left arm left
        fillRect(44, 52, 4, 12, defaultColors.skin); // Left arm back
        fillRect(36, 48, 4, 4, defaultColors.skin); // Left arm top
        fillRect(40, 48, 4, 4, defaultColors.skin); // Left arm bottom
// Legs
        fillRect(4, 20, 4, 12, defaultColors.pants); // Right leg front
        fillRect(0, 20, 4, 12, defaultColors.pants); // Right leg right
        fillRect(8, 20, 4, 12, defaultColors.pants); // Right leg left
        fillRect(12, 20, 4, 12, defaultColors.pants); // Right leg back
        fillRect(4, 16, 4, 4, defaultColors.pants); // Right leg top
        fillRect(8, 16, 4, 4, defaultColors.shoes); // Right leg bottom
        fillRect(20, 52, 4, 12, defaultColors.pants); // Left leg front
        fillRect(16, 52, 4, 12, defaultColors.pants); // Left leg right
        fillRect(24, 52, 4, 12, defaultColors.pants); // Left leg left
        fillRect(28, 52, 4, 12, defaultColors.pants); // Left leg back
        fillRect(20, 48, 4, 4, defaultColors.pants); // Left leg top
        fillRect(24, 48, 4, 4, defaultColors.shoes); // Left leg bottom
        ctx.putImageData(skinData, 0, 0);
    }

    function fillRect(x, y, w, h, color) {
        for (let i = x; i < x + w; i++) {
            for (let j = y; j < y + h; j++) {
                if (i >= 0 && i < SKIN_WIDTH && j >= 0 && j < SKIN_HEIGHT) {
                    const index = (j * SKIN_WIDTH + i) * 4;
                    skinData.data[index] = color[0];
                    skinData.data[index + 1] = color[1];
                    skinData.data[index + 2] = color[2];
                    skinData.data[index + 3] = color[3];
                }
            }
        }
    }

    function initColorWheel() {
        const wheel = document.getElementById('colorWheel');
        const ctx = wheel.getContext('2d');
        wheel.width = wheel.height = 140;
        const centerX = wheel.width / 2, centerY = wheel.height / 2, radius = 65;

// Create color wheel
        for (let angle = 0; angle < 360; angle++) {
            const startAngle = (angle - 1) * Math.PI / 180;
            const endAngle = angle * Math.PI / 180;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.closePath();
            ctx.fillStyle = `hsl(${angle}, 100%, 50%)`;
            ctx.fill();
        }

// Add white gradient
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, wheel.width, wheel.height);

// Add black gradient
        const gradient2 = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient2.addColorStop(0, 'rgba(0,0,0,0)');
        gradient2.addColorStop(0.7, 'rgba(0,0,0,0)');
        gradient2.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = gradient2;
        ctx.fillRect(0, 0, wheel.width, wheel.height);

        wheel.addEventListener('click', e => {
            const rect = wheel.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= radius) {
                const imageData = ctx.getImageData(x, y, 1, 1);
                const [r, g, b] = imageData.data;
                setColor(r, g, b);
            }
        });
    }

    function init3DPreview() {
        const container = document.getElementById('preview3d');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 100, 200);
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(30, 20, 40);
        camera.lookAt(0, 0, 0);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

// Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

// Ground
        const groundGeometry = new THREE.CircleGeometry(30, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -18;
        ground.receiveShadow = true;
        scene.add(ground);

// Create custom controls object
        controls = {
            autoRotate: false,
            update: function() {
                if (this.autoRotate && model) {
                    model.rotation.y += 0.01;
                }
            },
            reset: function() {
                camera.position.set(30, 20, 40);
                camera.lookAt(0, 0, 0);
                if (model) {
                    model.rotation.set(0, 0, 0);
                }
            }
        };

        createSteveModel();

// Mouse controls
        let mouseDown = false, mouseX = 0, mouseY = 0;
        renderer.domElement.addEventListener('mousedown', e => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        renderer.domElement.addEventListener('mousemove', e => {
            if (!mouseDown) return;
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            if (model) {
                model.rotation.y += deltaX * 0.01;
                const newRotationX = model.rotation.x + deltaY * 0.01;
                model.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, newRotationX));
            }
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        renderer.domElement.addEventListener('mouseup', () => { mouseDown = false; });
        renderer.domElement.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(delta);
            camera.position.clampLength(20, 100);
        });

        animate();
    }

    function createSteveModel() {
        if (model) scene.remove(model);

// Create texture from skin data
        const canvas2d = document.createElement('canvas');
        canvas2d.width = SKIN_WIDTH;
        canvas2d.height = SKIN_HEIGHT;
        const ctx2d = canvas2d.getContext('2d');
        ctx2d.putImageData(skinData, 0, 0);

        skinTexture = new THREE.CanvasTexture(canvas2d);
        skinTexture.magFilter = THREE.NearestFilter;
        skinTexture.minFilter = THREE.NearestFilter;
        skinTexture.needsUpdate = true;

        const material = new THREE.MeshStandardMaterial({
            map: skinTexture,
            transparent: true,
            alphaTest: 0.1,
            side: THREE.DoubleSide
        });

        const group = new THREE.Group();

// Head (8x8x8)
        const headGeometry = new THREE.BoxGeometry(8, 8, 8);
        setUVs(headGeometry, SKIN_PARTS.head);
        const head = new THREE.Mesh(headGeometry, material);
        head.position.y = 10;
        head.castShadow = true;
        group.add(head);

// Head overlay (8.5x8.5x8.5)
        const headOverlayGeometry = new THREE.BoxGeometry(8.5, 8.5, 8.5);
        setUVs(headOverlayGeometry, SKIN_PARTS.headOverlay);
        const headOverlay = new THREE.Mesh(headOverlayGeometry, material);
        headOverlay.position.y = 10;
        group.add(headOverlay);

// Body (8x12x4)
        const bodyGeometry = new THREE.BoxGeometry(8, 12, 4);
        setUVs(bodyGeometry, SKIN_PARTS.body);
        const body = new THREE.Mesh(bodyGeometry, material);
        body.castShadow = true;
        group.add(body);

// Body overlay
        const bodyOverlayGeometry = new THREE.BoxGeometry(8.5, 12.5, 4.5);
        setUVs(bodyOverlayGeometry, SKIN_PARTS.bodyOverlay);
        const bodyOverlay = new THREE.Mesh(bodyOverlayGeometry, material);
        group.add(bodyOverlay);

// Arms
        const armWidth = modelType === 'alex' ? 3 : 4;
        const armOverlayWidth = modelType === 'alex' ? 3.5 : 4.5;

// Right arm
        const rightArmGeometry = new THREE.BoxGeometry(armWidth, 12, 4);
        setUVs(rightArmGeometry, SKIN_PARTS.armRight);
        const rightArm = new THREE.Mesh(rightArmGeometry, material);
        rightArm.position.set(-(4 + armWidth/2), 0, 0);
        rightArm.castShadow = true;
        group.add(rightArm);

// Right arm overlay
        const rightArmOverlayGeometry = new THREE.BoxGeometry(armOverlayWidth, 12.5, 4.5);
        setUVs(rightArmOverlayGeometry, SKIN_PARTS.armRightOverlay);
        const rightArmOverlay = new THREE.Mesh(rightArmOverlayGeometry, material);
        rightArmOverlay.position.set(-(4 + armWidth/2), 0, 0);
        group.add(rightArmOverlay);

// Left arm
        const leftArmGeometry = new THREE.BoxGeometry(armWidth, 12, 4);
        setUVs(leftArmGeometry, SKIN_PARTS.armLeft);
        const leftArm = new THREE.Mesh(leftArmGeometry, material);
        leftArm.position.set(4 + armWidth/2, 0, 0);
        leftArm.castShadow = true;
        group.add(leftArm);

// Left arm overlay
        const leftArmOverlayGeometry = new THREE.BoxGeometry(armOverlayWidth, 12.5, 4.5);
        setUVs(leftArmOverlayGeometry, SKIN_PARTS.armLeftOverlay);
        const leftArmOverlay = new THREE.Mesh(leftArmOverlayGeometry, material);
        leftArmOverlay.position.set(4 + armWidth/2, 0, 0);
        group.add(leftArmOverlay);

// Legs
// Right leg
        const rightLegGeometry = new THREE.BoxGeometry(4, 12, 4);
        setUVs(rightLegGeometry, SKIN_PARTS.legRight);
        const rightLeg = new THREE.Mesh(rightLegGeometry, material);
        rightLeg.position.set(-2, -12, 0);
        rightLeg.castShadow = true;
        group.add(rightLeg);

// Right leg overlay
        const rightLegOverlayGeometry = new THREE.BoxGeometry(4.5, 12.5, 4.5);
        setUVs(rightLegOverlayGeometry, SKIN_PARTS.legRightOverlay);
        const rightLegOverlay = new THREE.Mesh(rightLegOverlayGeometry, material);
        rightLegOverlay.position.set(-2, -12, 0);
        group.add(rightLegOverlay);

// Left leg
        const leftLegGeometry = new THREE.BoxGeometry(4, 12, 4);
        setUVs(leftLegGeometry, SKIN_PARTS.legLeft);
        const leftLeg = new THREE.Mesh(leftLegGeometry, material);
        leftLeg.position.set(2, -12, 0);
        leftLeg.castShadow = true;
        group.add(leftLeg);

// Left leg overlay
        const leftLegOverlayGeometry = new THREE.BoxGeometry(4.5, 12.5, 4.5);
        setUVs(leftLegOverlayGeometry, SKIN_PARTS.legLeftOverlay);
        const leftLegOverlay = new THREE.Mesh(leftLegOverlayGeometry, material);
        leftLegOverlay.position.set(2, -12, 0);
        group.add(leftLegOverlay);

        model = group;
        scene.add(model);

// Store body parts for animation
        model.userData = {
            head, rightArm, leftArm, rightLeg, leftLeg,
            animationTime: 0
        };
    }

    function setUVs(geometry, partMap) {
        const uvs = [];
        const { front, back, top, bottom, right, left } = partMap;

// Three.js BoxGeometry face order: right, left, top, bottom, front, back
        const faces = [right, left, top, bottom, front, back];

        faces.forEach(([x, y, w, h]) => {
            // Bottom-left
            uvs.push(x / SKIN_WIDTH, 1 - (y + h) / SKIN_HEIGHT);
            // Bottom-right
            uvs.push((x + w) / SKIN_WIDTH, 1 - (y + h) / SKIN_HEIGHT);
            // Top-left
            uvs.push(x / SKIN_WIDTH, 1 - y / SKIN_HEIGHT);
            // Top-right
            uvs.push((x + w) / SKIN_WIDTH, 1 - y / SKIN_HEIGHT);
        });

        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        controls.autoRotate = document.getElementById('autoRotate').checked;
        controls.update();

// Walking animation when enabled
        if (isAnimating && model && model.userData) {
            const { head, rightArm, leftArm, rightLeg, leftLeg, animationTime } = model.userData;
            const time = Date.now() * 0.003;
            const walkSpeed = 2;

            // Head bob
            head.position.y = 10 + Math.sin(time * walkSpeed * 2) * 0.5;

            // Arm swing
            rightArm.rotation.x = Math.sin(time * walkSpeed) * 0.5;
            leftArm.rotation.x = -Math.sin(time * walkSpeed) * 0.5;

            // Leg swing
            rightLeg.rotation.x = -Math.sin(time * walkSpeed) * 0.5;
            leftLeg.rotation.x = Math.sin(time * walkSpeed) * 0.5;
        }

        renderer.render(scene, camera);
    }

    function setupEventListeners() {
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

// Touch support
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

// Alpha slider
        const alphaSlider = document.getElementById('alphaSlider');
        alphaSlider.addEventListener('input', e => {
            currentAlpha = parseInt(e.target.value);
            document.getElementById('alphaValue').textContent = currentAlpha;
            updateColorDisplay();
        });

// Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) redo();
                        else undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 's':
                        e.preventDefault();
                        saveSkin();
                        break;
                    case 'o':
                        e.preventDefault();
                        document.getElementById('fileInput').click();
                        break;
                    case 'n':
                        e.preventDefault();
                        newSkin();
                        break;
                }
            } else {
                switch(e.key.toLowerCase()) {
                    case 'b': selectTool('pencil'); break;
                    case 'e': selectTool('eraser'); break;
                    case 'i': selectTool('picker'); break;
                    case 'g': selectTool('fill'); break;
                    case 'l': selectTool('line'); break;
                    case 'r': selectTool('rect'); break;
                    case '+':
                    case '=':
                        zoom(1);
                        break;
                    case '-':
                    case '_':
                        zoom(-1);
                        break;
                }
            }
        });
    }

    function updateView() {
        const scale = zoomLevel;
        canvas.style.width = templateCanvas.style.width = SKIN_WIDTH * scale + 'px';
        canvas.style.height = templateCanvas.style.height = SKIN_HEIGHT * scale + 'px';
        document.querySelector('.zoom-value').textContent = Math.round(scale / 8 * 100) + '%';

// Update main canvas
        ctx.imageSmoothingEnabled = false;
        ctx.putImageData(skinData, 0, 0);

// Draw template overlay
        templateCtx.clearRect(0, 0, SKIN_WIDTH, SKIN_HEIGHT);
        templateCtx.imageSmoothingEnabled = false;

        if (currentView === 'template' || document.getElementById('showLabels').checked) {
            templateCtx.strokeStyle = 'rgba(88, 101, 242, 0.5)';
            templateCtx.lineWidth = 0.5;
            templateCtx.font = '10px Arial';
            templateCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';

            // Draw part outlines and labels
            const drawPart = (part, label) => {
                Object.entries(part).forEach(([side, [x, y, w, h]]) => {
                    templateCtx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
                    if (document.getElementById('showLabels').checked && side === 'front') {
                        templateCtx.fillText(label, x + 2, y + h - 2);
                    }
                });
            };

            drawPart(SKIN_PARTS.head, 'Head');
            drawPart(SKIN_PARTS.body, 'Body');
            drawPart(SKIN_PARTS.armRight, 'R.Arm');
            drawPart(SKIN_PARTS.armLeft, 'L.Arm');
            drawPart(SKIN_PARTS.legRight, 'R.Leg');
            drawPart(SKIN_PARTS.legLeft, 'L.Leg');
        }

// Draw grid
        if (document.getElementById('gridToggle').checked && zoomLevel >= 8) {
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1 / scale;
            for (let x = 0; x <= SKIN_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, SKIN_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= SKIN_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(SKIN_WIDTH, y);
                ctx.stroke();
            }
            ctx.restore();
        }

// Update 3D texture
        if (skinTexture && renderer) {
            const canvas2d = document.createElement('canvas');
            canvas2d.width = SKIN_WIDTH;
            canvas2d.height = SKIN_HEIGHT;
            const ctx2d = canvas2d.getContext('2d');
            ctx2d.putImageData(skinData, 0, 0);
            skinTexture.image = canvas2d;
            skinTexture.needsUpdate = true;
        }
    }

    function startDrawing(e) {
        if (e.button === 2) return; // Right click
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        startX = Math.floor((e.clientX - rect.left) / zoomLevel);
        startY = Math.floor((e.clientY - rect.top) / zoomLevel);

        if (currentTool === 'pencil' || currentTool === 'eraser') {
            draw(e);
        } else if (currentTool === 'picker') {
            const pixel = getPixel(startX, startY);
            if (pixel.a > 0) {
                setColor(pixel.r, pixel.g, pixel.b, pixel.a);
            }
            isDrawing = false;
        }
    }

    function draw(e) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / zoomLevel);
        const y = Math.floor((e.clientY - rect.top) / zoomLevel);
        updateStatusBar(x, y);

        if (!isDrawing) return;
        if (x < 0 || x >= SKIN_WIDTH || y < 0 || y >= SKIN_HEIGHT) return;

        if (currentTool === 'pencil') {
            drawLine(startX, startY, x, y, currentColor, currentAlpha);
            if (document.getElementById('symmetryToggle').checked) {
                const centerX = SKIN_WIDTH / 2;
                const mirrorStartX = Math.floor(centerX * 2 - startX - 1);
                const mirrorX = Math.floor(centerX * 2 - x - 1);
                drawLine(mirrorStartX, startY, mirrorX, y, currentColor, currentAlpha);
            }
            startX = x;
            startY = y;
        } else if (currentTool === 'eraser') {
            drawLine(startX, startY, x, y, null, 0);
            if (document.getElementById('symmetryToggle').checked) {
                const centerX = SKIN_WIDTH / 2;
                const mirrorStartX = Math.floor(centerX * 2 - startX - 1);
                const mirrorX = Math.floor(centerX * 2 - x - 1);
                drawLine(mirrorStartX, startY, mirrorX, y, null, 0);
            }
            startX = x;
            startY = y;
        }
        updateView();
    }

    function stopDrawing(e) {
        if (!isDrawing) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / zoomLevel);
        const y = Math.floor((e.clientY - rect.top) / zoomLevel);

        if (currentTool === 'fill') {
            if (x >= 0 && x < SKIN_WIDTH && y >= 0 && y < SKIN_HEIGHT) {
                const targetColor = getPixel(x, y);
                floodFill(x, y, targetColor, currentColor, currentAlpha);
            }
        } else if (currentTool === 'line') {
            drawLine(startX, startY, x, y, currentColor, currentAlpha);
            if (document.getElementById('symmetryToggle').checked) {
                const centerX = SKIN_WIDTH / 2;
                const mirrorStartX = Math.floor(centerX * 2 - startX - 1);
                const mirrorX = Math.floor(centerX * 2 - x - 1);
                drawLine(mirrorStartX, startY, mirrorX, y, currentColor, currentAlpha);
            }
        } else if (currentTool === 'rect') {
            drawRect(startX, startY, x, y, currentColor, currentAlpha);
            if (document.getElementById('symmetryToggle').checked) {
                const centerX = SKIN_WIDTH / 2;
                const mirrorStartX = Math.floor(centerX * 2 - startX - 1);
                const mirrorX = Math.floor(centerX * 2 - x - 1);
                drawRect(mirrorStartX, startY, mirrorX, y, currentColor, currentAlpha);
            }
        }

        isDrawing = false;
        saveHistory();
        updateView();
    }

    function drawLine(x0, y0, x1, y1, color, alpha) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
            setPixel(x0, y0, color, alpha);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
    }

    function drawRect(x0, y0, x1, y1, color, alpha) {
        const minX = Math.min(x0, x1);
        const minY = Math.min(y0, y1);
        const maxX = Math.max(x0, x1);
        const maxY = Math.max(y0, y1);
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                setPixel(x, y, color, alpha);
            }
        }
    }

    function setPixel(x, y, color, alpha) {
        if (x < 0 || x >= SKIN_WIDTH || y < 0 || y >= SKIN_HEIGHT) return;
        const index = (y * SKIN_WIDTH + x) * 4;
        if (alpha === 0 || !color) {
            skinData.data[index + 3] = 0;
        } else {
            const rgb = hexToRgb(color) || color.match(/\d+/g)?.map(n => parseInt(n));
            if (rgb) {
                skinData.data[index] = rgb[0];
                skinData.data[index + 1] = rgb[1];
                skinData.data[index + 2] = rgb[2];
                skinData.data[index + 3] = alpha;
            }
        }
    }

    function getPixel(x, y) {
        if (x < 0 || x >= SKIN_WIDTH || y < 0 || y >= SKIN_HEIGHT) {
            return { r: 0, g: 0, b: 0, a: 0 };
        }
        const index = (y * SKIN_WIDTH + x) * 4;
        return {
            r: skinData.data[index],
            g: skinData.data[index + 1],
            b: skinData.data[index + 2],
            a: skinData.data[index + 3]
        };
    }

    function floodFill(x, y, targetColor, fillColor, alpha) {
        const fillRgb = hexToRgb(fillColor) || fillColor.match(/\d+/g)?.map(n => parseInt(n));
        if (!fillRgb) return;
        const newColor = { r: fillRgb[0], g: fillRgb[1], b: fillRgb[2], a: alpha };

        if (colorsMatch(targetColor, newColor)) return;

        const stack = [[x, y]];
        const visited = new Set();

        while (stack.length) {
            const [cx, cy] = stack.pop();
            const key = `${cx},${cy}`;

            if (visited.has(key)) continue;
            visited.add(key);

            if (cx < 0 || cx >= SKIN_WIDTH || cy < 0 || cy >= SKIN_HEIGHT) continue;

            const currentColor = getPixel(cx, cy);
            if (!colorsMatch(currentColor, targetColor)) continue;

            setPixel(cx, cy, fillColor, alpha);

            stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }
    }

    function colorsMatch(c1, c2) {
        return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
    }

    function hexToRgb(hex) {
        if (!hex || typeof hex !== 'string') return null;
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
    }

    function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }

    function setColor(r, g, b, a = 255) {
        currentColor = `rgb(${r},${g},${b})`;
        currentAlpha = a;
        updateColorDisplay();
        addRecentColor(currentColor);
    }

    function updateColorDisplay() {
        const colorDiv = document.getElementById('currentColor');
        const colorAfter = colorDiv.querySelector('::after') || colorDiv;
        const rgb = currentColor.match(/\d+/g);
        if (rgb) {
            colorDiv.style.setProperty('background', `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${currentAlpha / 255})`);
            document.getElementById('colorValue').textContent = rgbToHex(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]));
        }
        document.getElementById('alphaSlider').value = currentAlpha;
        document.getElementById('alphaValue').textContent = currentAlpha;
    }

    function addRecentColor(color) {
        const rgb = color.match(/\d+/g);
        if (!rgb) return;
        const colorKey = `${rgb[0]},${rgb[1]},${rgb[2]},${currentAlpha}`;
        if (!recentColors.find(c => c.key === colorKey)) {
            recentColors.unshift({ color, alpha: currentAlpha, key: colorKey });
            if (recentColors.length > 16) recentColors.pop();
        }
        const container = document.getElementById('recentColors');
        container.innerHTML = '';
        recentColors.forEach((c, i) => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = c.color;
            swatch.style.opacity = c.alpha / 255;
            swatch.title = `${c.color} (Alpha: ${c.alpha})`;
            swatch.onclick = () => {
                const rgb = c.color.match(/\d+/g);
                if (rgb) setColor(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]), c.alpha);
            };
            container.appendChild(swatch);
        });
    }

    function selectTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        canvas.style.cursor = tool === 'picker' ? 'crosshair' : tool === 'fill' ? 'pointer' : 'default';
        updateStatusBar();
    }

    function zoom(direction) {
        const oldZoom = zoomLevel;
        zoomLevel = Math.max(1, Math.min(32, zoomLevel + direction * (zoomLevel >= 8 ? 4 : 2)));
        if (zoomLevel !== oldZoom) {
            updateView();
        }
    }

    function newSkin() {
        if (confirm('Create a new skin? This will clear your current work.')) {
            createDefaultSkin();
            history = [];
            historyStep = -1;
            saveHistory();
            updateView();
        }
    }

    function loadSkin(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                if (img.width !== SKIN_WIDTH || img.height !== SKIN_HEIGHT) {
                    if (!confirm(`This image is ${img.width}x${img.height}. Minecraft skins should be 64x64. The image will be resized. Continue?`)) {
                        return;
                    }
                }

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = SKIN_WIDTH;
                tempCanvas.height = SKIN_HEIGHT;
                const tempCtx = tempCanvas.getContext('2d', { imageSmoothingEnabled: false });
                tempCtx.drawImage(img, 0, 0, SKIN_WIDTH, SKIN_HEIGHT);
                skinData = tempCtx.getImageData(0, 0, SKIN_WIDTH, SKIN_HEIGHT);

                history = [];
                historyStep = -1;
                saveHistory();
                updateView();
            };
            img.onerror = () => {
                alert('Failed to load image. Please ensure it is a valid image file.');
            };
            img.src = e.target.result;
        };
        reader.onerror = () => {
            alert('Failed to read file.');
        };
        reader.readAsDataURL(file);
        event.target.value = ''; // Reset input
    }

    function saveSkin() {
// Create a temporary canvas for export
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = SKIN_WIDTH;
        exportCanvas.height = SKIN_HEIGHT;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.putImageData(skinData, 0, 0);

// Convert to blob and download
        exportCanvas.toBlob(blob => {
            const link = document.createElement('a');
            link.download = `minecraft_skin_${new Date().toISOString().slice(0, 10)}_${Date.now()}.png`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        }, 'image/png');
    }

    function saveHistory() {
        if (historyStep < history.length - 1) {
            history = history.slice(0, historyStep + 1);
        }
        const dataCopy = new Uint8ClampedArray(skinData.data);
        history.push(dataCopy);
        historyStep++;
        if (history.length > 50) { // Increased history size
            history.shift();
            historyStep--;
        }
    }

    function undo() {
        if (historyStep > 0) {
            historyStep--;
            skinData.data.set(history[historyStep]);
            updateView();
        }
    }

    function redo() {
        if (historyStep < history.length - 1) {
            historyStep++;
            skinData.data.set(history[historyStep]);
            updateView();
        }
    }

    function setView(view, event) {
        currentView = view;
        document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
        if (event && event.target) {
            event.target.classList.add('active');
        }
        updateView();
    }

    function setModel(type, event) {
        modelType = type;
        document.querySelectorAll('.model-btn').forEach(btn => btn.classList.remove('active'));
        if (event && event.target) {
            event.target.classList.add('active');
        }
        createSteveModel();
    }

    function resetCamera() {
        controls.reset();
    }

    function toggleAnimation() {
        isAnimating = !isAnimating;
        if (!isAnimating && model && model.userData) {
            // Reset positions
            const { head, rightArm, leftArm, rightLeg, leftLeg } = model.userData;
            if (head) head.position.y = 10;
            if (rightArm) rightArm.rotation.x = 0;
            if (leftArm) leftArm.rotation.x = 0;
            if (rightLeg) rightLeg.rotation.x = 0;
            if (leftLeg) leftLeg.rotation.x = 0;
        }
    }

    function updateStatusBar(x, y) {
        if (x !== undefined && y !== undefined && x >= 0 && x < SKIN_WIDTH && y >= 0 && y < SKIN_HEIGHT) {
            document.getElementById('mousePos').textContent = `${x}, ${y}`;
        } else if (x === undefined) {
            document.getElementById('mousePos').textContent = '-, -';
        }
        document.getElementById('currentToolName').textContent = toolNames[currentTool];
    }

    // Error handling
    window.addEventListener('error', e => {
        console.error('Global error:', e.error);
    });

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        if (camera && renderer) {
            const container = document.getElementById('preview3d');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        if (renderer) {
            renderer.dispose();
        }
    });

    // Performance optimization: Throttle mousemove events
    let drawTimeout;
    const throttledDraw = (e) => {
        if (!drawTimeout) {
            drawTimeout = setTimeout(() => {
                draw(e);
                drawTimeout = null;
            }, 16); // ~60fps
        }
    };

    // Export functions for external use (if needed)
    window.MinecraftSkinEditor = {
        newSkin,
        loadSkin,
        saveSkin,
        undo,
        redo,
        selectTool,
        setModel,
        zoom,
        resetCamera,
        toggleAnimation
    };
</script>
</body>
</html>