<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <title>Enhanced Webcam Filters</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üì∑</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/glfx@0.0.4/glfx.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiRW5oYW5jZWQgV2ViY2FtIEZpbHRlcnMiLCJzaG9ydF9uYW1lIjoiV2ViY2FtIEZpbHRlcnMiLCJzdGFydF91cmwiOiIuLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAiLCJ0aGVtZV9jb2xvciI6IiMwMDAiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgMTAwIDEwMCc+PHRleHQgeT0nLjllbScgZm9udC1zaXplPSc5MCc+8J+UpTwvdGV4dD48L3N2Zz4iLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
</head>
<body class="flex flex-col items-center justify-center min-h-screen m-0 bg-black">
<div id="loadingIndicator" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-90 text-white z-50">
    <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-blue-500 mb-4"></div>
    <div class="text-xl">Initializing camera...</div>
</div>
<div id="errorMessage" class="absolute inset-0 hidden flex-col items-center justify-center bg-black bg-opacity-90 text-red-500 text-xl z-50 p-4 text-center">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
    <span id="errorText"></span>
    <button id="retryButton" class="mt-4 bg-red-600 text-white font-bold py-2 px-4 rounded hover:bg-red-700">Retry</button>
</div>

<div class="flex flex-col h-screen w-full">
    <div class="flex-grow flex items-center justify-center overflow-hidden" id="canvasContainer">
        <canvas id="canvas"></canvas>
        <div class="absolute top-4 right-4 flex flex-col space-y-2">
            <button id="fullscreenBtn" class="bg-gray-800 text-white font-bold py-2 px-4 rounded hover:bg-gray-700 flex items-center justify-center" aria-label="Toggle fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 01-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 011.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 011.414-1.414L15 13.586V12a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="recordBtn" class="bg-red-600 text-white font-bold py-2 px-4 rounded hover:bg-red-700 flex items-center justify-center" aria-label="Record video">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <circle cx="10" cy="10" r="8" />
                </svg>
            </button>
            <button id="snapshotBtn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded hover:bg-blue-700 flex items-center justify-center" aria-label="Take photo">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 5a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586a1 1 0 01-.707-.293l-1.121-1.121A2 2 0 0011.172 3H8.828a2 2 0 00-1.414.586L6.293 4.707A1 1 0 015.586 5H4zm6 9a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        <div class="absolute top-4 left-4">
            <select id="cameraSelect" class="bg-gray-800 text-white rounded px-2 py-1 text-sm">
                <option value="">Loading cameras...</option>
            </select>
        </div>
        <div id="recordingIndicator" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-3 py-1 rounded hidden flex items-center">
            <span class="animate-pulse mr-2">‚óè</span> Recording
            <span id="recordingTime" class="ml-2">00:00</span>
        </div>
    </div>

    <div id="controlPanel" class="p-4 bg-gray-900 bg-opacity-90">
        <div class="flex justify-between items-center mb-2">
            <div class="flex items-center">
                <span id="currentFilterName" class="text-white mr-4">None</span>
                <input type="range" id="intensitySlider" min="0" max="100" value="50" class="w-32 mx-2">
                <span id="intensityValue" class="text-white ml-1">50%</span>
            </div>
            <div class="flex items-center">
                <button id="settingsBtn" class="text-white bg-gray-800 rounded-full p-2 mr-2" aria-label="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                    </svg>
                </button>
                <select id="presetSelect" class="bg-gray-800 text-white rounded px-2 py-1 text-sm">
                    <option value="none">No Preset</option>
                    <option value="vintage">Vintage</option>
                    <option value="vaporwave">Vaporwave</option>
                    <option value="noir">Film Noir</option>
                    <option value="dreamy">Dreamy</option>
                    <option value="comic">Comic Book</option>
                </select>
            </div>
        </div>
        <div class="carousel-container relative flex items-center">
            <button id="prevButton" class="absolute left-0 bg-gray-800 text-white font-bold py-2 px-4 rounded m-1 z-10">
                &lt;
            </button>
            <div id="carousel" class="flex overflow-x-auto hide-scrollbar space-x-2 px-20 mx-auto" style="max-width:90vw;scrollbar-width:none;">
            </div>
            <button id="nextButton" class="absolute right-0 bg-gray-800 text-white font-bold py-2 px-4 rounded m-1 z-10">
                &gt;
            </button>
        </div>
        <div id="keyboardShortcuts" class="text-gray-400 text-xs text-center mt-2">
            Keyboard: ‚Üê ‚Üí to change filters | Space to take photo | R to record | F for fullscreen | + - to adjust intensity
        </div>
    </div>
</div>

<div id="settingsPanel" class="fixed inset-0 bg-black bg-opacity-90 z-50 hidden flex-col items-center justify-center">
    <div class="bg-gray-800 p-6 rounded-lg max-w-md w-full mx-4">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-white text-xl font-bold">Settings</h2>
            <button id="closeSettingsBtn" class="text-white hover:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="space-y-4">
            <div>
                <label class="block text-white mb-2">Resolution</label>
                <select id="resolutionSelect" class="bg-gray-700 text-white rounded px-3 py-2 w-full">
                    <option value="auto">Auto (Default)</option>
                    <option value="hd">HD (1280x720)</option>
                    <option value="fullhd">Full HD (1920x1080)</option>
                    <option value="4k">4K (3840x2160)</option>
                </select>
            </div>
            <div>
                <label class="block text-white mb-2">Video Quality (Recording)</label>
                <select id="videoQualitySelect" class="bg-gray-700 text-white rounded px-3 py-2 w-full">
                    <option value="high">High (3 Mbps)</option>
                    <option value="medium" selected>Medium (1.5 Mbps)</option>
                    <option value="low">Low (800 Kbps)</option>
                </select>
            </div>
            <div>
                <label class="block text-white mb-2">Theme</label>
                <select id="themeSelect" class="bg-gray-700 text-white rounded px-3 py-2 w-full">
                    <option value="dark" selected>Dark</option>
                    <option value="light">Light</option>
                </select>
            </div>
            <div class="mt-6 text-center">
                <button id="saveSettingsBtn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded hover:bg-blue-700">
                    Save Settings
                </button>
            </div>
        </div>
    </div>
</div>

<div id="tooltipContainer" class="fixed pointer-events-none z-50 bg-black bg-opacity-80 text-white text-sm p-2 rounded hidden"></div>

<style>
    .hide-scrollbar::-webkit-scrollbar {display: none;}
    .hide-scrollbar {-ms-overflow-style: none; scrollbar-width: none;}
    .filter-button.active {border: 2px solid #3b82f6; box-shadow: 0 0 8px #3b82f6;}
    .filter-preview {position: relative; width: 80px; height: 60px; overflow: hidden; border-radius: 4px; background-color: #1f2937;}
    .filter-preview img {width: 100%; height: 100%; object-fit: cover;}
    .filter-preview .filter-name {position: absolute; bottom: 0; left: 0; right: 0; background-color: rgba(0,0,0,0.7); color: white; font-size: 10px; text-align: center; padding: 2px;}
    .filter-button {display: flex; flex-direction: column; align-items: center; background: transparent; border: 2px solid transparent; transition: all 0.2s;}
    body.light-theme {background-color: #f3f4f6;}
    body.light-theme #controlPanel {background-color: rgba(243, 244, 246, 0.9);}
    body.light-theme #currentFilterName, body.light-theme #intensityValue, body.light-theme #keyboardShortcuts {color: #1f2937;}
    @media (max-width: 640px) {
        #controlPanel {padding: 2px;}
        .carousel-container {margin-bottom: 0;}
        #keyboardShortcuts {display: none;}
        .filter-preview {width: 60px; height: 45px;}
    }
    @media (display-mode: standalone) {
        .app-installed {display: none;}
    }
</style>

<script>
    let video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.style.display = 'none';
    document.body.appendChild(video);

    let glfxCanvas = fx.canvas();
    document.getElementById('canvas').replaceWith(glfxCanvas);
    let currentFilter = 'none';
    let intensity = 0.5;
    let cameraReady = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingStartTime = 0;
    let recordingInterval = null;
    let currentStream = null;
    let currentCameraId = null;
    let filterPreviews = {};
    let isFullscreen = false;
    let settings = {
        resolution: 'auto',
        videoQuality: 'medium',
        theme: 'dark'
    };

    const presets = {
        none: { filter: 'none', intensity: 0.5 },
        vintage: { filter: 'vintageFilm', intensity: 0.8 },
        vaporwave: { filter: 'retroWave', intensity: 0.85 },
        noir: { filter: 'sepia', intensity: 0.9 },
        dreamy: { filter: 'dreamy', intensity: 0.7 },
        comic: { filter: 'comicBook', intensity: 0.65 }
    };

    const filters = [
        'none', 'mirror', 'hue', 'sharpen', 'emboss', 'sepia', 'blur', 'brightnessContrast',
        'hueSaturation', 'vibrance', 'vignette', 'denoise', 'unsharpMask', 'noise',
        'lensBlur', 'zoomBlur', 'colorHalftone', 'dotScreen', 'edgeWork', 'hexagonalPixelate',
        'ink', 'bulgePinch', 'swirl', 'retroWave', 'dreamy', 'vintageFilm', 'cyberpunk',
        'comicBook', 'watercolor', 'miniatureWorld', 'psychedelicSwirl', 'fisheyeLens',
        'whirlpool', 'mirroredBubble', 'tornado', 'dreamyPortal'
    ];

    const filterDescriptions = {
        none: 'No effect applied',
        mirror: 'Horizontal mirror effect',
        hue: 'Adjust color hue',
        sharpen: 'Increase image sharpness',
        emboss: 'Create embossed texture effect',
        sepia: 'Classic vintage brownish tint',
        blur: 'Soften the image',
        brightnessContrast: 'Adjust light and dark levels',
        hueSaturation: 'Adjust colors and intensity',
        vibrance: 'Enhance color vibrance',
        vignette: 'Darken the edges',
        denoise: 'Reduce image noise',
        unsharpMask: 'Enhance edge details',
        noise: 'Add grain texture',
        lensBlur: 'Simulate camera lens blur',
        zoomBlur: 'Radial motion blur',
        colorHalftone: 'Comic-style color dots',
        dotScreen: 'Newspaper print effect',
        edgeWork: 'Edge detection',
        hexagonalPixelate: 'Hex-shaped pixels',
        ink: 'Ink drawing effect',
        bulgePinch: 'Distort image like a lens',
        swirl: 'Twist the image in a spiral',
        retroWave: 'Vibrant 80s aesthetic',
        dreamy: 'Soft focus dreamy effect',
        vintageFilm: 'Classic film look',
        cyberpunk: 'Futuristic neon style',
        comicBook: 'Comic book art style',
        watercolor: 'Painting-like effect',
        miniatureWorld: 'Tilt-shift miniature look',
        psychedelicSwirl: 'Trippy color swirls',
        fisheyeLens: 'Wide angle fisheye distortion',
        whirlpool: 'Spinning whirlpool effect',
        mirroredBubble: 'Mirror inside a bubble',
        tornado: 'Spinning tornado distortion',
        dreamyPortal: 'Magical portal effect'
    };

    function loadSavedSettings() {
        try {
            const savedSettings = localStorage.getItem('webcamFilterSettings');
            if (savedSettings) {
                settings = {...settings, ...JSON.parse(savedSettings)};
            }
            applySettings();
        } catch (e) {
            console.error("Error loading settings:", e);
        }
    }

    function saveSettings() {
        try {
            settings.resolution = document.getElementById('resolutionSelect').value;
            settings.videoQuality = document.getElementById('videoQualitySelect').value;
            settings.theme = document.getElementById('themeSelect').value;
            localStorage.setItem('webcamFilterSettings', JSON.stringify(settings));
            applySettings();
            document.getElementById('settingsPanel').style.display = 'none';
            restartCamera();
        } catch (e) {
            console.error("Error saving settings:", e);
        }
    }

    function applySettings() {
        document.getElementById('resolutionSelect').value = settings.resolution;
        document.getElementById('videoQualitySelect').value = settings.videoQuality;
        document.getElementById('themeSelect').value = settings.theme;

        if (settings.theme === 'light') {
            document.body.classList.add('light-theme');
        } else {
            document.body.classList.remove('light-theme');
        }
    }

    async function getConnectedCameras() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            const cameraSelect = document.getElementById('cameraSelect');
            cameraSelect.innerHTML = '';

            if (videoDevices.length === 0) {
                const option = document.createElement('option');
                option.text = 'No cameras found';
                option.disabled = true;
                cameraSelect.add(option);
            } else {
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${index + 1}`;
                    cameraSelect.add(option);
                });

                cameraSelect.addEventListener('change', () => {
                    currentCameraId = cameraSelect.value;
                    restartCamera();
                });

                if (!currentCameraId && videoDevices.length > 0) {
                    currentCameraId = videoDevices[0].deviceId;
                    cameraSelect.value = currentCameraId;
                }
            }
        } catch (error) {
            console.error("Error enumerating devices:", error);
            showError("Could not detect cameras. Please check your permissions.");
        }
    }

    async function setupCamera() {
        try {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: { facingMode: "user" },
                audio: false
            };

            if (currentCameraId) {
                constraints.video = { deviceId: { exact: currentCameraId } };
            }

            if (settings.resolution !== 'auto') {
                switch (settings.resolution) {
                    case 'hd':
                        constraints.video.width = { ideal: 1280 };
                        constraints.video.height = { ideal: 720 };
                        break;
                    case 'fullhd':
                        constraints.video.width = { ideal: 1920 };
                        constraints.video.height = { ideal: 1080 };
                        break;
                    case '4k':
                        constraints.video.width = { ideal: 3840 };
                        constraints.video.height = { ideal: 2160 };
                        break;
                }
            }

            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = currentStream;

            video.onloadedmetadata = () => {
                cameraReady = true;
                document.getElementById('loadingIndicator').style.display = 'none';
                window.addEventListener('resize', onResize);
                onResize();

                requestAnimationFrame(update);
            };

            await getConnectedCameras();
        } catch (error) {
            console.error("Camera error:", error);
            showError("Camera access denied or not available. Please check your camera permissions.");
        }
    }

    function showError(message) {
        const errorMessage = document.getElementById('errorMessage');
        document.getElementById('errorText').textContent = message;
        errorMessage.classList.remove('hidden');
        errorMessage.classList.add('flex');
        document.getElementById('loadingIndicator').style.display = 'none';
    }

    function update() {
        if (cameraReady) {
            try {
                let texture = glfxCanvas.texture(video);
                applyFilter(texture);
                texture.destroy();
            } catch (e) {
                console.error("Rendering error:", e);
            }
        }
        requestAnimationFrame(update);
    }

    function applyFilter(texture) {
        const i = intensity;

        switch (currentFilter) {
            case 'mirror':
                glfxCanvas.draw(texture).matrixWarp([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], false, true).update();
                break;
            case 'hue':
                glfxCanvas.draw(texture).hueSaturation(i * 1.0, i * -1.0).update();
                break;
            case 'sharpen':
                glfxCanvas.draw(texture).unsharpMask(20 * i, 2 * i).update();
                break;
            case 'emboss':
                glfxCanvas.draw(texture).edgeWork(4 * i).update();
                break;
            case 'sepia':
                glfxCanvas.draw(texture).sepia(i * 2).update();
                break;
            case 'blur':
                glfxCanvas.draw(texture).triangleBlur(40 * i).update();
                break;
            case 'brightnessContrast':
                glfxCanvas.draw(texture).brightnessContrast(i * 0.2, i * 0.2).update();
                break;
            case 'hueSaturation':
                glfxCanvas.draw(texture).hueSaturation(-i, i).update();
                break;
            case 'vibrance':
                glfxCanvas.draw(texture).vibrance(i).update();
                break;
            case 'vignette':
                glfxCanvas.draw(texture).vignette(i, i).update();
                break;
            case 'denoise':
                glfxCanvas.draw(texture).denoise(40 * i).update();
                break;
            case 'unsharpMask':
                glfxCanvas.draw(texture).unsharpMask(40 * i, 4 * i).update();
                break;
            case 'noise':
                glfxCanvas.draw(texture).noise(i).update();
                break;
            case 'lensBlur':
                glfxCanvas.draw(texture).lensBlur(30 * i, 1.5 * i, 0).update();
                break;
            case 'zoomBlur':
                glfxCanvas.draw(texture).zoomBlur(glfxCanvas.width / 2, glfxCanvas.height / 2, i).update();
                break;
            case 'colorHalftone':
                glfxCanvas.draw(texture).colorHalftone(glfxCanvas.width / 2, glfxCanvas.height / 2, 0, 20 * i).update();
                break;
            case 'dotScreen':
                glfxCanvas.draw(texture).dotScreen(glfxCanvas.width / 2, glfxCanvas.height / 2, 0, 20 * i).update();
                break;
            case 'edgeWork':
                glfxCanvas.draw(texture).edgeWork(20 * i).update();
                break;
            case 'hexagonalPixelate':
                glfxCanvas.draw(texture).hexagonalPixelate(glfxCanvas.width / 2, glfxCanvas.height / 2, 40 * i).update();
                break;
            case 'ink':
                glfxCanvas.draw(texture).ink(i * 0.5).update();
                break;
            case 'bulgePinch':
                glfxCanvas.draw(texture).bulgePinch(glfxCanvas.width / 2, glfxCanvas.height / 2, 200 * i, i).update();
                break;
            case 'swirl':
                glfxCanvas.draw(texture).swirl(glfxCanvas.width / 2, glfxCanvas.height / 2, 400 * i, 6 * i).update();
                break;
            case 'retroWave':
                glfxCanvas.draw(texture).hueSaturation(0.2 * i, i).vibrance(i).noise(0.4 * i).update();
                break;
            case 'dreamy':
                glfxCanvas.draw(texture).triangleBlur(30 * i).vignette(0.4 * i, i).update();
                break;
            case 'vintageFilm':
                glfxCanvas.draw(texture).sepia(1.6 * i).noise(0.8 * i).vignette(0.3 * i, i).update();
                break;
            case 'cyberpunk':
                glfxCanvas.draw(texture).hueSaturation(i, 2 * i).lensBlur(10 * i, -i, 0).colorHalftone(glfxCanvas.width / 2, glfxCanvas.height / 2, 0, 20 * i).update();
                break;
            case 'comicBook':
                glfxCanvas.draw(texture).dotScreen(glfxCanvas.width / 2, glfxCanvas.height / 2, 0, 20 * i).edgeWork(10 * i).update();
                break;
            case 'watercolor':
                glfxCanvas.draw(texture).triangleBlur(50 * i).vibrance(0.6 * i).update();
                break;
            case 'miniatureWorld':
                glfxCanvas.draw(texture).bulgePinch(glfxCanvas.width / 2, glfxCanvas.height / 2, Math.min(glfxCanvas.width, glfxCanvas.height) / 2, 2 * i).vibrance(1.2 * i).update();
                break;
            case 'psychedelicSwirl':
                glfxCanvas.draw(texture).swirl(glfxCanvas.width / 2, glfxCanvas.height / 2, 400 * i, Math.PI * 2 * i).hueSaturation(i, 0).update();
                break;
            case 'fisheyeLens':
                glfxCanvas.draw(texture).bulgePinch(glfxCanvas.width / 2, glfxCanvas.height / 2, Math.min(glfxCanvas.width, glfxCanvas.height) / 2, 2 * i).unsharpMask(40 * i, 4 * i).update();
                break;
            case 'whirlpool':
                glfxCanvas.draw(texture).swirl(glfxCanvas.width / 2, glfxCanvas.height / 2, Math.min(glfxCanvas.width, glfxCanvas.height) / 2, 8 * i).triangleBlur(20 * i).update();
                break;
            case 'mirroredBubble':
                glfxCanvas.draw(texture).bulgePinch(glfxCanvas.width / 4, glfxCanvas.height / 2, glfxCanvas.width / 4, i).matrixWarp([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], false, true).update();
                break;
            case 'tornado':
                glfxCanvas.draw(texture).swirl(glfxCanvas.width / 2, glfxCanvas.height / 2, Math.min(glfxCanvas.width, glfxCanvas.height) / 3, 12 * i).noise(0.4 * i).update();
                break;
            case 'dreamyPortal':
                glfxCanvas.draw(texture).bulgePinch(glfxCanvas.width / 2, glfxCanvas.height / 2, glfxCanvas.width / 3, 2 * i).hueSaturation(0.4 * i, 1.6 * i).triangleBlur(10 * i).update();
                break;
            case 'none':
            default:
                glfxCanvas.draw(texture).update();
                break;
        }
    }

    // Extract filter application to a reusable function for snapshot use
    function applyFilterToTexture(canvas, texture, filter, i) {
        switch (filter) {
            case 'mirror':
                return canvas.draw(texture).matrixWarp([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], false, true);
            case 'hue':
                return canvas.draw(texture).hueSaturation(i * 1.0, i * -1.0);
            case 'sharpen':
                return canvas.draw(texture).unsharpMask(20 * i, 2 * i);
            case 'emboss':
                return canvas.draw(texture).edgeWork(4 * i);
            case 'sepia':
                return canvas.draw(texture).sepia(i * 2);
            case 'blur':
                return canvas.draw(texture).triangleBlur(40 * i);
            case 'brightnessContrast':
                return canvas.draw(texture).brightnessContrast(i * 0.2, i * 0.2);
            case 'hueSaturation':
                return canvas.draw(texture).hueSaturation(-i, i);
            case 'vibrance':
                return canvas.draw(texture).vibrance(i);
            case 'vignette':
                return canvas.draw(texture).vignette(i, i);
            case 'denoise':
                return canvas.draw(texture).denoise(40 * i);
            case 'unsharpMask':
                return canvas.draw(texture).unsharpMask(40 * i, 4 * i);
            case 'noise':
                return canvas.draw(texture).noise(i);
            case 'lensBlur':
                return canvas.draw(texture).lensBlur(30 * i, 1.5 * i, 0);
            case 'zoomBlur':
                return canvas.draw(texture).zoomBlur(canvas.width / 2, canvas.height / 2, i);
            case 'colorHalftone':
                return canvas.draw(texture).colorHalftone(canvas.width / 2, canvas.height / 2, 0, 20 * i);
            case 'dotScreen':
                return canvas.draw(texture).dotScreen(canvas.width / 2, canvas.height / 2, 0, 20 * i);
            case 'edgeWork':
                return canvas.draw(texture).edgeWork(20 * i);
            case 'hexagonalPixelate':
                return canvas.draw(texture).hexagonalPixelate(canvas.width / 2, canvas.height / 2, 40 * i);
            case 'ink':
                return canvas.draw(texture).ink(i * 0.5);
            case 'bulgePinch':
                return canvas.draw(texture).bulgePinch(canvas.width / 2, canvas.height / 2, 200 * i, i);
            case 'swirl':
                return canvas.draw(texture).swirl(canvas.width / 2, canvas.height / 2, 400 * i, 6 * i);
            case 'retroWave':
                return canvas.draw(texture).hueSaturation(0.2 * i, i).vibrance(i).noise(0.4 * i);
            case 'dreamy':
                return canvas.draw(texture).triangleBlur(30 * i).vignette(0.4 * i, i);
            case 'vintageFilm':
                return canvas.draw(texture).sepia(1.6 * i).noise(0.8 * i).vignette(0.3 * i, i);
            case 'cyberpunk':
                return canvas.draw(texture).hueSaturation(i, 2 * i).lensBlur(10 * i, -i, 0).colorHalftone(canvas.width / 2, canvas.height / 2, 0, 20 * i);
            case 'comicBook':
                return canvas.draw(texture).dotScreen(canvas.width / 2, canvas.height / 2, 0, 20 * i).edgeWork(10 * i);
            case 'watercolor':
                return canvas.draw(texture).triangleBlur(50 * i).vibrance(0.6 * i);
            case 'miniatureWorld':
                return canvas.draw(texture).bulgePinch(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) / 2, 2 * i).vibrance(1.2 * i);
            case 'psychedelicSwirl':
                return canvas.draw(texture).swirl(canvas.width / 2, canvas.height / 2, 400 * i, Math.PI * 2 * i).hueSaturation(i, 0);
            case 'fisheyeLens':
                return canvas.draw(texture).bulgePinch(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) / 2, 2 * i).unsharpMask(40 * i, 4 * i);
            case 'whirlpool':
                return canvas.draw(texture).swirl(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) / 2, 8 * i).triangleBlur(20 * i);
            case 'mirroredBubble':
                return canvas.draw(texture).bulgePinch(canvas.width / 4, canvas.height / 2, canvas.width / 4, i).matrixWarp([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], false, true);
            case 'tornado':
                return canvas.draw(texture).swirl(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) / 3, 12 * i).noise(0.4 * i);
            case 'dreamyPortal':
                return canvas.draw(texture).bulgePinch(canvas.width / 2, canvas.height / 2, canvas.width / 3, 2 * i).hueSaturation(0.4 * i, 1.6 * i).triangleBlur(10 * i);
            case 'none':
            default:
                return canvas.draw(texture);
        }
    }

    function onResize() {
        if (!cameraReady) return;

        const container = document.getElementById('canvasContainer');
        const controlPanel = document.getElementById('controlPanel');
        const maxHeight = window.innerHeight - controlPanel.offsetHeight;

        const aspectRatio = video.videoWidth / video.videoHeight;
        let newWidth = container.offsetWidth;
        let newHeight = newWidth / aspectRatio;

        if (newHeight > maxHeight) {
            newHeight = maxHeight;
            newWidth = newHeight * aspectRatio;
        }

        glfxCanvas.width = newWidth;
        glfxCanvas.height = newHeight;
        glfxCanvas.style.width = `${newWidth}px`;
        glfxCanvas.style.height = `${newHeight}px`;
    }

    function setFilter(filter) {
        currentFilter = filter;
        document.getElementById('currentFilterName').textContent = filter.charAt(0).toUpperCase() + filter.slice(1);
        document.getElementById('presetSelect').value = 'none';

        document.querySelectorAll('.filter-button').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeButton = document.querySelector(`.filter-button[data-filter="${filter}"]`);
        if (activeButton) {
            activeButton.classList.add('active');

            const carousel = document.getElementById('carousel');
            activeButton.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    }

    function createFilterButtons() {
        const carousel = document.getElementById('carousel');

        filters.forEach(filter => {
            let button = document.createElement('div');
            button.className = 'filter-button m-1 transition-all duration-200';
            button.dataset.filter = filter;

            let preview = document.createElement('div');
            preview.className = 'filter-preview';

            let img = document.createElement('img');
            img.src = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'80\' height=\'60\' viewBox=\'0 0 80 60\'%3E%3Crect width=\'80\' height=\'60\' fill=\'%232d3748\'/%3E%3Ccircle cx=\'40\' cy=\'30\' r=\'15\' fill=\'%234a5568\'/%3E%3C/svg%3E';
            img.alt = filter;
            preview.appendChild(img);

            let name = document.createElement('div');
            name.className = 'filter-name';
            name.textContent = filter.charAt(0).toUpperCase() + filter.slice(1);
            preview.appendChild(name);

            button.appendChild(preview);
            button.dataset.tooltip = filterDescriptions[filter] || filter;

            button.addEventListener('mouseenter', (e) => {
                showTooltip(e, filterDescriptions[filter] || filter);
            });

            button.addEventListener('mouseleave', () => {
                hideTooltip();
            });

            button.onclick = () => { setFilter(filter); };
            carousel.appendChild(button);

            filterPreviews[filter] = button;
        });

        document.getElementById('prevButton').addEventListener('click', () => {
            carousel.scrollBy({ left: -200, behavior: 'smooth' });
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            carousel.scrollBy({ left: 200, behavior: 'smooth' });
        });

        setFilter('none');
    }

    function showTooltip(event, text) {
        const tooltip = document.getElementById('tooltipContainer');
        tooltip.textContent = text;
        tooltip.style.display = 'block';

        const x = event.clientX;
        const y = event.clientY - 30;

        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
    }

    function hideTooltip() {
        document.getElementById('tooltipContainer').style.display = 'none';
    }

    // Completely rewritten snapshot function using WebGL correctly
    function takeSnapshot() {
        try {
            // Create a temporary fx canvas for the snapshot
            const tempFxCanvas = fx.canvas();
            tempFxCanvas.width = glfxCanvas.width;
            tempFxCanvas.height = glfxCanvas.height;

            // Apply the current filter to a fresh frame
            let tempTexture = tempFxCanvas.texture(video);
            let result = applyFilterToTexture(tempFxCanvas, tempTexture, currentFilter, intensity);
            result.update();

            // Create a regular 2D canvas
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = tempFxCanvas.width;
            outputCanvas.height = tempFxCanvas.height;
            const ctx = outputCanvas.getContext('2d', { alpha: false });

            // Draw the WebGL canvas to the 2D canvas
            ctx.drawImage(tempFxCanvas, 0, 0);

            // Create the download link using the 2D canvas
            const dataUrl = outputCanvas.toDataURL('image/png');

            // Create and trigger download link
            const link = document.createElement('a');
            link.download = `webcam-filter-${currentFilter}-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`;
            link.href = dataUrl;

            // Add temporary to DOM to ensure Firefox compatibility
            document.body.appendChild(link);
            link.click();

            // Clean up resources
            setTimeout(() => {
                document.body.removeChild(link);
                tempTexture.destroy();
                tempFxCanvas.destroy();
            }, 100);
        } catch (error) {
            console.error("Error taking snapshot:", error);
            showError("Failed to take snapshot. Details: " + error.message);
        }
    }

    function setupIntensitySlider() {
        const slider = document.getElementById('intensitySlider');
        const value = document.getElementById('intensityValue');

        slider.addEventListener('input', () => {
            intensity = slider.value / 100;
            value.textContent = `${slider.value}%`;
        });
    }

    function toggleRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
            startRecording();
        } else {
            stopRecording();
        }
    }

    function startRecording() {
        if (!cameraReady) return;

        try {
            // Try different methods to get a stream
            let outputStream;

            // Method 1: Try to capture GL canvas (works in Chrome)
            try {
                if (glfxCanvas.captureStream) {
                    outputStream = glfxCanvas.captureStream(30);
                }
            } catch (e) {
                console.warn("Canvas capture failed:", e);
            }

            // Method 2: If canvas capture failed, try video capture with drawable canvas
            if (!outputStream) {
                try {
                    // Create a drawable canvas for recording
                    const drawableCanvas = document.createElement('canvas');
                    drawableCanvas.width = video.videoWidth;
                    drawableCanvas.height = video.videoHeight;
                    document.body.appendChild(drawableCanvas);
                    drawableCanvas.style.display = 'none';

                    // Set up canvas context for drawing
                    const ctx = drawableCanvas.getContext('2d');

                    // Create a stream from the drawable canvas
                    if (drawableCanvas.captureStream) {
                        outputStream = drawableCanvas.captureStream(30);
                    } else if (drawableCanvas.mozCaptureStream) {
                        outputStream = drawableCanvas.mozCaptureStream();
                    }

                    // Set up an interval to draw the glfxCanvas to the drawable canvas
                    const drawInterval = setInterval(() => {
                        ctx.drawImage(glfxCanvas, 0, 0, drawableCanvas.width, drawableCanvas.height);
                    }, 16); // ~60fps

                    // Store reference to clean up later
                    window.drawableCanvas = drawableCanvas;
                    window.drawInterval = drawInterval;
                } catch (e) {
                    console.warn("Drawable canvas method failed:", e);
                }
            }

            // Method 3: Last resort - use original video stream (no filters)
            if (!outputStream && video.srcObject) {
                try {
                    if (video.captureStream) {
                        outputStream = video.captureStream();
                    } else if (video.mozCaptureStream) {
                        outputStream = video.mozCaptureStream();
                    }
                } catch (e) {
                    console.warn("Video capture failed:", e);
                }
            }

            if (!outputStream) {
                throw new Error("Could not create media stream for recording");
            }

            recordedChunks = [];

            // Try different codec options for better browser compatibility
            let videoOptions;
            try {
                // Check what codecs are supported
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    videoOptions = {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: getBitrate(settings.videoQuality)
                    };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    videoOptions = {
                        mimeType: 'video/webm;codecs=vp8',
                        videoBitsPerSecond: getBitrate(settings.videoQuality)
                    };
                } else if (MediaRecorder.isTypeSupported('video/webm')) {
                    videoOptions = {
                        mimeType: 'video/webm',
                        videoBitsPerSecond: getBitrate(settings.videoQuality)
                    };
                } else {
                    // Use default options if none of the above are supported
                    videoOptions = { videoBitsPerSecond: getBitrate(settings.videoQuality) };
                }
            } catch (e) {
                // Fallback to basic options
                videoOptions = {};
            }

            mediaRecorder = new MediaRecorder(outputStream, videoOptions);

            mediaRecorder.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = saveRecording;

            mediaRecorder.start(1000);
            recordingStartTime = Date.now();

            recordingInterval = setInterval(updateRecordingTime, 1000);

            document.getElementById('recordBtn').classList.add('animate-pulse');
            document.getElementById('recordingIndicator').classList.remove('hidden');
            document.getElementById('recordingIndicator').classList.add('flex');
        } catch (error) {
            console.error("Recording error:", error);
            showError("Could not start recording. Your browser may not support this feature.");
        }
    }

    function getBitrate(quality) {
        switch (quality) {
            case 'high': return 3 * 1000 * 1000;
            case 'medium': return 1.5 * 1000 * 1000;
            case 'low': return 800 * 1000;
            default: return 1.5 * 1000 * 1000;
        }
    }

    function updateRecordingTime() {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('recordingTime').textContent = `${minutes}:${seconds}`;
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            clearInterval(recordingInterval);
            document.getElementById('recordBtn').classList.remove('animate-pulse');
            document.getElementById('recordingIndicator').classList.add('hidden');
            document.getElementById('recordingIndicator').classList.remove('flex');

            // Clean up drawable canvas if it was created
            if (window.drawInterval) {
                clearInterval(window.drawInterval);
                delete window.drawInterval;
            }
            if (window.drawableCanvas) {
                document.body.removeChild(window.drawableCanvas);
                delete window.drawableCanvas;
            }
        }
    }

    function saveRecording() {
        try {
            if (recordedChunks.length === 0) {
                showError("No video data was recorded");
                return;
            }

            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            a.href = url;
            a.download = `webcam-recording-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
            a.click();

            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        } catch (error) {
            console.error("Error saving recording:", error);
            showError("Failed to save recording");
        }
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            const container = document.getElementById('canvasContainer');
            if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            }
            isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            isFullscreen = false;
        }
    }

    function setupPresets() {
        const presetSelect = document.getElementById('presetSelect');

        presetSelect.addEventListener('change', () => {
            const preset = presetSelect.value;
            if (preset !== 'none' && presets[preset]) {
                currentFilter = presets[preset].filter;
                intensity = presets[preset].intensity;

                document.getElementById('intensitySlider').value = intensity * 100;
                document.getElementById('intensityValue').textContent = `${Math.round(intensity * 100)}%`;

                document.querySelectorAll('.filter-button').forEach(btn => {
                    btn.classList.remove('active');
                });

                const activeButton = document.querySelector(`.filter-button[data-filter="${currentFilter}"]`);
                if (activeButton) {
                    activeButton.classList.add('active');

                    const carousel = document.getElementById('carousel');
                    activeButton.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }

                document.getElementById('currentFilterName').textContent = currentFilter.charAt(0).toUpperCase() + currentFilter.slice(1);
            }
        });
    }

    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            const index = filters.indexOf(currentFilter);

            if (e.code === 'ArrowLeft') {
                const newIndex = (index - 1 + filters.length) % filters.length;
                setFilter(filters[newIndex]);
            } else if (e.code === 'ArrowRight') {
                const newIndex = (index + 1) % filters.length;
                setFilter(filters[newIndex]);
            } else if (e.code === 'Space') {
                e.preventDefault();
                takeSnapshot();
            } else if (e.code === 'KeyR') {
                toggleRecording();
            } else if (e.code === 'KeyF') {
                toggleFullscreen();
            } else if (e.key === '+' || e.key === '=') {
                const slider = document.getElementById('intensitySlider');
                slider.value = Math.min(100, parseInt(slider.value) + 10);
                slider.dispatchEvent(new Event('input'));
            } else if (e.key === '-' || e.key === '_') {
                const slider = document.getElementById('intensitySlider');
                slider.value = Math.max(0, parseInt(slider.value) - 10);
                slider.dispatchEvent(new Event('input'));
            }
        });
    }

    function setupSettingsPanel() {
        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsPanel').style.display = 'flex';
        });

        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            document.getElementById('settingsPanel').style.display = 'none';
        });

        document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
    }

    function setupSwipeControls() {
        let startX, startY;
        const carousel = document.getElementById('carousel');

        carousel.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }, false);

        carousel.addEventListener('touchmove', (e) => {
            if (!startX || !startY) return;

            const diffX = startX - e.touches[0].clientX;
            const diffY = startY - e.touches[0].clientY;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                e.preventDefault();
            }
        }, { passive: false });

        glfxCanvas.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }, false);

        glfxCanvas.addEventListener('touchend', (e) => {
            if (!startX || !startY) return;

            const diffX = startX - e.changedTouches[0].clientX;
            const diffY = startY - e.changedTouches[0].clientY;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (Math.abs(diffX) > 50) {
                    const index = filters.indexOf(currentFilter);
                    if (diffX > 0) {
                        setFilter(filters[(index + 1) % filters.length]);
                    } else {
                        setFilter(filters[(index - 1 + filters.length) % filters.length]);
                    }
                }
            }

            startX = null;
            startY = null;
        }, false);
    }

    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(
                URL.createObjectURL(
                    new Blob([
                        `self.addEventListener('install', e => { e.waitUntil(self.skipWaiting()); });
           self.addEventListener('activate', e => { e.waitUntil(self.clients.claim()); });
           self.addEventListener('fetch', e => { e.respondWith(fetch(e.request)); });`
                    ], { type: 'application/javascript' })
                )
            ).catch(e => console.error('SW registration failed:', e));
        }
    }

    function restartCamera() {
        cameraReady = false;
        document.getElementById('loadingIndicator').style.display = 'flex';
        setupCamera();
    }

    // Handle window resize for better layout
    window.addEventListener('resize', () => {
        if (cameraReady) {
            onResize();
        }
    });

    document.getElementById('retryButton').addEventListener('click', () => {
        document.getElementById('errorMessage').classList.remove('flex');
        document.getElementById('errorMessage').classList.add('hidden');
        document.getElementById('loadingIndicator').style.display = 'flex';
        setupCamera();
    });

    document.getElementById('snapshotBtn').addEventListener('click', takeSnapshot);
    document.getElementById('recordBtn').addEventListener('click', toggleRecording);
    document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

    createFilterButtons();
    setupIntensitySlider();
    setupKeyboardShortcuts();
    setupPresets();
    setupSettingsPanel();
    setupSwipeControls();
    loadSavedSettings();
    registerServiceWorker();
    setupCamera();
</script>
</body>
</html>