<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Art Animator - Create Frame-by-Frame Animations Online | Free Tool</title>
    <meta name="description"
          content="Create stunning pixel art animations with our free online tool. Draw frame-by-frame animations, export as GIF, and bring your pixel art to life with professional features.">
    <meta name="keywords"
          content="pixel art animator, frame animation, gif creator, pixel art tool, online animation, sprite animation, retro animation, pixel graphics, animation maker">
    <meta name="author" content="Claude Sonnet 4 prompted by Tobias M√ºller">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href="https://www.gptgames.dev/tools/pixel_art_animator.html">
    <meta property="og:title" content="Pixel Art Animator - Create Frame-by-Frame Animations Online">
    <meta property="og:description"
          content="Create stunning pixel art animations with our free online tool. Draw frame-by-frame animations, export as GIF, and bring your pixel art to life with professional features.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_211.webp">
    <meta property="og:url" content="https://www.gptgames.dev/tools/pixel_art_animator.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="GPT Games">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Pixel Art Animator - Create Frame-by-Frame Animations Online">
    <meta name="twitter:description"
          content="Create stunning pixel art animations with our free online tool. Draw frame-by-frame animations, export as GIF, and bring your pixel art to life.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_211.webp">
    <meta name="theme-color" content="#4f46e5">
    <meta name="application-name" content="Pixel Art Animator">
    <meta name="apple-mobile-web-app-title" content="Pixel Art Animator">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow: hidden;
            user-select: none
        }

        .app {
            display: grid;
            grid-template-columns:300px 1fr;
            grid-template-rows:50px 1fr 200px;
            height: 100vh;
            background: #1a1d29
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            grid-column: 1/-1
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            margin-right: auto
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 16px;
            overflow-y: auto
        }

        .canvas-area {
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 16px;
            padding: 16px
        }

        .timeline {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 16px;
            overflow-y: auto
        }

        .section {
            margin-bottom: 24px
        }

        .section h3 {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #e0e6ed;
            text-transform: uppercase;
            letter-spacing: 0.5px
        }

        .tools {
            display: grid;
            grid-template-columns:repeat(2, 1fr);
            gap: 8px
        }

        .tool {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px
        }

        .tool:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px)
        }

        .tool.active {
            background: #4f46e5;
            border-color: #4f46e5;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3)
        }

        .colors {
            display: grid;
            grid-template-columns:repeat(6, 1fr);
            gap: 6px;
            margin-bottom: 12px
        }

        .color {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s
        }

        .color:hover {
            transform: scale(1.1)
        }

        .color.active {
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3)
        }

        .color-input {
            width: 100%;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2)
        }

        .canvas-container {
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            background: #fff;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3)
        }

        .main-canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges
        }

        .onion-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges
        }

        .selection-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 16px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap
        }

        .btn {
            background: #4f46e5;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px
        }

        .btn:hover {
            background: #4338ca;
            transform: translateY(-1px)
        }

        .btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            opacity: 0.5
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2)
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2)
        }

        .btn.danger {
            background: #ef4444
        }

        .btn.danger:hover {
            background: #dc2626
        }

        .btn.small {
            padding: 6px 10px;
            font-size: 10px
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px
        }

        .slider {
            -webkit-appearance: none;
            width: 60px;
            height: 3px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px
        }

        .timeline-title {
            font-size: 12px;
            font-weight: 600;
            color: #e0e6ed;
            text-transform: uppercase;
            letter-spacing: 0.5px
        }

        .timeline-controls {
            display: flex;
            gap: 6px
        }

        .frames-container {
            max-height: 120px;
            overflow-y: auto
        }

        .frames {
            display: grid;
            grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            padding: 4px 0
        }

        .frame {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.2s;
            position: relative;
            background: #fff
        }

        .frame:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4)
        }

        .frame.active {
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3)
        }

        .frame canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges
        }

        .frame .delete {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(255, 0, 0, 0.9);
            color: #fff;
            border: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 8px;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .frame:hover .delete {
            opacity: 1
        }

        .frame .number {
            position: absolute;
            bottom: 1px;
            left: 2px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 8px;
            padding: 1px 3px;
            border-radius: 2px;
            font-weight: 600
        }

        .add-frame {
            width: 60px;
            height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 6px;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s
        }

        .add-frame:hover {
            border-color: #4f46e5;
            color: #4f46e5;
            transform: scale(1.05)
        }

        .option {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px
        }

        .option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #4f46e5
        }

        .option label {
            font-size: 11px;
            color: #e0e6ed
        }

        .frame-actions {
            display: grid;
            grid-template-columns:1fr 1fr;
            gap: 6px;
            margin-top: 12px
        }

        .history-actions {
            display: grid;
            grid-template-columns:1fr 1fr;
            gap: 6px;
            margin-bottom: 12px
        }

        .canvas-size-select {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 11px;
            margin-bottom: 8px
        }

        .canvas-size-select option {
            background: #1a1d29;
            color: #fff
        }

        .canvas-size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px
        }

        .canvas-size-input {
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 11px;
            text-align: center
        }

        .canvas-size-input::placeholder {
            color: rgba(255, 255, 255, 0.5)
        }

        .canvas-size-apply {
            width: 100%;
            margin-bottom: 12px
        }

        .info {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 12px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 24px;
            border-radius: 8px;
            z-index: 1000;
            text-align: center
        }

        .shortcuts {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 8px
        }

        .progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px
        }

        .progress-bar {
            height: 100%;
            background: #4f46e5;
            border-radius: 2px;
            transition: width 0.3s;
            width: 0%
        }

        @media (max-width: 768px) {
            .app {
                grid-template-columns:1fr;
                grid-template-rows:50px 1fr 240px
            }

            .sidebar {
                display: none
            }

            .controls {
                flex-direction: column;
                gap: 8px
            }

            .frames {
                grid-template-columns:repeat(auto-fill, minmax(50px, 1fr))
            }

            .frame, .add-frame {
                width: 50px;
                height: 50px
            }
        }
    </style>
</head>
<body>
<div class="app">
    <div class="header">
        <h1>üé® Pixel Art Animator</h1>
        <div class="header-controls">
            <button class="btn secondary small" id="clearAllBtn">üóëÔ∏è Clear All</button>
        </div>
    </div>
    <div class="sidebar">
        <div class="section">
            <h3>üìê Canvas Size</h3>
            <select class="canvas-size-select" id="canvasSize">
                <option value="8">8√ó8 pixels</option>
                <option value="16">16√ó16 pixels</option>
                <option value="32" selected>32√ó32 pixels</option>
                <option value="64">64√ó64 pixels</option>
                <option value="128">128√ó128 pixels</option>
                <option value="custom">Custom Size</option>
            </select>
            <div class="canvas-size-inputs" id="customSizeInputs" style="display: none;">
                <input type="number" class="canvas-size-input" id="canvasWidth" placeholder="Width" min="8" max="256"
                       value="32">
                <input type="number" class="canvas-size-input" id="canvasHeight" placeholder="Height" min="8" max="256"
                       value="32">
            </div>
            <button class="btn secondary small canvas-size-apply" id="applySizeBtn" style="display: none;">Apply Size
            </button>
        </div>
        <div class="section">
            <h3>üõ†Ô∏è Tools</h3>
            <div class="tools">
                <button class="tool active" data-tool="pen">‚úèÔ∏è Pen</button>
                <button class="tool" data-tool="eraser">üßΩ Eraser</button>
                <button class="tool" data-tool="fill">ü™£ Fill</button>
                <button class="tool" data-tool="eyedropper">üéØ Pick</button>
                <button class="tool" data-tool="select">üî≤ Select</button>
                <button class="tool" data-tool="move">‚úã Move</button>
            </div>
        </div>
        <div class="section">
            <h3>üé® Colors</h3>
            <div class="colors" id="palette"></div>
            <input type="color" class="color-input" id="colorPicker" value="#000000">
        </div>
        <div class="section">
            <h3>‚öôÔ∏è Options</h3>
            <div class="history-actions">
                <button class="btn secondary small" id="undoBtn">‚Ü∂ Undo</button>
                <button class="btn secondary small" id="redoBtn">‚Ü∑ Redo</button>
            </div>
            <div class="option">
                <input type="checkbox" id="onionSkin">
                <label for="onionSkin">Onion Skin</label>
            </div>
            <div class="option">
                <input type="checkbox" id="showGrid" checked>
                <label for="showGrid">Show Grid</label>
            </div>
            <div class="frame-actions">
                <button class="btn danger small" id="clearFrameBtn">üóëÔ∏è Clear</button>
                <button class="btn secondary small" id="duplicateFrameBtn">üìã Copy</button>
            </div>
            <div class="info">
                <strong>Canvas:</strong> <span id="canvasInfo">32√ó32</span> pixels<br>
                <strong>Frames:</strong> <span id="frameCount">1</span>
                <div class="shortcuts">
                    <strong>Shortcuts:</strong><br>
                    Space: Play/Stop ‚Ä¢ C: Clear ‚Ä¢ D: Copy<br>
                    Ctrl+Z: Undo ‚Ä¢ Ctrl+Y: Redo<br>
                    ‚Üê/‚Üí: Navigate frames ‚Ä¢ S: Select ‚Ä¢ Esc: Clear selection
                </div>
            </div>
        </div>
    </div>
    <div class="canvas-area">
        <div class="controls">
            <button class="btn" id="playBtn">‚ñ∂Ô∏è Play</button>
            <button class="btn secondary" id="stopBtn">‚èπÔ∏è Stop</button>
            <div class="slider-group">
                <span>Speed:</span>
                <input type="range" class="slider" id="speedSlider" min="1" max="20" value="8">
                <span id="speedValue">8</span>
            </div>
            <div class="slider-group">
                <span>Zoom:</span>
                <button class="btn secondary small" id="zoomOut">-</button>
                <span id="zoomLevel">12x</span>
                <button class="btn secondary small" id="zoomIn">+</button>
            </div>
            <button class="btn" id="exportBtn">üì• Export GIF</button>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" class="main-canvas" width="32" height="32"></canvas>
            <canvas id="onionCanvas" class="onion-canvas" width="32" height="32"></canvas>
            <canvas id="selectionCanvas" class="selection-canvas" width="32" height="32"></canvas>
        </div>
    </div>
    <div class="timeline">
        <div class="timeline-header">
            <span class="timeline-title">üé¨ Timeline</span>
            <div class="timeline-controls">
                <button class="btn secondary small" id="exampleBtn">‚ú® Example</button>
            </div>
        </div>
        <div class="frames-container">
            <div class="frames" id="frames"></div>
        </div>
    </div>
</div>
<script>
    class PixelArtAnimator {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.onionCanvas = document.getElementById('onionCanvas');
            this.onionCtx = this.onionCanvas.getContext('2d');
            this.selectionCanvas = document.getElementById('selectionCanvas');
            this.selectionCtx = this.selectionCanvas.getContext('2d');
            this.width = 32;
            this.height = 32;
            this.zoom = 12;
            this.currentTool = 'pen';
            this.currentColor = '#000000';
            this.frames = [this.createEmptyFrame()];
            this.currentFrame = 0;
            this.isPlaying = false;
            this.playSpeed = 8;
            this.animationId = null;
            this.lastPlayTime = 0;
            this.isDrawing = false;
            this.colors = ['#000000', '#ffffff', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe', '#fd79a8', '#fdcb6e', '#e17055', '#74b9ff', '#55a3ff', '#81ecec', '#2d3436', '#636e72'];

            // History for undo/redo
            this.history = [];
            this.historyIndex = -1;
            this.maxHistorySize = 50;

            // Selection tool
            this.selection = null;
            this.selectionStart = null;
            this.isSelecting = false;
            this.isMoving = false;
            this.moveStart = null;
            this.selectionData = null;
            this.animationFrame = null;

            this.setupCanvas();
            this.setupUI();
            this.setupEvents();
            this.updateCanvas();
            this.updateTimeline();
            this.updateFrameCount();
            this.saveState();
            this.startSelectionAnimation();
        }

        createEmptyFrame() {
            return new Array(this.width * this.height).fill('rgba(0,0,0,0)');
        }

        setupCanvas() {
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.onionCanvas.width = this.width;
            this.onionCanvas.height = this.height;
            this.selectionCanvas.width = this.width;
            this.selectionCanvas.height = this.height;

            this.canvas.style.width = (this.width * this.zoom) + 'px';
            this.canvas.style.height = (this.height * this.zoom) + 'px';
            this.onionCanvas.style.width = (this.width * this.zoom) + 'px';
            this.onionCanvas.style.height = (this.height * this.zoom) + 'px';
            this.selectionCanvas.style.width = (this.width * this.zoom) + 'px';
            this.selectionCanvas.style.height = (this.height * this.zoom) + 'px';

            this.ctx.imageSmoothingEnabled = false;
            this.onionCtx.imageSmoothingEnabled = false;
            this.selectionCtx.imageSmoothingEnabled = false;
        }

        setupUI() {
            const palette = document.getElementById('palette');
            palette.innerHTML = '';
            this.colors.forEach((color, i) => {
                const div = document.createElement('div');
                div.className = 'color';
                div.style.backgroundColor = color;
                div.onclick = () => this.setColor(color);
                if (i === 0) div.classList.add('active');
                palette.appendChild(div);
            });
            this.updateZoomDisplay();
            this.updateSpeedDisplay();
            this.updateCanvasInfo();
        }

        setupEvents() {
            document.querySelectorAll('.tool').forEach(btn => {
                btn.onclick = () => this.setTool(btn.dataset.tool);
            });

            document.getElementById('canvasSize').onchange = e => {
                const value = e.target.value;
                const customInputs = document.getElementById('customSizeInputs');
                const applyBtn = document.getElementById('applySizeBtn');

                if (value === 'custom') {
                    customInputs.style.display = 'grid';
                    applyBtn.style.display = 'block';
                } else {
                    customInputs.style.display = 'none';
                    applyBtn.style.display = 'none';
                    this.changeCanvasSize(parseInt(value), parseInt(value));
                }
            };

            document.getElementById('applySizeBtn').onclick = () => {
                const width = parseInt(document.getElementById('canvasWidth').value);
                const height = parseInt(document.getElementById('canvasHeight').value);

                if (width >= 8 && width <= 256 && height >= 8 && height <= 256) {
                    this.changeCanvasSize(width, height);
                } else {
                    alert('Canvas size must be between 8 and 256 pixels');
                }
            };

            document.getElementById('colorPicker').onchange = e => this.setColor(e.target.value);
            document.getElementById('playBtn').onclick = () => this.play();
            document.getElementById('stopBtn').onclick = () => this.stop();
            document.getElementById('speedSlider').oninput = e => {
                this.playSpeed = parseInt(e.target.value);
                this.updateSpeedDisplay();
            };
            document.getElementById('zoomIn').onclick = () => this.zoom < 20 && this.setZoom(this.zoom + 2);
            document.getElementById('zoomOut').onclick = () => this.zoom > 4 && this.setZoom(this.zoom - 2);
            document.getElementById('exportBtn').onclick = () => this.exportGIF();
            document.getElementById('exampleBtn').onclick = () => this.loadExample();
            document.getElementById('clearAllBtn').onclick = () => this.clearAll();
            document.getElementById('clearFrameBtn').onclick = () => this.clearCurrentFrame();
            document.getElementById('duplicateFrameBtn').onclick = () => this.duplicateCurrentFrame();
            document.getElementById('onionSkin').onchange = () => this.updateOnionSkin();
            document.getElementById('showGrid').onchange = () => this.updateCanvas();
            document.getElementById('undoBtn').onclick = () => this.undo();
            document.getElementById('redoBtn').onclick = () => this.redo();

            document.addEventListener('keydown', e => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'z':
                        case 'Z':
                            e.preventDefault();
                            if (e.shiftKey) {
                                this.redo();
                            } else {
                                this.undo();
                            }
                            break;
                        case 'y':
                        case 'Y':
                            e.preventDefault();
                            this.redo();
                            break;
                    }
                } else {
                    switch (e.key) {
                        case ' ':
                            e.preventDefault();
                            this.isPlaying ? this.stop() : this.play();
                            break;
                        case 'c':
                        case 'C':
                            this.clearCurrentFrame();
                            break;
                        case 'd':
                        case 'D':
                            this.duplicateCurrentFrame();
                            break;
                        case 's':
                        case 'S':
                            this.setTool('select');
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.switchFrame(Math.max(0, this.currentFrame - 1));
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.switchFrame(Math.min(this.frames.length - 1, this.currentFrame + 1));
                            break;
                        case 'Escape':
                            this.clearSelection();
                            break;
                    }
                }
            });

            this.canvas.onmousedown = e => this.startDrawing(e);
            this.canvas.onmousemove = e => this.draw(e);
            this.canvas.onmouseup = () => this.stopDrawing();
            this.canvas.onmouseleave = () => this.stopDrawing();
            this.canvas.ontouchstart = e => {
                e.preventDefault();
                this.startDrawing(e.touches[0])
            };
            this.canvas.ontouchmove = e => {
                e.preventDefault();
                this.draw(e.touches[0])
            };
            this.canvas.ontouchend = e => {
                e.preventDefault();
                this.stopDrawing()
            };
        }

        changeCanvasSize(newWidth, newHeight) {
            const oldFrames = this.frames.map(frame => [...frame]);
            const oldWidth = this.width;
            const oldHeight = this.height;

            this.width = newWidth;
            this.height = newHeight;

            // Resize all frames
            this.frames = oldFrames.map(frame => {
                const newFrame = this.createEmptyFrame();
                for (let y = 0; y < Math.min(oldHeight, newHeight); y++) {
                    for (let x = 0; x < Math.min(oldWidth, newWidth); x++) {
                        newFrame[y * newWidth + x] = frame[y * oldWidth + x];
                    }
                }
                return newFrame;
            });

            this.setupCanvas();
            this.updateCanvas();
            this.updateTimeline();
            this.updateCanvasInfo();
            this.clearSelection();
            this.saveState();
        }

        updateCanvasInfo() {
            document.getElementById('canvasInfo').textContent = `${this.width}√ó${this.height}`;
        }

        saveState() {
            const state = {
                frames: this.frames.map(frame => [...frame]),
                currentFrame: this.currentFrame
            };

            // Remove future history if we're in the middle
            if (this.historyIndex < this.history.length - 1) {
                this.history = this.history.slice(0, this.historyIndex + 1);
            }

            this.history.push(state);

            // Limit history size
            if (this.history.length > this.maxHistorySize) {
                this.history.shift();
            } else {
                this.historyIndex++;
            }

            this.updateHistoryButtons();
        }

        undo() {
            if (this.historyIndex > 0) {
                this.historyIndex--;
                this.restoreState(this.history[this.historyIndex]);
            }
        }

        redo() {
            if (this.historyIndex < this.history.length - 1) {
                this.historyIndex++;
                this.restoreState(this.history[this.historyIndex]);
            }
        }

        restoreState(state) {
            this.frames = state.frames.map(frame => [...frame]);
            this.currentFrame = state.currentFrame;
            this.updateCanvas();
            this.updateTimeline();
            this.updateFrameCount();
            this.updateHistoryButtons();
            this.clearSelection();
        }

        updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
            document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
        }

        setTool(tool) {
            this.currentTool = tool;
            document.querySelectorAll('.tool').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });

            if (tool !== 'select' && tool !== 'move') {
                this.clearSelection();
            }
        }

        setColor(color) {
            this.currentColor = color;
            document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
            const colorEl = Array.from(document.querySelectorAll('.color')).find(c => c.style.backgroundColor === color || this.rgbToHex(c.style.backgroundColor) === color);
            colorEl?.classList.add('active');
            document.getElementById('colorPicker').value = color;
        }

        rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb;
            const values = rgb.match(/\d+/g);
            if (!values) return rgb;
            return '#' + values.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
        }

        setZoom(zoom) {
            this.zoom = zoom;
            this.setupCanvas();
            this.updateCanvas();
            this.updateZoomDisplay();
        }

        updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = this.zoom + 'x';
        }

        updateSpeedDisplay() {
            document.getElementById('speedValue').textContent = this.playSpeed;
        }

        updateFrameCount() {
            document.getElementById('frameCount').textContent = this.frames.length;
        }

        getPixelPos(e) {
            const rect = this.canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / this.zoom);
            const y = Math.floor((e.clientY - rect.top) / this.zoom);
            return {x, y};
        }

        startDrawing(e) {
            const {x, y} = this.getPixelPos(e);

            if (this.currentTool === 'select') {
                this.clearSelection();
                this.isSelecting = true;
                this.selectionStart = {x, y};
                return;
            }

            if (this.currentTool === 'move') {
                if (this.selection && this.isPointInSelection(x, y)) {
                    this.isMoving = true;
                    this.moveStart = {x, y};
                    this.extractSelectionData();
                    return;
                }
            }

            this.isDrawing = true;
            this.draw(e);
        }

        draw(e) {
            const {x, y} = this.getPixelPos(e);

            if (this.isSelecting) {
                this.updateSelection(x, y);
                return;
            }

            if (this.isMoving) {
                this.updateMove(x, y);
                return;
            }

            if (!this.isDrawing) return;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

            const index = y * this.width + x;

            switch (this.currentTool) {
                case 'pen':
                    this.frames[this.currentFrame][index] = this.currentColor;
                    break;
                case 'eraser':
                    this.frames[this.currentFrame][index] = 'rgba(0,0,0,0)';
                    break;
                case 'eyedropper':
                    const color = this.frames[this.currentFrame][index];
                    if (color && color !== 'rgba(0,0,0,0)') this.setColor(color);
                    break;
                case 'fill':
                    this.floodFill(x, y, this.frames[this.currentFrame][index], this.currentColor);
                    break;
            }

            this.updateCanvas();
            this.updateFrameThumb(this.currentFrame);
        }

        updateSelection(x, y) {
            if (!this.selectionStart) return;

            const startX = Math.min(this.selectionStart.x, x);
            const startY = Math.min(this.selectionStart.y, y);
            const endX = Math.max(this.selectionStart.x, x);
            const endY = Math.max(this.selectionStart.y, y);

            this.selection = {
                x: startX,
                y: startY,
                width: endX - startX + 1,
                height: endY - startY + 1
            };
        }

        updateMove(x, y) {
            if (!this.moveStart || !this.selection) return;

            const dx = x - this.moveStart.x;
            const dy = y - this.moveStart.y;

            const newX = Math.max(0, Math.min(this.width - this.selection.width, this.selection.x + dx));
            const newY = Math.max(0, Math.min(this.height - this.selection.height, this.selection.y + dy));

            this.selection.x = newX;
            this.selection.y = newY;

            // Update the canvas with the temporary move
            this.updateCanvas();
            this.drawMovingSelection();
        }

        extractSelectionData() {
            if (!this.selection) return;

            this.selectionData = [];
            const frame = this.frames[this.currentFrame];

            for (let y = 0; y < this.selection.height; y++) {
                for (let x = 0; x < this.selection.width; x++) {
                    const sourceX = this.selection.x + x;
                    const sourceY = this.selection.y + y;
                    const index = sourceY * this.width + sourceX;
                    this.selectionData.push(frame[index]);
                    frame[index] = 'rgba(0,0,0,0)';
                }
            }
        }

        drawMovingSelection() {
            if (!this.selection || !this.selectionData) return;

            for (let y = 0; y < this.selection.height; y++) {
                for (let x = 0; x < this.selection.width; x++) {
                    const targetX = this.selection.x + x;
                    const targetY = this.selection.y + y;
                    const dataIndex = y * this.selection.width + x;
                    const color = this.selectionData[dataIndex];

                    if (color && color !== 'rgba(0,0,0,0)') {
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(targetX, targetY, 1, 1);
                    }
                }
            }
        }

        pasteSelectionData() {
            if (!this.selection || !this.selectionData) return;

            const frame = this.frames[this.currentFrame];

            for (let y = 0; y < this.selection.height; y++) {
                for (let x = 0; x < this.selection.width; x++) {
                    const targetX = this.selection.x + x;
                    const targetY = this.selection.y + y;
                    const index = targetY * this.width + targetX;
                    const dataIndex = y * this.selection.width + x;
                    frame[index] = this.selectionData[dataIndex];
                }
            }

            this.updateCanvas();
            this.updateFrameThumb(this.currentFrame);
        }

        isPointInSelection(x, y) {
            if (!this.selection) return false;
            return x >= this.selection.x && x < this.selection.x + this.selection.width &&
                y >= this.selection.y && y < this.selection.y + this.selection.height;
        }

        clearSelection() {
            this.selection = null;
            this.selectionStart = null;
            this.selectionData = null;
            this.updateSelectionCanvas();
        }

        startSelectionAnimation() {
            let dashOffset = 0;

            const animate = () => {
                dashOffset = (dashOffset + 0.1) % 1;
                this.updateSelectionCanvas(dashOffset);
                this.animationFrame = requestAnimationFrame(animate);
            };

            animate();
        }

        updateSelectionCanvas(dashOffset = 0) {
            this.selectionCtx.clearRect(0, 0, this.width, this.height);

            if (this.selection) {
                this.selectionCtx.strokeStyle = '#4f46e5';
                this.selectionCtx.lineWidth = 0.15;
                this.selectionCtx.setLineDash([0.4, 0.4]);
                this.selectionCtx.lineDashOffset = dashOffset;
                this.selectionCtx.strokeRect(
                    this.selection.x + 0.075,
                    this.selection.y + 0.075,
                    this.selection.width - 0.15,
                    this.selection.height - 0.15
                );

                // Add a white shadow for better visibility
                this.selectionCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.selectionCtx.lineWidth = 0.05;
                this.selectionCtx.setLineDash([0.4, 0.4]);
                this.selectionCtx.lineDashOffset = dashOffset + 0.2;
                this.selectionCtx.strokeRect(
                    this.selection.x + 0.025,
                    this.selection.y + 0.025,
                    this.selection.width - 0.05,
                    this.selection.height - 0.05
                );
            }
        }

        stopDrawing() {
            if (this.isDrawing) {
                this.isDrawing = false;
                this.saveState();
            }

            if (this.isSelecting) {
                this.isSelecting = false;
                this.selectionStart = null;
            }

            if (this.isMoving) {
                this.isMoving = false;
                this.moveStart = null;
                this.pasteSelectionData();
                this.selectionData = null;
                this.saveState();
            }
        }

        floodFill(x, y, targetColor, newColor) {
            if (targetColor === newColor) return;
            const stack = [{x, y}];
            const frame = this.frames[this.currentFrame];
            const visited = new Set();
            while (stack.length) {
                const {x, y} = stack.pop();
                if (x < 0 || x >= this.width || y < 0 || y >= this.height) continue;
                const key = `${x},${y}`;
                if (visited.has(key)) continue;
                visited.add(key);
                const index = y * this.width + x;
                if (frame[index] !== targetColor) continue;
                frame[index] = newColor;
                stack.push({x: x + 1, y}, {x: x - 1, y}, {x, y: y + 1}, {x, y: y - 1});
            }
        }

        updateCanvas() {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.fillRect(0, 0, this.width, this.height);
            const frame = this.frames[this.currentFrame];
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    const color = frame[y * this.width + x];
                    if (color && color !== 'rgba(0,0,0,0)') {
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            if (document.getElementById('showGrid').checked) {
                this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                this.ctx.lineWidth = 0.02;
                for (let i = 0; i <= this.width; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= this.height; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.width, i);
                    this.ctx.stroke();
                }
            }
            this.updateOnionSkin();
        }

        updateOnionSkin() {
            this.onionCtx.clearRect(0, 0, this.width, this.height);
            if (!document.getElementById('onionSkin').checked || this.currentFrame === 0) return;
            const prevFrame = this.frames[this.currentFrame - 1];
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    const color = prevFrame[y * this.width + x];
                    if (color && color !== 'rgba(0,0,0,0)') {
                        this.onionCtx.fillStyle = color;
                        this.onionCtx.globalAlpha = 0.3;
                        this.onionCtx.fillRect(x, y, 1, 1);
                        this.onionCtx.globalAlpha = 1;
                    }
                }
            }
        }

        clearCurrentFrame() {
            this.frames[this.currentFrame] = this.createEmptyFrame();
            this.updateCanvas();
            this.updateFrameThumb(this.currentFrame);
            this.clearSelection();
            this.saveState();
        }

        duplicateCurrentFrame() {
            const newFrame = [...this.frames[this.currentFrame]];
            this.frames.splice(this.currentFrame + 1, 0, newFrame);
            this.currentFrame++;
            this.updateTimeline();
            this.updateCanvas();
            this.updateFrameCount();
            this.clearSelection();
            this.saveState();
        }

        addFrame() {
            this.frames.push([...this.frames[this.currentFrame]]);
            this.currentFrame = this.frames.length - 1;
            this.updateTimeline();
            this.updateCanvas();
            this.updateFrameCount();
            this.clearSelection();
            this.saveState();
        }

        deleteFrame(index) {
            if (this.frames.length <= 1) return;
            this.frames.splice(index, 1);
            if (this.currentFrame >= this.frames.length) this.currentFrame = this.frames.length - 1;
            this.updateTimeline();
            this.updateCanvas();
            this.updateFrameCount();
            this.clearSelection();
            this.saveState();
        }

        switchFrame(index) {
            if (index < 0 || index >= this.frames.length) return;
            this.currentFrame = index;
            this.updateCanvas();
            this.updateTimeline();
            this.clearSelection();
        }

        updateTimeline() {
            const container = document.getElementById('frames');
            container.innerHTML = '';
            this.frames.forEach((frame, i) => {
                const div = document.createElement('div');
                div.className = 'frame' + (i === this.currentFrame ? ' active' : '');
                div.onclick = () => this.switchFrame(i);
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete';
                deleteBtn.textContent = '√ó';
                deleteBtn.onclick = e => {
                    e.stopPropagation();
                    this.deleteFrame(i);
                };
                const numberLabel = document.createElement('div');
                numberLabel.className = 'number';
                numberLabel.textContent = i + 1;
                const canvas = document.createElement('canvas');
                canvas.width = this.width;
                canvas.height = this.height;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, this.width, this.height);
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const color = frame[y * this.width + x];
                        if (color && color !== 'rgba(0,0,0,0)') {
                            ctx.fillStyle = color;
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
                div.appendChild(canvas);
                div.appendChild(deleteBtn);
                div.appendChild(numberLabel);
                container.appendChild(div);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-frame';
            addBtn.textContent = '+';
            addBtn.onclick = () => this.addFrame();
            container.appendChild(addBtn);
        }

        updateFrameThumb(index) {
            const frameDiv = document.querySelector(`.frame:nth-child(${index + 1})`);
            if (!frameDiv) return;
            const canvas = frameDiv.querySelector('canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const frame = this.frames[index];
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, this.width, this.height);
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    const color = frame[y * this.width + x];
                    if (color && color !== 'rgba(0,0,0,0)') {
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        play() {
            if (this.isPlaying) return;
            this.isPlaying = true;
            this.lastPlayTime = Date.now();
            this.clearSelection();
            this.animate();
        }

        stop() {
            this.isPlaying = false;
            if (this.animationId) cancelAnimationFrame(this.animationId);
        }

        animate() {
            if (!this.isPlaying) return;
            const now = Date.now();
            if (now - this.lastPlayTime > 1000 / this.playSpeed) {
                this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                this.updateCanvas();
                this.updateTimeline();
                this.lastPlayTime = now;
            }
            this.animationId = requestAnimationFrame(() => this.animate());
        }

        loadExample() {
            const size = Math.min(this.width, this.height);
            const frameCount = 8;
            this.frames = [];
            for (let i = 0; i < frameCount; i++) {
                this.frames.push(this.createBouncingBall(i, size));
            }
            this.currentFrame = 0;
            this.updateCanvas();
            this.updateTimeline();
            this.updateFrameCount();
            this.clearSelection();
            this.saveState();
        }

        createBouncingBall(frame, size) {
            const data = this.createEmptyFrame();
            const centerX = Math.floor(size / 2);
            const bounceHeight = Math.floor(size / 4);
            const y = Math.round(centerX + Math.sin(frame / 8 * Math.PI * 2) * bounceHeight);
            const squash = Math.abs(Math.sin(frame / 8 * Math.PI * 2)) < 0.3 ? 0.8 : 1;
            const ballRadius = Math.floor(size / 8);

            for (let dy = -ballRadius; dy <= ballRadius; dy++) {
                for (let dx = -ballRadius; dx <= ballRadius; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy * squash);
                    if (distance <= ballRadius) {
                        const px = centerX + dx;
                        const py = y + dy;
                        if (px >= 0 && px < this.width && py >= 0 && py < this.height) {
                            data[py * this.width + px] = distance <= ballRadius * 0.5 ? '#ff6b6b' :
                                distance <= ballRadius * 0.75 ? '#ff8e8e' : '#ffaaaa';
                        }
                    }
                }
            }
            return data;
        }

        clearAll() {
            this.frames = [this.createEmptyFrame()];
            this.currentFrame = 0;
            this.updateCanvas();
            this.updateTimeline();
            this.updateFrameCount();
            this.clearSelection();
            this.history = [];
            this.historyIndex = -1;
            this.saveState();
        }

        async exportGIF() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.innerHTML = 'üé¨ Creating GIF...<br><small>Please wait a moment</small><div class="progress"><div class="progress-bar" id="progressBar"></div></div>';
            document.body.appendChild(loadingDiv);

            const progressBar = document.getElementById('progressBar');

            try {
                const {
                    GIFEncoder,
                    quantize,
                    applyPalette
                } = await import('https://unpkg.com/gifenc@1.0.3/dist/gifenc.esm.js');
                const gif = GIFEncoder();

                for (let i = 0; i < this.frames.length; i++) {
                    const frame = this.frames[i];
                    const canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, this.width, this.height);

                    for (let y = 0; y < this.height; y++) {
                        for (let x = 0; x < this.width; x++) {
                            const color = frame[y * this.width + x];
                            if (color && color !== 'rgba(0,0,0,0)') {
                                ctx.fillStyle = color;
                                ctx.fillRect(x, y, 1, 1);
                            }
                        }
                    }

                    const imageData = ctx.getImageData(0, 0, this.width, this.height);
                    const {data} = imageData;
                    const palette = quantize(data, 256);
                    const index = applyPalette(data, palette);

                    gif.writeFrame(index, this.width, this.height, {
                        palette,
                        delay: Math.round(1000 / this.playSpeed),
                        first: i === 0
                    });

                    progressBar.style.width = ((i + 1) / this.frames.length * 100) + '%';
                }

                gif.finish();
                const buffer = gif.bytes();
                const blob = new Blob([buffer], {type: 'image/gif'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pixel-animation-${this.width}x${this.height}-${Date.now()}.gif`;
                a.click();
                URL.revokeObjectURL(url);

            } catch (error) {
                console.error('GIF export failed:', error);
                alert('GIF export failed. Please try again.');
            } finally {
                document.body.removeChild(loadingDiv);
            }
        }
    }

    new PixelArtAnimator();
</script>
<script src="../logo.js"></script>
</body>
</html>