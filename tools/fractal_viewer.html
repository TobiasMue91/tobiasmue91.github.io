<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒ€</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Explore mesmerizing fractals with our interactive Fractal Viewer. Customize, zoom, and save your unique creations.">
    <title>Fractal Explorer - Interactive Mathematical Art</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = {darkMode: 'class'}</script>
    <style>
        @keyframes pulse-subtle {0% {opacity: 0.7;} 50% {opacity: 1;} 100% {opacity: 0.7;}}
        .loading {animation: pulse-subtle 1.5s infinite ease-in-out;}
        .fractal-canvas {touch-action: none;}
        .slider {-webkit-appearance: none; height: 5px; border-radius: 5px; background: #e2e8f0; outline: none;}
        .slider::-webkit-slider-thumb {-webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #6366f1; cursor: pointer;}
        .slider::-moz-range-thumb {width: 18px; height: 18px; border-radius: 50%; background: #6366f1; cursor: pointer;}
        .slider:hover::-webkit-slider-thumb {background: #4f46e5;}
        .slider:hover::-moz-range-thumb {background: #4f46e5;}
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 font-sans transition-colors duration-300">
<div class="min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-indigo-600 dark:bg-indigo-800 text-white shadow-lg">
        <div class="container mx-auto px-4 py-4 flex flex-wrap items-center justify-between">
            <div class="flex items-center">
                <span class="text-3xl mr-2">ðŸŒ€</span>
                <h1 class="text-2xl md:text-3xl font-bold">Fractal Explorer</h1>
            </div>
            <div class="flex items-center mt-2 md:mt-0">
                <button id="themeToggle" class="p-2 rounded-full hover:bg-indigo-700 transition-colors">
                    <svg id="darkIcon" class="w-6 h-6 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
                    </svg>
                    <svg id="lightIcon" class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button id="infoButton" class="ml-3 p-2 rounded-full hover:bg-indigo-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto px-4 py-6">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            <!-- Canvas Section -->
            <div class="lg:col-span-8 flex flex-col">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
                    <div class="relative">
                        <canvas id="fractalCanvas" class="w-full fractal-canvas cursor-move"></canvas>
                        <div id="interactionIndicator" class="absolute bottom-2 left-2 bg-indigo-600/90 text-white text-xs px-2 py-1 rounded-full hidden">
                            <span id="indicatorText">Interactive Mode</span>
                        </div>
                        <div id="loadingOverlay" class="absolute inset-0 bg-gray-900/70 flex items-center justify-center hidden">
                            <div class="text-white text-center">
                                <div class="loading inline-block w-10 h-10 border-4 border-white border-t-transparent rounded-full"></div>
                                <p class="mt-2 font-medium">Rendering...</p>
                            </div>
                        </div>
                        <div class="absolute bottom-2 right-2 flex gap-2">
                            <button id="fullscreenBtn" class="bg-gray-900/50 hover:bg-gray-900/70 text-white p-2 rounded-full transition-colors duration-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 01-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 011.414-1.414L15 13.586V12a1 1 0 011-1z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700">
                        <div class="flex flex-wrap gap-2 justify-center">
                            <button id="zoomIn" class="btn-primary bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                                </svg>
                                Zoom In
                            </button>
                            <button id="zoomOut" class="btn-primary bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd" />
                                </svg>
                                Zoom Out
                            </button>
                            <button id="reset" class="btn-secondary bg-amber-500 hover:bg-amber-600 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                                </svg>
                                Reset
                            </button>
                            <button id="save" class="btn-tertiary bg-emerald-600 hover:bg-emerald-700 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h5a2 2 0 012 2v7a2 2 0 01-2 2H4a2 2 0 01-2-2V8a2 2 0 012-2h5v5.586l-1.293-1.293zM9 4a1 1 0 012 0v2H9V4z" />
                                </svg>
                                Save Image
                            </button>
                            <button id="shareBtn" class="btn-tertiary bg-violet-600 hover:bg-violet-700 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" />
                                </svg>
                                Share
                            </button>
                        </div>
                        <div id="coordinates" class="text-sm text-gray-600 dark:text-gray-400 text-center mt-3"></div>
                    </div>
                </div>

                <!-- Preset Manager -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg mt-6 p-4">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-indigo-500" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" />
                        </svg>
                        Preset Manager
                    </h3>
                    <div class="flex flex-wrap gap-3">
                        <div class="flex-grow min-w-[180px]">
                            <input type="text" id="presetName" placeholder="Preset name" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        </div>
                        <button id="savePreset" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded-md transition-colors duration-200">Save Preset</button>
                        <button id="randomize" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded-md transition-colors duration-200 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                            </svg>
                            Randomize
                        </button>
                    </div>
                    <div id="presetList" class="mt-3 flex flex-wrap gap-2"></div>
                </div>

                <!-- Gallery Section -->
                <div id="galleryContainer" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg mt-6 p-4">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-indigo-500" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
                        </svg>
                        Gallery
                    </h3>
                    <div id="gallery" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3"></div>
                    <div id="emptyGallery" class="text-center py-6 text-gray-500 dark:text-gray-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                        <p>Your saved fractals will appear here</p>
                    </div>
                </div>
            </div>

            <!-- Controls Section -->
            <div class="lg:col-span-4">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 sticky top-4">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-indigo-500" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                        </svg>
                        Fractal Controls
                    </h3>

                    <!-- Fractal Type -->
                    <div class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2" for="fractalType">
                            Fractal Type
                            <button id="fractalInfoBtn" class="ml-1 text-gray-400 hover:text-indigo-500 transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </label>
                        <select id="fractalType" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="mandelbrot">Mandelbrot Set</option>
                            <option value="julia">Julia Set</option>
                            <option value="burningShip">Burning Ship</option>
                            <option value="mandelbox">Mandelbox</option>
                            <option value="sierpinskiCarpet">Sierpinski Carpet</option>
                            <option value="lyapunov">Lyapunov Fractal</option>
                            <option value="phoenix">Phoenix Fractal</option>
                            <option value="mandelbox3DSlice">Mandelbox 3D Slice</option>
                            <option value="newtonFractal">Newton Fractal</option>
                        </select>
                        <div id="fractalDescription" class="mt-2 text-sm text-gray-600 dark:text-gray-400 hidden"></div>
                    </div>

                    <!-- Iterations -->
                    <div class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2" for="maxIterations">
                            Maximum Iterations: <span id="iterationValue">100</span>
                        </label>
                        <input type="range" id="maxIterations" min="50" max="1000" value="100" step="10" class="w-full slider">
                        <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
                            <span>50</span>
                            <span>1000</span>
                        </div>
                    </div>

                    <!-- Color Scheme -->
                    <div class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2" for="colorScheme">
                            Color Scheme
                        </label>
                        <select id="colorScheme" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="default">Default</option>
                            <option value="rainbow">Rainbow</option>
                            <option value="fire">Fire</option>
                            <option value="ocean">Ocean</option>
                            <option value="psychedelic">Psychedelic</option>
                            <option value="pastel">Pastel</option>
                            <option value="neon">Neon</option>
                            <option value="grayscale">Grayscale</option>
                            <option value="autumn">Autumn</option>
                            <option value="electric">Electric</option>
                            <option value="cosmic">Cosmic</option>
                            <option value="vintage">Vintage</option>
                        </select>
                    </div>

                    <!-- Julia Set Parameters -->
                    <div id="juliaParams" class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2">
                            Julia Parameters
                        </label>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-gray-600 dark:text-gray-400 text-xs mb-1" for="juliaReal">Real Part:</label>
                                <input type="number" id="juliaReal" value="-0.7" step="0.05" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            </div>
                            <div>
                                <label class="block text-gray-600 dark:text-gray-400 text-xs mb-1" for="juliaImag">Imaginary Part:</label>
                                <input type="number" id="juliaImag" value="0.27015" step="0.05" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            </div>
                        </div>
                    </div>

                    <!-- Quality Settings -->
                    <div class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2 flex items-center">
                            <span>Interactive Quality</span>
                            <div class="ml-auto flex items-center">
                                <span id="interactiveQualityLabel" class="text-xs text-indigo-500 dark:text-indigo-400 font-medium">Balanced</span>
                                <span class="ml-1 text-xs text-gray-500 dark:text-gray-400">â†“</span>
                            </div>
                        </label>
                        <div class="flex items-center">
                            <span class="text-xs text-gray-500 dark:text-gray-400 mr-2">Fast</span>
                            <input type="range" id="interactiveQuality" min="1" max="3" value="2" step="1" class="flex-grow slider">
                            <span class="text-xs text-gray-500 dark:text-gray-400 ml-2">Smooth</span>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Affects rendering speed during interactions</p>
                    </div>

                    <div class="mb-4">
                        <label class="block text-gray-700 dark:text-gray-300 text-sm font-medium mb-2 flex items-center">
                            <span>Final Quality</span>
                            <div class="ml-auto flex items-center">
                                <span id="finalQualityLabel" class="text-xs text-indigo-500 dark:text-indigo-400 font-medium">Balanced</span>
                                <span class="ml-1 text-xs text-gray-500 dark:text-gray-400">â†“</span>
                            </div>
                        </label>
                        <div class="flex items-center">
                            <span class="text-xs text-gray-500 dark:text-gray-400 mr-2">Fast</span>
                            <input type="range" id="finalQuality" min="1" max="5" value="3" step="1" class="flex-grow slider">
                            <span class="text-xs text-gray-500 dark:text-gray-400 ml-2">Detailed</span>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Affects final render quality when idle</p>
                    </div>

                    <!-- Performance Stats -->
                    <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                        <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Performance Monitor</h4>
                        <div class="flex flex-wrap gap-2 text-xs">
                            <div class="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                                Render Time: <span id="renderTime" class="font-mono">0ms</span>
                            </div>
                            <div class="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                                FPS: <span id="fpsCounter" class="font-mono">0</span>
                            </div>
                            <div class="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                                Zoom: <span id="zoomLevel" class="font-mono">1.0x</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<!-- Modals -->
<div id="infoModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto mx-4">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900 dark:text-white">About Fractal Explorer</h3>
                <button id="closeInfoModal" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="prose dark:prose-invert dark:text-white max-w-none">
                <p>Fractal Explorer is an interactive tool for exploring mathematical fractals - complex patterns that exhibit self-similarity at different scales.</p>
                <h4>Controls:</h4>
                <ul>
                    <li><strong>Mouse Drag:</strong> Pan around the fractal</li>
                    <li><strong>Mouse Wheel:</strong> Zoom in/out at cursor position</li>
                    <li><strong>Double Click:</strong> Center and zoom in at clicked point</li>
                </ul>
                <h4>Fractal Types:</h4>
                <ul id="fractalInfoList"></ul>
                <p>Enjoy exploring these mathematical wonders and save your discoveries to the gallery!</p>
            </div>
        </div>
    </div>
</div>

<div id="shareModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900 dark:text-white">Share Fractal</h3>
                <button id="closeShareModal" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <p class="mb-4 text-gray-600 dark:text-gray-300">Copy this link to share your current fractal configuration:</p>
            <div class="flex mb-4">
                <input id="shareUrl" type="text" readonly class="flex-grow px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                <button id="copyShareUrl" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded-r-md transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                        <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                    </svg>
                </button>
            </div>
            <div class="text-center">
                <a id="downloadLink" download="fractal.png" class="inline-block bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-md transition-colors duration-200">
                    Download Image
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Fullscreen container for canvas -->
<div id="fullscreenContainer" class="fixed inset-0 bg-black z-50 hidden">
    <div class="absolute top-4 right-4 flex space-x-2">
        <button id="exitFullscreen" class="bg-white/20 hover:bg-white/30 text-white p-2 rounded-full transition-colors duration-200">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>
    <canvas id="fullscreenCanvas" class="w-full h-full fractal-canvas"></canvas>
</div>

<script>
    // Core fractal rendering engine and Web Worker implementation
    const canvas = document.getElementById('fractalCanvas');
    const ctx = canvas.getContext('2d');
    const fullscreenCanvas = document.getElementById('fullscreenCanvas');
    const fullscreenCtx = fullscreenCanvas.getContext('2d');

    // UI Elements
    const fractalType = document.getElementById('fractalType');
    const maxIterations = document.getElementById('maxIterations');
    const iterationValue = document.getElementById('iterationValue');
    const colorScheme = document.getElementById('colorScheme');
    const juliaReal = document.getElementById('juliaReal');
    const juliaImag = document.getElementById('juliaImag');
    const juliaParams = document.getElementById('juliaParams');
    const interactiveQuality = document.getElementById('interactiveQuality');
    const interactiveQualityLabel = document.getElementById('interactiveQualityLabel');
    const finalQuality = document.getElementById('finalQuality');
    const finalQualityLabel = document.getElementById('finalQualityLabel');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const resetBtn = document.getElementById('reset');
    const saveBtn = document.getElementById('save');
    const coordinatesDiv = document.getElementById('coordinates');
    const gallery = document.getElementById('gallery');
    const emptyGallery = document.getElementById('emptyGallery');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const interactionIndicator = document.getElementById('interactionIndicator');
    const indicatorText = document.getElementById('indicatorText');
    const renderTimeDisplay = document.getElementById('renderTime');
    const fpsCounter = document.getElementById('fpsCounter');
    const zoomLevelDisplay = document.getElementById('zoomLevel');
    const themeToggle = document.getElementById('themeToggle');
    const darkIcon = document.getElementById('darkIcon');
    const lightIcon = document.getElementById('lightIcon');
    const presetName = document.getElementById('presetName');
    const savePresetBtn = document.getElementById('savePreset');
    const presetList = document.getElementById('presetList');
    const randomizeBtn = document.getElementById('randomize');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const exitFullscreenBtn = document.getElementById('exitFullscreen');
    const fullscreenContainer = document.getElementById('fullscreenContainer');
    const shareBtn = document.getElementById('shareBtn');
    const shareModal = document.getElementById('shareModal');
    const closeShareModal = document.getElementById('closeShareModal');
    const shareUrl = document.getElementById('shareUrl');
    const copyShareUrlBtn = document.getElementById('copyShareUrl');
    const downloadLink = document.getElementById('downloadLink');
    const infoButton = document.getElementById('infoButton');
    const infoModal = document.getElementById('infoModal');
    const closeInfoModal = document.getElementById('closeInfoModal');
    const fractalInfoBtn = document.getElementById('fractalInfoBtn');
    const fractalDescription = document.getElementById('fractalDescription');
    const fractalInfoList = document.getElementById('fractalInfoList');

    // State variables
    let width = 800;
    let height = 600;
    let centerX = -0.5;
    let centerY = 0;
    let zoomLevel = 1;
    let isDragging = false;
    let lastX, lastY;
    let renderHighQualityInProgress = false;
    let renderLowQualityInProgress = false;
    let frameCount = 0;
    let lastFrameTime = 0;
    let fps = 0;
    let renderStartTime = 0;
    let workerHQ = null;
    let workerLQ = null;
    let isDarkMode = localStorage.getItem('darkMode') === 'true';
    let currentCanvas = canvas;
    let currentCtx = ctx;
    let isFullscreen = false;
    let interactiveQualityLevel = 2; // Default to medium
    let finalQualityLevel = 3; // Default to medium-high
    let lastRenderParams = {};
    let presets = JSON.parse(localStorage.getItem('fractals-presets') || '[]');
    let galleryItems = JSON.parse(localStorage.getItem('fractals-gallery') || '[]');

    // Advanced rendering management variables
    let isInteracting = false;
    let isRenderScheduled = false;
    let interactionEndTimeout = null;
    let lastInteractionTime = 0;
    let renderDebounceDelay = 100; // ms delay before high-quality render

    // Fractal descriptions
    const fractalDescriptions = {
        mandelbrot: "The Mandelbrot set is one of the most famous fractals, defined by the equation z = zÂ² + c, where z and c are complex numbers.",
        julia: "Julia sets are related to the Mandelbrot set, but with a fixed complex parameter that creates different patterns.",
        burningShip: "The Burning Ship fractal is a variant of the Mandelbrot set that uses the absolute values of the components.",
        mandelbox: "The Mandelbox is a 3D fractal with complex folding operations that create intricate box-like structures.",
        sierpinskiCarpet: "The Sierpinski Carpet is a classic fractal created by recursively removing the central portion of squares.",
        lyapunov: "The Lyapunov fractal visualizes the stability of dynamical systems and often shows intricate patterns.",
        phoenix: "The Phoenix fractal is based on a recursive formula that incorporates previous iterations for complex patterns.",
        mandelbox3DSlice: "This is a 2D slice of the 3D Mandelbox fractal, showing intricate detail of its internal structure.",
        newtonFractal: "Newton fractals visualize the basins of attraction when applying Newton's method to find roots of complex polynomials."
    };

    // Setup canvas and UI
    function initializeApp() {
        setupCanvasSize();
        initializeWebWorkers();
        updateTheme();
        setupJuliaParams();
        loadGalleryItems();
        renderPresetButtons();
        updateFractalDescription();
        populateFractalInfo();
        updateQualityLabels();
        checkUrlParams();

        // Initial rendering
        requestHighQualityRender();
    }

    function setupCanvasSize() {
        // Set initial canvas dimensions
        const containerWidth = canvas.parentElement.clientWidth;
        width = containerWidth;
        height = Math.round(width * 0.75);
        canvas.width = width;
        canvas.height = height;
        fullscreenCanvas.width = window.innerWidth;
        fullscreenCanvas.height = window.innerHeight;
    }

    function updateQualityLabels() {
        // Interactive quality label
        switch (parseInt(interactiveQuality.value)) {
            case 1: interactiveQualityLabel.textContent = "Fastest"; break;
            case 2: interactiveQualityLabel.textContent = "Balanced"; break;
            case 3: interactiveQualityLabel.textContent = "Smooth"; break;
        }

        // Final quality label
        switch (parseInt(finalQuality.value)) {
            case 1: finalQualityLabel.textContent = "Fastest"; break;
            case 2: finalQualityLabel.textContent = "Fast"; break;
            case 3: finalQualityLabel.textContent = "Balanced"; break;
            case 4: finalQualityLabel.textContent = "Detailed"; break;
            case 5: finalQualityLabel.textContent = "Ultra"; break;
        }
    }

    function initializeWebWorkers() {
        // Create a worker for high-quality rendering
        const workerScript = `
            // Worker for fractal rendering
            onmessage = function(e) {
                const { width, height, centerX, centerY, zoomLevel, maxIter, type,
                        colorScheme, juliaReal, juliaImag, quality, isInteractive } = e.data;

                // Calculate pixel size based on quality
                const pixelSkip = isInteractive ?
                    Math.max(1, 4 - quality) :  // Interactive mode: larger steps for speed
                    Math.max(1, 6 - quality);   // Final quality: finer steps for detail

                const imageData = new ImageData(width, height);
                const data = imageData.data;

                // Clear the buffer first
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 0;
                    data[i + 1] = 0;
                    data[i + 2] = 0;
                    data[i + 3] = 255;
                }

                // Render at the specified quality level
                for (let x = 0; x < width; x += pixelSkip) {
                    for (let y = 0; y < height; y += pixelSkip) {
                        const zx = 1.5 * (x - width / 2) / (0.5 * zoomLevel * width) + centerX;
                        const zy = (y - height / 2) / (0.5 * zoomLevel * height) + centerY;

                        let value;
                        switch (type) {
                            case 'julia':
                                value = julia(zx, zy, juliaReal, juliaImag, maxIter);
                                break;
                            case 'burningShip':
                                value = burningShip(zx, zy, maxIter);
                                break;
                            case 'mandelbox':
                                value = mandelbox(zx, zy, maxIter);
                                break;
                            case 'sierpinskiCarpet':
                                value = sierpinskiCarpet(zx, zy, maxIter);
                                break;
                            case 'lyapunov':
                                value = lyapunov(zx, zy, maxIter);
                                break;
                            case 'phoenix':
                                value = phoenix(zx, zy, maxIter);
                                break;
                            case 'mandelbox3DSlice':
                                value = mandelbox3DSlice(zx, zy, maxIter);
                                break;
                            case 'newtonFractal':
                                value = newtonFractal(zx, zy, maxIter);
                                break;
                            default:
                                value = mandelbrot(zx, zy, maxIter);
                        }

                        const [r, g, b] = getColor(value, maxIter, colorScheme, type);

                        // Fill the rectangle of pixels
                        for (let dx = 0; dx < pixelSkip && x + dx < width; dx++) {
                            for (let dy = 0; dy < pixelSkip && y + dy < height; dy++) {
                                const pos = ((y + dy) * width + (x + dx)) * 4;
                                data[pos] = r;
                                data[pos + 1] = g;
                                data[pos + 2] = b;
                                data[pos + 3] = 255;
                            }
                        }
                    }

                    // Report progress more frequently during interactive mode
                    if (isInteractive) {
                        if (x % 40 === 0) {
                            const progress = x / width;
                            postMessage({ type: 'progress', progress, imageData });
                        }
                    } else {
                        if (x % 20 === 0) {
                            const progress = x / width;
                            postMessage({ type: 'progress', progress, imageData });
                        }
                    }
                }

                // Final render
                postMessage({ type: 'complete', imageData });
            };

            // Fractal algorithms
            function mandelbrot(x0, y0, maxIter) {
                let x = 0, y = 0, x2 = 0, y2 = 0, iter = 0;
                while (x2 + y2 <= 4 && iter < maxIter) {
                    y = 2 * x * y + y0;
                    x = x2 - y2 + x0;
                    x2 = x * x;
                    y2 = y * y;
                    iter++;
                }
                return iter;
            }

            function julia(x, y, cx, cy, maxIter) {
                let x2 = x * x, y2 = y * y, iter = 0;
                while (x2 + y2 <= 4 && iter < maxIter) {
                    y = 2 * x * y + cy;
                    x = x2 - y2 + cx;
                    x2 = x * x;
                    y2 = y * y;
                    iter++;
                }
                return iter;
            }

            function burningShip(x0, y0, maxIter) {
                let x = 0, y = 0, x2 = 0, y2 = 0, iter = 0;
                while (x2 + y2 <= 4 && iter < maxIter) {
                    y = Math.abs(2 * x * y) - y0;
                    x = x2 - y2 + x0;
                    x2 = x * x;
                    y2 = y * y;
                    iter++;
                }
                return iter;
            }

            function mandelbox(x, y, maxIter) {
                const SCALE = 2;
                const MINRAD2 = 0.25;
                let zx = x;
                let zy = y;
                let c = 0;
                for (let i = 0; i < maxIter; i++) {
                    if (zx > 1) {
                        zx = 2 - zx;
                    } else if (zx < -1) {
                        zx = -2 - zx;
                    }
                    if (zy > 1) {
                        zy = 2 - zy;
                    } else if (zy < -1) {
                        zy = -2 - zy;
                    }
                    let r2 = zx * zx + zy * zy;
                    if (r2 < MINRAD2) {
                        const temp = SCALE / MINRAD2;
                        zx = temp * zx;
                        zy = temp * zy;
                    } else if (r2 < 1) {
                        const temp = SCALE / r2;
                        zx = temp * zx;
                        zy = temp * zy;
                    }
                    zx = SCALE * zx + x;
                    zy = SCALE * zy + y;
                    if (zx * zx + zy * zy > 4) {
                        return i;
                    }
                    c++;
                }
                return c;
            }

            function sierpinskiCarpet(x, y, maxIter) {
                let iter = 0;
                while (iter < maxIter) {
                    if ((Math.floor(x * 3) % 3 == 1) && (Math.floor(y * 3) % 3 == 1)) {
                        return iter;
                    }
                    x *= 3;
                    y *= 3;
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    iter++;
                }
                return maxIter;
            }

            function lyapunov(x, y, maxIter) {
                const a = 3.7 * x;
                const b = 3.7 * y;
                let x0 = 0.5;
                let sum = 0;
                for (let i = 0; i < maxIter; i++) {
                    const r = i % 2 === 0 ? a : b;
                    x0 = r * x0 * (1 - x0);
                    sum += Math.log(Math.abs(r * (1 - 2 * x0)));
                }
                return sum / maxIter;
            }

            function phoenix(x, y, maxIter) {
                let x1 = x, y1 = y, x2 = 0, y2 = 0;
                const p = -0.5, q = 0.0;
                for (let i = 0; i < maxIter; i++) {
                    const xx = x1 * x1 - y1 * y1 + x + p * x2;
                    const yy = 2 * x1 * y1 + y + q * y2;
                    if (xx * xx + yy * yy > 4) return i;
                    x2 = x1;
                    y2 = y1;
                    x1 = xx;
                    y1 = yy;
                }
                return maxIter;
            }

            function mandelbox3DSlice(x, y, maxIter) {
                const scale = 2;
                let zx = x, zy = y, zz = 0;
                let c = 0;
                for (let i = 0; i < maxIter; i++) {
                    zx = clamp(zx, -1, 1) * 2 - zx;
                    zy = clamp(zy, -1, 1) * 2 - zy;
                    zz = clamp(zz, -1, 1) * 2 - zz;

                    const r = Math.sqrt(zx*zx + zy*zy + zz*zz);
                    if (r < 0.5) {
                        zx *= 4; zy *= 4; zz *= 4;
                    } else if (r < 1) {
                        zx /= r*r; zy /= r*r; zz /= r*r;
                    }

                    zx = zx * scale + x;
                    zy = zy * scale + y;
                    zz = zz * scale;

                    if (zx*zx + zy*zy + zz*zz > 4) return i;
                    c++;
                }
                return c;
            }

            function clamp(x, min, max) {
                return Math.min(Math.max(x, min), max);
            }

            function newtonFractal(x, y, maxIter) {
                let zx = x, zy = y;
                for (let i = 0; i < maxIter; i++) {
                    const zx2 = zx * zx, zy2 = zy * zy;
                    const zx3 = zx2 * zx - 3 * zx * zy2;
                    const zy3 = 3 * zx2 * zy - zy2 * zy;
                    const mag = zx3 * zx3 + zy3 * zy3;
                    if (mag < 1e-6) return i;
                    const denom = 3 * (zx2 + zy2);
                    zx -= (zx3 + 1) / denom;
                    zy -= zy3 / denom;
                }
                return maxIter;
            }

            function getColor(value, maxIter, scheme, type) {
                if (type === 'lyapunov') {
                    // Lyapunov fractal uses a different coloring scheme
                    const hue = (value + 5) / 10; // Adjust this range as needed
                    return hsvToRgb(hue, 1, 1);
                }

                if (value === maxIter) return [0, 0, 0];

                const t = value / maxIter;
                switch (scheme) {
                    case 'rainbow':
                        return hsvToRgb(t, 1, 1);
                    case 'fire':
                        return hsvToRgb(t / 3, 1, Math.min(1, t * 2));
                    case 'ocean':
                        return hsvToRgb(0.6 + t / 3, 1, Math.min(1, t * 2));
                    case 'psychedelic':
                        return hsvToRgb(Math.sin(t * Math.PI), 1, 1);
                    case 'pastel':
                        return hsvToRgb(t, 0.5, 1);
                    case 'neon':
                        return hsvToRgb(t, 1, t < 0.5 ? 0.5 + t : 1);
                    case 'grayscale':
                        const gray = Math.floor(t * 255);
                        return [gray, gray, gray];
                    case 'autumn':
                        return [
                            Math.floor(255 * t),
                            Math.floor(128 * Math.sin(Math.PI * t)),
                            Math.floor(64 * (1 - t))
                        ];
                    case 'electric':
                        return hsvToRgb(0.6 + 0.4 * t, 1, t < 0.5 ? 2 * t : 1);
                    case 'cosmic':
                        return [
                            Math.floor(128 * (1 + Math.sin(2 * Math.PI * t))),
                            Math.floor(128 * (1 + Math.sin(2 * Math.PI * t + 2 * Math.PI / 3))),
                            Math.floor(128 * (1 + Math.sin(2 * Math.PI * t + 4 * Math.PI / 3)))
                        ];
                    case 'vintage':
                        return [
                            Math.floor(255 * (0.5 + 0.5 * Math.sin(Math.PI * t))),
                            Math.floor(255 * (0.5 + 0.5 * Math.sin(Math.PI * t + Math.PI / 2))),
                            Math.floor(255 * (0.5 + 0.5 * Math.sin(Math.PI * t + Math.PI)))
                        ];
                    default:
                        return hsvToRgb(t, 1, Math.sqrt(t));
                }
            }

            function hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0: r = v, g = t, b = p; break;
                    case 1: r = q, g = v, b = p; break;
                    case 2: r = p, g = v, b = t; break;
                    case 3: r = p, g = q, b = v; break;
                    case 4: r = t, g = p, b = v; break;
                    case 5: r = v, g = p, b = q; break;
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        `;

        const blob = new Blob([workerScript], { type: 'application/javascript' });
        workerHQ = new Worker(URL.createObjectURL(blob));
        workerLQ = new Worker(URL.createObjectURL(blob));

        // High-quality worker handler
        workerHQ.onmessage = function(e) {
            const { type, progress, imageData } = e.data;

            if (type === 'progress') {
                // Only update if not currently interacting
                if (!isInteracting) {
                    currentCtx.putImageData(imageData, 0, 0);
                }
            } else if (type === 'complete') {
                // Final render
                currentCtx.putImageData(imageData, 0, 0);
                renderHighQualityInProgress = false;
                loadingOverlay.classList.add('hidden');

                // Update performance stats
                const renderTime = performance.now() - renderStartTime;
                renderTimeDisplay.textContent = `${Math.round(renderTime)}ms`;
            }
        };

        // Low-quality worker handler for interactive mode
        workerLQ.onmessage = function(e) {
            const { type, imageData } = e.data;

            if (type === 'progress' || type === 'complete') {
                currentCtx.putImageData(imageData, 0, 0);

                if (type === 'complete') {
                    renderLowQualityInProgress = false;
                    // If user has stopped interacting, request high quality
                    if (!isInteracting && !renderHighQualityInProgress) {
                        scheduleHighQualityRender();
                    }
                }
            }
        };
    }

    function setupJuliaParams() {
        function toggleJuliaParams() {
            if (fractalType.value === 'julia') {
                juliaParams.classList.remove('hidden');
            } else {
                juliaParams.classList.add('hidden');
            }
        }
        toggleJuliaParams();
        fractalType.addEventListener('change', toggleJuliaParams);
    }

    function updateTheme() {
        if (isDarkMode) {
            document.documentElement.classList.add('dark');
            darkIcon.classList.remove('hidden');
            lightIcon.classList.add('hidden');
        } else {
            document.documentElement.classList.remove('dark');
            darkIcon.classList.add('hidden');
            lightIcon.classList.remove('hidden');
        }
    }

    function updateFractalDescription() {
        const description = fractalDescriptions[fractalType.value];
        if (description) {
            fractalDescription.textContent = description;
        }
    }

    function populateFractalInfo() {
        // Populate fractal descriptions in the info modal
        fractalInfoList.innerHTML = '';
        Object.entries(fractalDescriptions).forEach(([key, desc]) => {
            const li = document.createElement('li');
            const name = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            li.innerHTML = `<strong>${name}</strong>: ${desc}`;
            fractalInfoList.appendChild(li);
        });
    }

    function loadGalleryItems() {
        gallery.innerHTML = '';

        if (galleryItems.length === 0) {
            emptyGallery.classList.remove('hidden');
            return;
        }

        emptyGallery.classList.add('hidden');

        galleryItems.forEach((item, index) => {
            const container = document.createElement('div');
            container.className = 'relative group';

            const img = document.createElement('img');
            img.src = item.imageData;
            img.className = 'w-full h-auto rounded shadow hover:shadow-lg transition-shadow cursor-pointer';
            img.addEventListener('click', () => window.open(img.src, '_blank'));

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity rounded';

            const loadBtn = document.createElement('button');
            loadBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white p-1 rounded-full mx-1';
            loadBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
            </svg>`;
            loadBtn.title = 'Load Settings';
            loadBtn.addEventListener('click', () => loadFractalSettings(item.settings));

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'bg-red-600 hover:bg-red-700 text-white p-1 rounded-full mx-1';
            deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>`;
            deleteBtn.title = 'Delete';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('Are you sure you want to delete this fractal?')) {
                    galleryItems.splice(index, 1);
                    localStorage.setItem('fractals-gallery', JSON.stringify(galleryItems));
                    loadGalleryItems();
                }
            });

            actionsDiv.appendChild(loadBtn);
            actionsDiv.appendChild(deleteBtn);

            container.appendChild(img);
            container.appendChild(actionsDiv);
            gallery.appendChild(container);
        });
    }

    function renderPresetButtons() {
        presetList.innerHTML = '';

        presets.forEach((preset, index) => {
            const presetBtn = document.createElement('button');
            presetBtn.className = 'px-2 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-indigo-100 dark:hover:bg-indigo-900 text-sm rounded transition-colors flex items-center group relative';
            presetBtn.textContent = preset.name;

            // Delete button that appears on hover
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'ml-1 text-red-500 opacity-0 group-hover:opacity-100 transition-opacity';
            deleteBtn.innerHTML = 'Ã—';
            deleteBtn.title = 'Delete preset';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm(`Delete preset "${preset.name}"?`)) {
                    presets.splice(index, 1);
                    localStorage.setItem('fractals-presets', JSON.stringify(presets));
                    renderPresetButtons();
                }
            });

            presetBtn.appendChild(deleteBtn);

            presetBtn.addEventListener('click', () => {
                loadFractalSettings(preset.settings);
            });

            presetList.appendChild(presetBtn);
        });
    }

    function checkUrlParams() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('settings')) {
            try {
                const settings = JSON.parse(atob(urlParams.get('settings')));
                loadFractalSettings(settings);
            } catch (e) {
                console.error("Error loading settings from URL:", e);
            }
        }
    }

    function saveCurrentPreset() {
        const name = presetName.value.trim();
        if (!name) {
            alert("Please enter a preset name");
            return;
        }

        const settings = getCurrentSettings();

        // Check for duplicate names
        const existingIndex = presets.findIndex(p => p.name === name);
        if (existingIndex >= 0) {
            if (!confirm(`Replace existing preset "${name}"?`)) {
                return;
            }
            presets[existingIndex].settings = settings;
        } else {
            presets.push({ name, settings });
        }

        localStorage.setItem('fractals-presets', JSON.stringify(presets));
        presetName.value = '';
        renderPresetButtons();
    }

    function loadFractalSettings(settings) {
        fractalType.value = settings.type;
        maxIterations.value = settings.maxIterations;
        iterationValue.textContent = settings.maxIterations;
        colorScheme.value = settings.colorScheme;
        juliaReal.value = settings.juliaReal;
        juliaImag.value = settings.juliaImag;
        interactiveQuality.value = settings.interactiveQuality || 2;
        finalQuality.value = settings.finalQuality || 3;

        centerX = settings.centerX;
        centerY = settings.centerY;
        zoomLevel = settings.zoomLevel;

        setupJuliaParams();
        updateFractalDescription();
        updateQualityLabels();
        requestHighQualityRender();
    }

    function getCurrentSettings() {
        return {
            type: fractalType.value,
            maxIterations: parseInt(maxIterations.value),
            colorScheme: colorScheme.value,
            juliaReal: parseFloat(juliaReal.value),
            juliaImag: parseFloat(juliaImag.value),
            interactiveQuality: parseInt(interactiveQuality.value),
            finalQuality: parseInt(finalQuality.value),
            centerX: centerX,
            centerY: centerY,
            zoomLevel: zoomLevel
        };
    }

    function randomizeFractalSettings() {
        // Choose a random fractal type
        const types = Array.from(fractalType.options).map(opt => opt.value);
        fractalType.value = types[Math.floor(Math.random() * types.length)];

        // Randomize iterations (between 100-500)
        const iterations = Math.floor(Math.random() * 400) + 100;
        maxIterations.value = iterations;
        iterationValue.textContent = iterations;

        // Randomize color scheme
        const schemes = Array.from(colorScheme.options).map(opt => opt.value);
        colorScheme.value = schemes[Math.floor(Math.random() * schemes.length)];

        // Randomize Julia parameters if needed
        juliaReal.value = (Math.random() * 2 - 1).toFixed(3);
        juliaImag.value = (Math.random() * 2 - 1).toFixed(3);

        // Reset view with slight randomization
        centerX = -0.5 + (Math.random() * 0.4 - 0.2);
        centerY = 0 + (Math.random() * 0.4 - 0.2);
        zoomLevel = 0.8 + Math.random() * 0.4;

        setupJuliaParams();
        updateFractalDescription();
        requestHighQualityRender();
    }

    // New Two-Tier Rendering System for Fluid UX
    function startInteraction() {
        if (!isInteracting) {
            isInteracting = true;
            interactionIndicator.classList.remove('hidden');
            indicatorText.textContent = "Interactive Mode";

            // Cancel any pending high-quality renders
            if (renderHighQualityInProgress) {
                workerHQ.terminate();
                workerHQ = null;
                const blob = new Blob([document.querySelector('script').textContent], { type: 'application/javascript' });
                workerHQ = new Worker(URL.createObjectURL(blob));
                renderHighQualityInProgress = false;
            }
        }

        // Update last interaction time
        lastInteractionTime = performance.now();

        // Clear any existing timeouts
        if (interactionEndTimeout) {
            clearTimeout(interactionEndTimeout);
        }

        // Set a new timeout for ending interaction state
        interactionEndTimeout = setTimeout(() => {
            endInteraction();
        }, renderDebounceDelay);

        // Request a low-quality render if not already in progress
        requestLowQualityRender();
    }

    function endInteraction() {
        isInteracting = false;
        interactionIndicator.classList.add('hidden');

        // Schedule a high-quality render
        scheduleHighQualityRender();
    }

    function scheduleHighQualityRender() {
        if (!isRenderScheduled && !renderHighQualityInProgress) {
            isRenderScheduled = true;
            setTimeout(() => {
                isRenderScheduled = false;
                if (!isInteracting) {
                    requestHighQualityRender();
                }
            }, 50); // Short delay to batch multiple changes
        }
    }

    function requestLowQualityRender() {
        if (renderLowQualityInProgress) {
            return; // Already rendering
        }

        renderLowQualityInProgress = true;

        // Collect render parameters
        interactiveQualityLevel = parseInt(interactiveQuality.value);
        const params = {
            width: currentCanvas.width,
            height: currentCanvas.height,
            centerX: centerX,
            centerY: centerY,
            zoomLevel: zoomLevel,
            maxIter: parseInt(maxIterations.value),
            type: fractalType.value,
            colorScheme: colorScheme.value,
            juliaReal: parseFloat(juliaReal.value),
            juliaImag: parseFloat(juliaImag.value),
            quality: interactiveQualityLevel,
            isInteractive: true
        };

        // Store for share url
        lastRenderParams = params;

        // Update zoom level display
        zoomLevelDisplay.textContent = zoomLevel.toFixed(1) + 'x';

        // Start rendering
        workerLQ.postMessage(params);
    }

    function requestHighQualityRender() {
        if (renderHighQualityInProgress) {
            return;
        }

        renderHighQualityInProgress = true;
        loadingOverlay.classList.remove('hidden');
        renderStartTime = performance.now();

        // Collect render parameters
        finalQualityLevel = parseInt(finalQuality.value);
        const params = {
            width: currentCanvas.width,
            height: currentCanvas.height,
            centerX: centerX,
            centerY: centerY,
            zoomLevel: zoomLevel,
            maxIter: parseInt(maxIterations.value),
            type: fractalType.value,
            colorScheme: colorScheme.value,
            juliaReal: parseFloat(juliaReal.value),
            juliaImag: parseFloat(juliaImag.value),
            quality: finalQualityLevel,
            isInteractive: false
        };

        // Store for share url
        lastRenderParams = params;

        // Update zoom level display
        zoomLevelDisplay.textContent = zoomLevel.toFixed(1) + 'x';

        // Start rendering
        workerHQ.postMessage(params);
    }

    function updatePerformanceStats(timestamp) {
        if (!lastFrameTime) {
            lastFrameTime = timestamp;
            frameCount = 0;
        }

        frameCount++;

        if (timestamp - lastFrameTime >= 1000) {
            fps = Math.round((frameCount * 1000) / (timestamp - lastFrameTime));
            fpsCounter.textContent = fps;
            frameCount = 0;
            lastFrameTime = timestamp;
        }

        requestAnimationFrame(updatePerformanceStats);
    }

    function enterFullscreen() {
        isFullscreen = true;
        fullscreenContainer.classList.remove('hidden');
        fullscreenCanvas.width = window.innerWidth;
        fullscreenCanvas.height = window.innerHeight;
        currentCanvas = fullscreenCanvas;
        currentCtx = fullscreenCtx;
        requestHighQualityRender();
    }

    function exitFullscreen() {
        isFullscreen = false;
        fullscreenContainer.classList.add('hidden');
        currentCanvas = canvas;
        currentCtx = ctx;
        requestHighQualityRender();
    }

    function saveFractal() {
        // Request a high-quality render first to ensure best image quality
        if (isInteracting) {
            endInteraction();
        }

        // Wait for the high-quality render to complete
        function waitForRenderAndSave() {
            if (renderHighQualityInProgress) {
                setTimeout(waitForRenderAndSave, 100);
                return;
            }

            const dataUrl = currentCanvas.toDataURL('image/png');

            // Save to gallery
            const settings = getCurrentSettings();
            galleryItems.push({
                imageData: dataUrl,
                settings: settings,
                timestamp: new Date().toISOString()
            });

            // Keep gallery at a reasonable size
            if (galleryItems.length > 12) {
                galleryItems = galleryItems.slice(-12);
            }

            localStorage.setItem('fractals-gallery', JSON.stringify(galleryItems));
            loadGalleryItems();

            // For direct download
            const link = document.createElement('a');
            link.download = `fractal-${new Date().toISOString().slice(0,10)}.png`;
            link.href = dataUrl;
            link.click();
        }

        requestHighQualityRender();
        waitForRenderAndSave();
    }

    function showShareModal() {
        // Generate share URL
        const settings = getCurrentSettings();
        const encodedSettings = btoa(JSON.stringify(settings));
        const shareURL = `${window.location.origin}${window.location.pathname}?settings=${encodedSettings}`;

        shareUrl.value = shareURL;

        // Set download link
        downloadLink.href = currentCanvas.toDataURL('image/png');

        // Show modal
        shareModal.classList.remove('hidden');
    }

    function closeShareModalFn() {
        shareModal.classList.add('hidden');
    }

    function copyShareUrlToClipboard() {
        shareUrl.select();
        document.execCommand('copy');

        const originalText = copyShareUrlBtn.innerHTML;
        copyShareUrlBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
        </svg>`;

        setTimeout(() => {
            copyShareUrlBtn.innerHTML = originalText;
        }, 2000);
    }

    function showInfoModal() {
        infoModal.classList.remove('hidden');
    }

    function closeInfoModalFn() {
        infoModal.classList.add('hidden');
    }

    function showFractalDescription() {
        if (fractalDescription.classList.contains('hidden')) {
            fractalDescription.classList.remove('hidden');
        } else {
            fractalDescription.classList.add('hidden');
        }
    }

    // Setup event listeners
    function setupEventListeners() {
        // Canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
            startInteraction();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width * 3 / zoomLevel + centerX - 1.5 / zoomLevel;
            const y = (e.clientY - rect.top) / canvas.height * 2 / zoomLevel + centerY - 1 / zoomLevel;
            coordinatesDiv.textContent = `(${x.toFixed(6)}, ${y.toFixed(6)})`;

            if (isDragging) {
                const dx = (e.clientX - lastX) / canvas.width * 3 / zoomLevel;
                const dy = (e.clientY - lastY) / canvas.height * 2 / zoomLevel;
                centerX -= dx;
                centerY -= dy;
                lastX = e.clientX;
                lastY = e.clientY;
                startInteraction();
            }
        });

        fullscreenCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            fullscreenCanvas.style.cursor = 'grabbing';
            startInteraction();
        });

        fullscreenCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = fullscreenCanvas.getBoundingClientRect();
                const dx = (e.clientX - lastX) / rect.width * 3 / zoomLevel;
                const dy = (e.clientY - lastY) / rect.height * 2 / zoomLevel;
                centerX -= dx;
                centerY -= dy;
                lastX = e.clientX;
                lastY = e.clientY;
                startInteraction();
            }
        });

        const stopDragging = () => {
            isDragging = false;
            canvas.style.cursor = 'move';
            fullscreenCanvas.style.cursor = 'move';
        };

        canvas.addEventListener('mouseup', stopDragging);
        canvas.addEventListener('mouseleave', stopDragging);
        fullscreenCanvas.addEventListener('mouseup', stopDragging);
        fullscreenCanvas.addEventListener('mouseleave', stopDragging);

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / canvas.width;
            const mouseY = (e.clientY - rect.top) / canvas.height;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

            centerX += (1 - zoomFactor) * (mouseX - 0.5) * 3 / zoomLevel;
            centerY += (1 - zoomFactor) * (mouseY - 0.5) * 2 / zoomLevel;
            zoomLevel *= zoomFactor;

            startInteraction();
        });

        fullscreenCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = fullscreenCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width;
            const mouseY = (e.clientY - rect.top) / rect.height;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

            centerX += (1 - zoomFactor) * (mouseX - 0.5) * 3 / zoomLevel;
            centerY += (1 - zoomFactor) * (mouseY - 0.5) * 2 / zoomLevel;
            zoomLevel *= zoomFactor;

            startInteraction();
        });

        // Double-click to zoom in at a point
        canvas.addEventListener('dblclick', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / canvas.width;
            const mouseY = (e.clientY - rect.top) / canvas.height;

            centerX += (mouseX - 0.5) * 3 / zoomLevel;
            centerY += (mouseY - 0.5) * 2 / zoomLevel;
            zoomLevel *= 2;

            startInteraction();
        });

        fullscreenCanvas.addEventListener('dblclick', (e) => {
            const rect = fullscreenCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width;
            const mouseY = (e.clientY - rect.top) / rect.height;

            centerX += (mouseX - 0.5) * 3 / zoomLevel;
            centerY += (mouseY - 0.5) * 2 / zoomLevel;
            zoomLevel *= 2;

            startInteraction();
        });

        // Button controls
        zoomInBtn.addEventListener('click', () => {
            zoomLevel *= 1.5;
            startInteraction();
        });

        zoomOutBtn.addEventListener('click', () => {
            zoomLevel /= 1.5;
            startInteraction();
        });

        resetBtn.addEventListener('click', () => {
            centerX = -0.5;
            centerY = 0;
            zoomLevel = 1;
            requestHighQualityRender();
        });

        saveBtn.addEventListener('click', saveFractal);

        // Form controls
        [fractalType, colorScheme, juliaReal, juliaImag].forEach(el => {
            el.addEventListener('change', () => {
                if (el === fractalType) {
                    updateFractalDescription();
                }
                requestHighQualityRender();
            });
        });

        maxIterations.addEventListener('input', () => {
            iterationValue.textContent = maxIterations.value;
        });

        maxIterations.addEventListener('change', () => {
            requestHighQualityRender();
        });

        // Quality controls
        interactiveQuality.addEventListener('input', () => {
            updateQualityLabels();
        });

        finalQuality.addEventListener('input', () => {
            updateQualityLabels();
        });

        // Theme toggle
        themeToggle.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            localStorage.setItem('darkMode', isDarkMode);
            updateTheme();
        });

        // Preset controls
        savePresetBtn.addEventListener('click', saveCurrentPreset);
        randomizeBtn.addEventListener('click', randomizeFractalSettings);

        // Fullscreen controls
        fullscreenBtn.addEventListener('click', enterFullscreen);
        exitFullscreenBtn.addEventListener('click', exitFullscreen);

        // Share controls
        shareBtn.addEventListener('click', showShareModal);
        closeShareModal.addEventListener('click', closeShareModalFn);
        copyShareUrlBtn.addEventListener('click', copyShareUrlToClipboard);

        // Info modal
        infoButton.addEventListener('click', showInfoModal);
        closeInfoModal.addEventListener('click', closeInfoModalFn);
        fractalInfoBtn.addEventListener('click', showFractalDescription);

        // Window resize
        window.addEventListener('resize', () => {
            if (!isFullscreen) {
                setupCanvasSize();
                requestHighQualityRender();
            } else {
                fullscreenCanvas.width = window.innerWidth;
                fullscreenCanvas.height = window.innerHeight;
                requestHighQualityRender();
            }
        });

        // Touch support for mobile
        function setupTouchEvents(canvasElement) {
            let lastTouchDistance = 0;

            canvasElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    startInteraction();
                } else if (e.touches.length === 2) {
                    // Prepare for pinch zoom
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    lastTouchDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                }
                e.preventDefault();
            });

            canvasElement.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const dx = (e.touches[0].clientX - lastX) / canvasElement.width * 3 / zoomLevel;
                    const dy = (e.touches[0].clientY - lastY) / canvasElement.height * 2 / zoomLevel;
                    centerX -= dx;
                    centerY -= dy;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    startInteraction();
                } else if (e.touches.length === 2) {
                    // Handle pinch zoom
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const touchDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );

                    if (lastTouchDistance > 0) {
                        const zoomFactor = touchDistance / lastTouchDistance;

// Calculate the center point between the two touches
                        const centerTouchX = (touch1.clientX + touch2.clientX) / 2;
                        const centerTouchY = (touch1.clientY + touch2.clientY) / 2;

                        const rect = canvasElement.getBoundingClientRect();
                        const mouseX = (centerTouchX - rect.left) / canvasElement.width;
                        const mouseY = (centerTouchY - rect.top) / canvasElement.height;

                        centerX += (1 - zoomFactor) * (mouseX - 0.5) * 3 / zoomLevel;
                        centerY += (1 - zoomFactor) * (mouseY - 0.5) * 2 / zoomLevel;
                        zoomLevel *= zoomFactor;

                        startInteraction();
                    }

                    lastTouchDistance = touchDistance;
                }
                e.preventDefault();
            });

            canvasElement.addEventListener('touchend', () => {
                isDragging = false;
                lastTouchDistance = 0;

                // Small delay before ending interaction to allow for tap events
                setTimeout(() => {
                    if (!isDragging && !isInteracting) {
                        endInteraction();
                    }
                }, 50);
            });
        }

        setupTouchEvents(canvas);
        setupTouchEvents(fullscreenCanvas);
    }

    // Initialize and start
    initializeApp();
    setupEventListeners();
    requestAnimationFrame(updatePerformanceStats);
</script>
<script src="../logo.js"></script>
</body>
</html>