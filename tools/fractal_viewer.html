<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒ€</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description"
          content="Explore mesmerizing fractals with our interactive Fractal Viewer. Customize, zoom, and save your unique creations.">
    <title>Fractal Viewer - Interactive Fractal Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans transition-colors duration-300">
<div class="container mx-auto px-4 py-8 max-w-4xl"><h1
        class="text-4xl font-bold text-center mb-6 text-indigo-600 dark:text-indigo-400">Fractal Viewer</h1>
    <div class="bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 mb-6 transition-all duration-300">
        <canvas id="fractalCanvas" class="w-full rounded-lg shadow-inner mb-4 cursor-move"></canvas>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="fractalType">Fractal
                Type:</label><select id="fractalType"
                                     class="w-full p-2 border rounded dark:bg-gray-700 dark:text-white">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="julia">Julia Set</option>
                <option value="burningShip">Burning Ship</option>
                <option value="mandelbox">Mandelbox</option>
            </select></div>
            <div><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="maxIterations">Max
                Iterations: <span id="iterationValue">100</span></label><input type="range" id="maxIterations" min="50"
                                                                               max="1000" value="100" class="w-full">
            </div>
            <div><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="colorScheme">Color
                Scheme:</label><select id="colorScheme"
                                       class="w-full p-2 border rounded dark:bg-gray-700 dark:text-white">
                <option value="default">Default</option>
                <option value="rainbow">Rainbow</option>
                <option value="fire">Fire</option>
                <option value="ocean">Ocean</option>
                <option value="psychedelic">Psychedelic</option>
            </select></div>
            <div><label class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" for="juliaReal">Julia
                Real:</label><input type="number" id="juliaReal" value="-0.7" step="0.1"
                                    class="w-full p-2 border rounded dark:bg-gray-700 dark:text-white"><label
                    class="block text-gray-700 dark:text-gray-300 text-sm font-bold mt-2 mb-2" for="juliaImag">Julia
                Imaginary:</label><input type="number" id="juliaImag" value="0.27015" step="0.1"
                                         class="w-full p-2 border rounded dark:bg-gray-700 dark:text-white"></div>
        </div>
        <div class="flex flex-wrap justify-center gap-2 mb-4">
            <button id="zoomIn"
                    class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors duration-300">
                Zoom In
            </button>
            <button id="zoomOut"
                    class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition-colors duration-300">
                Zoom Out
            </button>
            <button id="reset"
                    class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded transition-colors duration-300">
                Reset
            </button>
            <button id="save"
                    class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded transition-colors duration-300">
                Save
            </button>
        </div>
        <div id="coordinates" class="text-sm text-gray-600 dark:text-gray-400 text-center"></div>
    </div>
    <div id="gallery" class="grid grid-cols-2 md:grid-cols-3 gap-4"></div>
</div>
<script>
    const canvas = document.getElementById('fractalCanvas');
    const ctx = canvas.getContext('2d');
    const fractalType = document.getElementById('fractalType');
    const maxIterations = document.getElementById('maxIterations');
    const iterationValue = document.getElementById('iterationValue');
    const colorScheme = document.getElementById('colorScheme');
    const juliaReal = document.getElementById('juliaReal');
    const juliaImag = document.getElementById('juliaImag');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const resetBtn = document.getElementById('reset');
    const saveBtn = document.getElementById('save');
    const coordinatesDiv = document.getElementById('coordinates');
    const gallery = document.getElementById('gallery');
    let width = 800, height = 600;
    let centerX = -0.5, centerY = 0, zoomLevel = 1;
    let isDragging = false, lastX, lastY;
    canvas.width = width;
    canvas.height = height;

    function generateFractal() {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;
        const maxIter = parseInt(maxIterations.value);
        const scheme = colorScheme.value;
        const type = fractalType.value;
        const jr = parseFloat(juliaReal.value);
        const ji = parseFloat(juliaImag.value);
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                const zx = 1.5 * (x - width / 2) / (0.5 * zoomLevel * width) + centerX;
                const zy = (y - height / 2) / (0.5 * zoomLevel * height) + centerY;
                let i;
                if (type === 'julia') i = julia(zx, zy, jr, ji, maxIter); else if (type === 'burningShip') i = burningShip(zx, zy, maxIter); else if (type === 'mandelbox') i = mandelbox(zx, zy, maxIter); else i = mandelbrot(zx, zy, maxIter);
                const [r, g, b] = getColor(i, maxIter, scheme);
                const pos = (y * width + x) * 4;
                data[pos] = r;
                data[pos + 1] = g;
                data[pos + 2] = b;
                data[pos + 3] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }

    function mandelbrot(x0, y0, maxIter) {
        let x = 0, y = 0, x2 = 0, y2 = 0, iter = 0;
        while (x2 + y2 <= 4 && iter < maxIter) {
            y = 2 * x * y + y0;
            x = x2 - y2 + x0;
            x2 = x * x;
            y2 = y * y;
            iter++;
        }
        return iter;
    }

    function julia(x, y, cx, cy, maxIter) {
        let x2 = x * x, y2 = y * y, iter = 0;
        while (x2 + y2 <= 4 && iter < maxIter) {
            y = 2 * x * y + cy;
            x = x2 - y2 + cx;
            x2 = x * x;
            y2 = y * y;
            iter++;
        }
        return iter;
    }

    function burningShip(x0, y0, maxIter) {
        let x = 0, y = 0, x2 = 0, y2 = 0, iter = 0;
        while (x2 + y2 <= 4 && iter < maxIter) {
            y = Math.abs(2 * x * y) - y0;
            x = x2 - y2 + x0;
            x2 = x * x;
            y2 = y * y;
            iter++;
        }
        return iter;
    }

    function mandelbox(x, y, maxIter) {
        const SCALE = 2;
        const MINRAD2 = 0.25;
        let zx = x;
        let zy = y;
        let c = 0;
        for (let i = 0; i < maxIter; i++) {
            if (zx > 1) {
                zx = 2 - zx;
            } else if (zx < -1) {
                zx = -2 - zx;
            }
            if (zy > 1) {
                zy = 2 - zy;
            } else if (zy < -1) {
                zy = -2 - zy;
            }
            let r2 = zx * zx + zy * zy;
            if (r2 < MINRAD2) {
                const temp = SCALE / MINRAD2;
                zx = temp * zx;
                zy = temp * zy;
            } else if (r2 < 1) {
                const temp = SCALE / r2;
                zx = temp * zx;
                zy = temp * zy;
            }
            zx = SCALE * zx + x;
            zy = SCALE * zy + y;
            if (zx * zx + zy * zy > 4) {
                return i;
            }
            c++;
        }
        return c;
    }

    function getColor(i, maxIter, scheme) {
        if (i === maxIter) return [0, 0, 0];
        const t = i / maxIter;
        switch (scheme) {
            case'rainbow':
                return hsvToRgb(t, 1, 1);
            case'fire':
                return hsvToRgb(t / 3, 1, Math.min(1, t * 2));
            case'ocean':
                return hsvToRgb(0.6 + t / 3, 1, Math.min(1, t * 2));
            case'psychedelic':
                return hsvToRgb(Math.sin(t * Math.PI), 1, 1);
            default:
                return hsvToRgb(t, 1, Math.sqrt(t));
        }
    }

    function hsvToRgb(h, s, v) {
        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function zoom(factor) {
        zoomLevel *= factor;
        generateFractal();
    }

    function reset() {
        centerX = -0.5;
        centerY = 0;
        zoomLevel = 1;
        generateFractal();
    }

    function save() {
        const link = document.createElement('a');
        link.download = 'fractal.png';
        link.href = canvas.toDataURL();
        link.click();
        const thumbnail = document.createElement('img');
        thumbnail.src = link.href;
        thumbnail.classList.add('w-full', 'h-auto', 'rounded', 'shadow-md', 'hover:shadow-lg', 'transition-shadow', 'duration-300', 'cursor-pointer');
        thumbnail.addEventListener('click', () => window.open(link.href, '_blank'));
        gallery.appendChild(thumbnail);
    }

    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / canvas.width * 3 / zoomLevel + centerX - 1.5 / zoomLevel;
        const y = (e.clientY - rect.top) / canvas.height * 2 / zoomLevel + centerY - 1 / zoomLevel;
        coordinatesDiv.textContent = `(${x.toFixed(6)}, ${y.toFixed(6)})`;
        if (isDragging) {
            const dx = (e.clientX - lastX) / canvas.width * 3 / zoomLevel;
            const dy = (e.clientY - lastY) / canvas.height * 2 / zoomLevel;
            centerX -= dx;
            centerY -= dy;
            lastX = e.clientX;
            lastY = e.clientY;
            generateFractal();
        }
    });
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / canvas.width;
        const mouseY = (e.clientY - rect.top) / canvas.height;
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        centerX += (1 - zoomFactor) * (mouseX - 0.5) * 3 / zoomLevel;
        centerY += (1 - zoomFactor) * (mouseY - 0.5) * 2 / zoomLevel;
        zoomLevel *= zoomFactor;
        generateFractal();
    });
    zoomInBtn.addEventListener('click', () => zoom(1.5));
    zoomOutBtn.addEventListener('click', () => zoom(1 / 1.5));
    resetBtn.addEventListener('click', reset);
    saveBtn.addEventListener('click', save);
    [fractalType, maxIterations, colorScheme, juliaReal, juliaImag].forEach(el => el.addEventListener('input', generateFractal));
    maxIterations.addEventListener('input', () => iterationValue.textContent = maxIterations.value);
    window.addEventListener('resize', () => {
        width = Math.min(800, window.innerWidth - 40);
        height = Math.round(width * 0.75);
        canvas.width = width;
        canvas.height = height;
        generateFractal();
    });
    generateFractal();
</script>
<script src="../sidebar.js"></script>
</body>
</html>