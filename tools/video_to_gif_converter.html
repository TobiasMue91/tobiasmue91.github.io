<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video to GIF Converter</title>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéûÔ∏è</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>:root {
        --primary: #4361ee;
        --secondary: #3a0ca3;
        --success: #10b981;
        --error: #ef4444;
        --text: #1f2937;
        --light-text: #6b7280;
        --bg: #f9fafb;
        --card-bg: #fff;
        --border: #e5e7eb;
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        --radius: 8px
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.5
    }

    .container {
        max-width: 1100px;
        margin: 0 auto;
        padding: 2rem 1rem
    }

    header {
        text-align: center;
        margin-bottom: 2rem
    }

    header h1 {
        font-size: 2.5rem;
        color: var(--secondary);
        margin-bottom: .5rem
    }

    section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        transition: all .2s ease
    }

    .upload-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border: 2px dashed var(--border);
        border-radius: var(--radius);
        padding: 3rem 2rem;
        text-align: center;
        cursor: pointer;
        transition: all .2s ease
    }

    .upload-container:hover {
        border-color: var(--primary)
    }

    .upload-container i {
        font-size: 3rem;
        color: var(--primary);
        margin-bottom: 1rem
    }

    button {
        background: var(--primary);
        color: white;
        border: none;
        border-radius: var(--radius);
        padding: .75rem 1.5rem;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all .2s ease
    }

    button:hover {
        background: var(--secondary);
        transform: translateY(-2px)
    }

    .url-input {
        display: flex;
        width: 100%;
        max-width: 500px;
        margin-top: 1rem
    }

    .url-input input {
        flex: 1;
        padding: .75rem 1rem;
        border: 1px solid var(--border);
        border-radius: var(--radius) 0 0 var(--radius)
    }

    .editor-grid {
        display: grid;
        grid-template-columns:1.5fr 1fr;
        gap: 2rem
    }

    video {
        width: 100%;
        border-radius: var(--radius);
        background: #000;
        box-shadow: var(--shadow)
    }

    .time-control {
        margin-top: 1rem
    }

    .timeline {
        position: relative;
        height: 40px;
        background: var(--border);
        border-radius: 4px;
        margin-bottom: 8px
    }

    .timeline-progress {
        position: absolute;
        height: 100%;
        background: rgba(67, 97, 238, 0.3);
        border-radius: 4px;
        pointer-events: none
    }

    .time-marker {
        position: absolute;
        width: 2px;
        height: 100%;
        background: var(--primary);
        top: 0;
        z-index: 2;
        pointer-events: none
    }

    .slider-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background: var(--primary);
        border-radius: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: pointer;
        z-index: 3;
        box-shadow: 0 0 0 4px rgba(67, 97, 238, 0.2)
    }

    .time-display {
        display: flex;
        justify-content: space-between;
        color: var(--light-text);
        font-size: .9rem
    }

    .frame-preview {
        display: flex;
        overflow-x: auto;
        gap: 4px;
        margin-top: 8px;
        padding-bottom: 8px;
        max-width: 100%
    }

    .frame-preview img {
        height: 50px;
        width: auto;
        border-radius: 2px;
        box-shadow: var(--shadow)
    }

    .settings-container {
        display: flex;
        flex-direction: column;
        gap: 1.5rem
    }

    .setting {
        display: flex;
        align-items: center;
        gap: 1rem
    }

    .setting label {
        min-width: 80px;
        color: var(--light-text)
    }

    .setting input[type="range"] {
        flex: 1
    }

    .setting input[type="number"] {
        width: 80px;
        padding: .5rem;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        text-align: center
    }

    .live-preview {
        width: 100%;
        max-width: 180px;
        height: 120px;
        margin-top: 1rem;
        background: #f0f0f0;
        border-radius: var(--radius);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden
    }

    .live-preview canvas {
        max-width: 100%;
        max-height: 100%
    }

    #generateGifBtn {
        margin-top: 1rem;
        width: 100%;
        padding: 1rem;
        background: var(--success)
    }

    .gif-preview {
        display: flex;
        justify-content: center;
        margin: 1.5rem 0
    }

    .gif-preview img {
        max-width: 100%;
        max-height: 400px;
        border-radius: var(--radius)
    }

    .gif-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1.5rem;
        color: var(--light-text)
    }

    .action-buttons {
        display: flex;
        gap: 1rem
    }

    #downloadGifBtn {
        background: var(--success)
    }

    #shareGifBtn {
        background: var(--primary)
    }

    .progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000
    }

    .progress-container {
        background: var(--card-bg);
        border-radius: var(--radius);
        padding: 2rem;
        width: 90%;
        max-width: 500px;
        text-align: center
    }

    .progress-bar {
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
        margin: 1.5rem 0
    }

    .progress-fill {
        height: 100%;
        background: var(--primary);
        width: 0%;
        transition: width .3s
    }

    .tooltip {
        background: var(--card-bg);
        border-radius: 4px;
        padding: 4px 8px;
        box-shadow: var(--shadow);
        position: absolute;
        font-size: 0.8rem;
        z-index: 10;
        white-space: nowrap
    }

    .processing-options {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
        align-items: center
    }

    .keyboard-shortcuts {
        margin-top: 1rem;
        padding: 1rem;
        background: #f0f0f0;
        border-radius: var(--radius)
    }

    .shortcut {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem
    }

    .shortcut kbd {
        background: var(--card-bg);
        padding: 2px 6px;
        border-radius: 3px;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
        margin-left: 8px
    }

    .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 1rem;
        background: var(--success);
        color: white;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        transform: translateY(150%);
        animation: slideIn 0.3s forwards;
        z-index: 1000
    }

    @keyframes slideIn {
        to {
            transform: translateY(0)
        }
    }

    @keyframes slideOut {
        to {
            transform: translateY(150%)
        }
    }

    @media (max-width: 768px) {
        .editor-grid {
            grid-template-columns:1fr
        }

        .action-buttons {
            flex-direction: column
        }
    }</style>
</head>
<body>
<div class="container">
    <header>
        <h1>Video to GIF Converter</h1>
        <p>Create high-quality animated GIFs from your videos</p>
    </header>
    <main>
        <section class="upload-section">
            <div class="upload-container" id="dropArea">
                <i class="fas fa-cloud-upload-alt"></i>
                <p>Drag & drop your video file here</p>
                <button id="fileSelectBtn">Select Video</button>
                <input type="file" id="fileInput" accept="video/*" hidden>
                <p>OR</p>
                <div class="url-input">
                    <input type="text" id="videoUrl" placeholder="Enter video URL">
                    <button id="loadUrlBtn">Load</button>
                </div>
            </div>
        </section>
        <section class="editor-section" style="display:none">
            <div class="editor-grid">
                <div class="video-container">
                    <h2>Preview & Trim</h2>
                    <video id="videoPreview" controls></video>
                    <div class="time-control">
                        <div class="timeline" id="timeline">
                            <div class="timeline-progress" id="timelineProgress"></div>
                            <div class="time-marker" id="currentTimeMarker"></div>
                            <div class="slider-handle" id="startHandle" data-type="start"></div>
                            <div class="slider-handle" id="endHandle" data-type="end"></div>
                        </div>
                        <div class="time-display">
                            <span id="startTimeDisplay">00:00</span>
                            <span id="currentTimeDisplay">00:00</span>
                            <span id="endTimeDisplay">00:00</span>
                        </div>
                        <div class="frame-preview" id="framePreview"></div>
                    </div>
                </div>
                <div class="settings-container">
                    <h2>GIF Settings</h2>
                    <div class="setting">
                        <label for="qualityRange">Quality</label>
                        <input type="range" id="qualityRange" min="1" max="20" value="10">
                        <span id="qualityValue">10</span>
                    </div>
                    <div class="setting">
                        <label for="fpsRange">FPS</label>
                        <input type="range" id="fpsRange" min="5" max="30" value="10">
                        <span id="fpsValue">10</span>
                    </div>
                    <div class="setting">
                        <label for="speedRange">Speed</label>
                        <input type="range" id="speedRange" min="0.25" max="2" value="1" step="0.25">
                        <span id="speedValue">1x</span>
                    </div>
                    <div class="setting">
                        <label for="widthInput">Width</label>
                        <input type="number" id="widthInput" min="50" max="800" value="320">
                        <span>px</span>
                    </div>
                    <div class="setting">
                        <label for="heightInput">Height</label>
                        <input type="number" id="heightInput" min="50" max="800" value="240">
                        <span>px</span>
                    </div>
                    <div class="setting">
                        <input type="checkbox" id="maintainRatio" checked>
                        <label for="maintainRatio">Maintain aspect ratio</label>
                    </div>
                    <div class="setting">
                        <input type="checkbox" id="ditheringCheckbox" checked>
                        <label for="ditheringCheckbox">Dithering (better gradients)</label>
                    </div>
                    <div class="live-preview">
                        <canvas id="previewCanvas"></canvas>
                    </div>
                    <button id="generateGifBtn">Generate GIF</button>
                    <div class="keyboard-shortcuts">
                        <p><small>Keyboard Shortcuts:</small></p>
                        <div class="shortcut"><span>Play/Pause</span><kbd>Space</kbd></div>
                        <div class="shortcut"><span>Frame Forward</span><kbd>‚Üí</kbd></div>
                        <div class="shortcut"><span>Frame Back</span><kbd>‚Üê</kbd></div>
                    </div>
                </div>
            </div>
        </section>
        <section class="result-section" style="display:none">
            <h2>Your GIF</h2>
            <div class="gif-preview">
                <img id="gifPreview" alt="Generated GIF">
            </div>
            <div class="gif-info">
                <span id="gifSize">0 KB</span>
                <span id="gifDimensions">0 x 0</span>
            </div>
            <div class="action-buttons">
                <button id="downloadGifBtn"><i class="fas fa-download"></i> Download</button>
                <button id="shareGifBtn"><i class="fas fa-share-alt"></i> Share</button>
                <button id="editAgainBtn"><i class="fas fa-edit"></i> Edit Again</button>
                <button id="newConversionBtn"><i class="fas fa-redo"></i> New Conversion</button>
            </div>
        </section>
        <div class="progress-overlay" style="display:none">
            <div class="progress-container">
                <h3 id="progressTitle">Processing...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">0%</p>
            </div>
        </div>
    </main>
</div>
<script>
    let gifWorkerBlob = null;
    fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js').then(r => r.blob()).then(b => {
        gifWorkerBlob = b
    }).catch(e => console.error('Failed to load GIF worker:', e));
    document.addEventListener('DOMContentLoaded', () => {
        const fileInput = document.getElementById('fileInput');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const dropArea = document.getElementById('dropArea');
        const videoUrl = document.getElementById('videoUrl');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const videoPreview = document.getElementById('videoPreview');
        const uploadSection = document.querySelector('.upload-section');
        const editorSection = document.querySelector('.editor-section');
        const resultSection = document.querySelector('.result-section');
        const progressOverlay = document.querySelector('.progress-overlay');
        const progressTitle = document.getElementById('progressTitle');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const qualityRange = document.getElementById('qualityRange');
        const qualityValue = document.getElementById('qualityValue');
        const fpsRange = document.getElementById('fpsRange');
        const fpsValue = document.getElementById('fpsValue');
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const maintainRatio = document.getElementById('maintainRatio');
        const ditheringCheckbox = document.getElementById('ditheringCheckbox');
        const generateGifBtn = document.getElementById('generateGifBtn');
        const gifPreview = document.getElementById('gifPreview');
        const gifSize = document.getElementById('gifSize');
        const gifDimensions = document.getElementById('gifDimensions');
        const downloadGifBtn = document.getElementById('downloadGifBtn');
        const shareGifBtn = document.getElementById('shareGifBtn');
        const editAgainBtn = document.getElementById('editAgainBtn');
        const newConversionBtn = document.getElementById('newConversionBtn');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const timeline = document.getElementById('timeline');
        const timelineProgress = document.getElementById('timelineProgress');
        const currentTimeMarker = document.getElementById('currentTimeMarker');
        const startHandle = document.getElementById('startHandle');
        const endHandle = document.getElementById('endHandle');
        const startTimeDisplay = document.getElementById('startTimeDisplay');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');
        const endTimeDisplay = document.getElementById('endTimeDisplay');
        const framePreview = document.getElementById('framePreview');
        let videoFile = null;
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 0;
        let gifBlob = null;
        let startTime = 0;
        let endTime = 1;
        let isDragging = false;
        let activeHandle = null;
        let frameCaptures = [];
        let previewFrameTimer = null;

        async function generateGif() {
            if (!videoPreview.src) {
                createToast('Please load a video first', 'error');
                return
            }
            if (!gifWorkerBlob) {
                createToast('GIF encoder still loading, please wait...', 'error');
                return
            }
            const width = parseInt(widthInput.value);
            const height = parseInt(heightInput.value);
            const fps = parseInt(fpsRange.value);
            const speed = parseFloat(speedRange.value);
            const quality = parseInt(qualityRange.value);
            const dithering = ditheringCheckbox.checked;
            const duration = endTime - startTime;
            if (duration <= 0) {
                createToast('Invalid time range selected', 'error');
                return
            }
            progressOverlay.style.display = 'flex';
            progressFill.style.width = '0%';
            progressText.textContent = 'Preparing...';
            progressTitle.textContent = 'Creating GIF';
            try {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const framesNeeded = Math.ceil(duration * fps / speed);
                const frameDelay = 1000 / (fps * speed);
                const gif = new GIF({
                    workers: 2,
                    quality: quality,
                    width: width,
                    height: height,
                    workerScript: URL.createObjectURL(gifWorkerBlob),
                    dither: dithering ? 'FloydSteinberg' : false
                });
                gif.on('progress', p => {
                    const percent = 50 + (p * 50);
                    progressFill.style.width = `${Math.round(percent)}%`;
                    progressText.textContent = `Encoding: ${Math.round(p * 100)}%`
                });
                gif.on('finished', blob => {
                    gifBlob = blob;
                    const url = URL.createObjectURL(blob);
                    gifPreview.src = url;
                    gifSize.textContent = `${(blob.size / 1024).toFixed(2)} KB`;
                    gifDimensions.textContent = `${width} x ${height}`;
                    progressOverlay.style.display = 'none';
                    editorSection.style.display = 'none';
                    resultSection.style.display = 'block';
                    createToast('GIF created successfully!')
                });
                videoPreview.currentTime = startTime;
                await new Promise(resolve => {
                    videoPreview.onseeked = resolve
                });
                progressText.textContent = 'Extracting frames...';
                for (let i = 0; i < framesNeeded; i++) {
                    ctx.drawImage(videoPreview, 0, 0, width, height);
                    gif.addFrame(canvas, {delay: frameDelay, copy: true});
                    const progress = (i + 1) / framesNeeded;
                    progressFill.style.width = `${Math.round(progress * 50)}%`;
                    progressText.textContent = `Frame ${i + 1}/${framesNeeded}`;
                    videoPreview.currentTime = startTime + ((i + 1) * speed / fps);
                    await new Promise(resolve => {
                        videoPreview.onseeked = resolve
                    })
                }
                progressText.textContent = 'Encoding GIF...';
                gif.render()
            } catch (error) {
                console.error('Error generating GIF:', error);
                progressTitle.textContent = 'Error Occurred';
                progressText.textContent = 'Failed to create GIF. Try different settings.';
                setTimeout(() => progressOverlay.style.display = 'none', 2000)
            }
        }

        const throttle = (func, limit) => {
            let inThrottle;
            return function (...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit)
                }
            }
        };

        function createToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s forwards';
                setTimeout(() => document.body.removeChild(toast), 300)
            }, 3000)
        }

        function createTooltip(element, text) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = text;
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);
            element.addEventListener('mouseenter', () => {
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + (rect.width / 2) - tooltip.offsetWidth / 2}px`;
                tooltip.style.top = `${rect.top - tooltip.offsetHeight - 5}px`;
                tooltip.style.display = 'block'
            });
            element.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none'
            })
        }

        fileSelectBtn.addEventListener('click', () => {
            fileInput.click()
        });
        fileInput.addEventListener('change', handleFileSelect);
        dropArea.addEventListener('dragover', e => {
            e.preventDefault();
            dropArea.classList.add('active')
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('active')
        });
        dropArea.addEventListener('drop', e => {
            e.preventDefault();
            dropArea.classList.remove('active');
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect(e)
            }
        });
        loadUrlBtn.addEventListener('click', handleUrlLoad);
        videoPreview.addEventListener('loadedmetadata', () => {
            originalWidth = videoPreview.videoWidth;
            originalHeight = videoPreview.videoHeight;
            aspectRatio = originalWidth / originalHeight;
            widthInput.value = Math.min(originalWidth, 320);
            heightInput.value = Math.round(widthInput.value / aspectRatio);
            endTime = videoPreview.duration;
            updateHandlePositions();
            updateTimeDisplay();
            setupFramePreviews()
        });
        videoPreview.addEventListener('timeupdate', () => {
            const progress = videoPreview.currentTime / videoPreview.duration * 100;
            currentTimeMarker.style.left = `${progress}%`;
            currentTimeDisplay.textContent = formatTime(videoPreview.currentTime);
            updatePreviewCanvas()
        });
        document.addEventListener('keydown', e => {
            if (!videoPreview.src || editorSection.style.display === 'none') return;
            if (e.code === 'Space') {
                if (videoPreview.paused) videoPreview.play(); else videoPreview.pause();
                e.preventDefault()
            } else if (e.code === 'ArrowRight') {
                videoPreview.currentTime = Math.min(videoPreview.currentTime + 0.04, videoPreview.duration);
                e.preventDefault()
            } else if (e.code === 'ArrowLeft') {
                videoPreview.currentTime = Math.max(videoPreview.currentTime - 0.04, 0);
                e.preventDefault()
            }
        });
        timeline.addEventListener('mousedown', e => {
            const rect = timeline.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickPercent = clickX / rect.width;
            const clickTime = videoPreview.duration * clickPercent;
            const handleTarget = e.target;
            if (handleTarget === startHandle || handleTarget === endHandle) {
                isDragging = true;
                activeHandle = handleTarget
            } else {
                videoPreview.currentTime = clickTime
            }
        });
        document.addEventListener('mousemove', throttle((e) => {
            if (!isDragging || !activeHandle) return;
            const rect = timeline.getBoundingClientRect();
            let moveX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            let movePercent = moveX / rect.width;
            let moveTime = videoPreview.duration * movePercent;
            if (activeHandle === startHandle) {
                startTime = Math.min(moveTime, endTime - 0.1);
                videoPreview.currentTime = startTime
            } else if (activeHandle === endHandle) {
                endTime = Math.max(moveTime, startTime + 0.1);
                videoPreview.currentTime = endTime
            }
            updateHandlePositions();
            updateTimeDisplay()
        }, 16));
        document.addEventListener('mouseup', () => {
            isDragging = false;
            activeHandle = null
        });
        qualityRange.addEventListener('input', () => {
            qualityValue.textContent = qualityRange.value;
            updatePreviewCanvas()
        });
        fpsRange.addEventListener('input', () => {
            fpsValue.textContent = fpsRange.value;
            updatePreviewCanvas()
        });
        speedRange.addEventListener('input', () => {
            speedValue.textContent = `${speedRange.value}x`;
            updatePreviewCanvas()
        });
        widthInput.addEventListener('input', () => {
            if (maintainRatio.checked && originalWidth > 0) {
                heightInput.value = Math.round(widthInput.value / aspectRatio)
            }
            updatePreviewCanvas()
        });
        heightInput.addEventListener('input', () => {
            if (maintainRatio.checked && originalHeight > 0) {
                widthInput.value = Math.round(heightInput.value * aspectRatio)
            }
            updatePreviewCanvas()
        });
        ditheringCheckbox.addEventListener('change', updatePreviewCanvas);
        generateGifBtn.addEventListener('click', generateGif);
        downloadGifBtn.addEventListener('click', () => {
            if (gifBlob) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(gifBlob);
                a.download = `video-${new Date().getTime()}.gif`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                createToast('GIF downloaded successfully!')
            }
        });
        shareGifBtn.addEventListener('click', async () => {
            if (gifBlob && navigator.share) {
                try {
                    const file = new File([gifBlob], `video-${new Date().getTime()}.gif`, {type: 'image/gif'});
                    await navigator.share({
                        files: [file],
                        title: 'Check out my GIF',
                        text: 'Created with Video to GIF Converter'
                    });
                    createToast('GIF shared successfully!')
                } catch (error) {
                    console.error('Error sharing:', error);
                    createToast('Failed to share', 'error')
                }
            } else {
                createToast('Sharing not supported', 'error')
            }
        });
        editAgainBtn.addEventListener('click', () => {
            uploadSection.style.display = 'none';
            editorSection.style.display = 'block';
            resultSection.style.display = 'none'
        });
        newConversionBtn.addEventListener('click', () => {
            uploadSection.style.display = 'block';
            editorSection.style.display = 'none';
            resultSection.style.display = 'none';
            videoFile = null;
            videoPreview.src = '';
            gifPreview.src = '';
            videoUrl.value = '';
            gifBlob = null;
            framePreview.innerHTML = '';
            frameCaptures = []
        });
        createTooltip(qualityRange.parentElement, 'Higher quality = better colors but larger file size');
        createTooltip(fpsRange.parentElement, 'Frames per second: higher = smoother animation but larger file');
        createTooltip(speedRange.parentElement, 'Playback speed of the resulting animation');
        createTooltip(ditheringCheckbox.parentElement, 'Improves color gradients');

        function handleFileSelect(e) {
            const file = e.target.files[0] || e.dataTransfer?.files[0];
            if (file && file.type.startsWith('video/')) {
                videoFile = file;
                loadVideo(URL.createObjectURL(file))
            } else {
                createToast('Please select a valid video file', 'error')
            }
        }

        function handleUrlLoad() {
            const url = videoUrl.value.trim();
            if (url) {
                if (!/^https?:\/\/.+/i.test(url)) {
                    createToast('Please enter a valid URL', 'error');
                    return
                }
                loadVideo(url);
                videoFile = null
            } else {
                createToast('Please enter a video URL', 'error')
            }
        }

        function loadVideo(src) {
            videoPreview.src = src;
            videoPreview.load();
            videoPreview.onloadeddata = () => {
                uploadSection.style.display = 'none';
                editorSection.style.display = 'block';
                setupInitialSettings()
            };
            videoPreview.onerror = () => {
                createToast('Failed to load video', 'error');
                videoUrl.value = ''
            }
        }

        function setupInitialSettings() {
            previewCanvas.width = 160;
            previewCanvas.height = 120;
            endTime = videoPreview.duration;
            updateHandlePositions();
            updateTimeDisplay();
            setTimeout(updatePreviewCanvas, 300)
        }

        function setupFramePreviews() {
            const duration = videoPreview.duration;
            framePreview.innerHTML = '';
            frameCaptures = [];
            if (duration <= 0) return;
            const captureCount = Math.min(12, Math.max(6, Math.floor(duration)));
            const captureInterval = duration / captureCount;
            const capturePromises = [];
            for (let i = 0; i < captureCount; i++) {
                const time = i * captureInterval;
                capturePromises.push(captureVideoFrame(time))
            }
            Promise.all(capturePromises).then(frames => {
                frames.forEach((frame, index) => {
                    const time = index * captureInterval;
                    const img = document.createElement('img');
                    img.src = frame.url;
                    img.dataset.time = time;
                    img.addEventListener('click', () => {
                        videoPreview.currentTime = time
                    });
                    framePreview.appendChild(img);
                    frameCaptures.push(frame)
                })
            })
        }

        async function captureVideoFrame(time) {
            return new Promise(resolve => {
                videoPreview.currentTime = time;
                videoPreview.onseeked = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 160;
                    canvas.height = 90;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);
                    const url = canvas.toDataURL('image/jpeg', 0.7);
                    resolve({time, url})
                }
            })
        }

        function updateHandlePositions() {
            const startPercent = (startTime / videoPreview.duration) * 100;
            const endPercent = (endTime / videoPreview.duration) * 100;
            startHandle.style.left = `${startPercent}%`;
            endHandle.style.left = `${endPercent}%`;
            timelineProgress.style.left = `${startPercent}%`;
            timelineProgress.style.width = `${endPercent - startPercent}%`
        }

        function updateTimeDisplay() {
            startTimeDisplay.textContent = formatTime(startTime);
            endTimeDisplay.textContent = formatTime(endTime);
            currentTimeDisplay.textContent = formatTime(videoPreview.currentTime)
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms}`
        }

        function updatePreviewCanvas() {
            if (!videoPreview.readyState >= 2) return;
            clearTimeout(previewFrameTimer);
            previewFrameTimer = setTimeout(() => {
                const width = parseInt(widthInput.value);
                const height = parseInt(heightInput.value);
                if (width <= 0 || height <= 0) return;
                const ctx = previewCanvas.getContext('2d');
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                const scaleFactor = Math.min(previewCanvas.width / width, previewCanvas.height / height);
                const displayWidth = width * scaleFactor;
                const displayHeight = height * scaleFactor;
                const offsetX = (previewCanvas.width - displayWidth) / 2;
                const offsetY = (previewCanvas.height - displayHeight) / 2;
                ctx.drawImage(videoPreview, offsetX, offsetY, displayWidth, displayHeight)
            }, 100)
        }
    });
</script>
<script src="../logo.js"></script>
</body>
</html>