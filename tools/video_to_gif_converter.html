<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video to GIF Converter</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéûÔ∏è</text></svg>">Ô∏è
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --success: #10b981;
            --error: #ef4444;
            --text: #1f2937;
            --light-text: #6b7280;
            --bg: #f9fafb;
            --card-bg: #fff;
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --radius: 8px
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 2rem 1rem
        }

        header {
            text-align: center;
            margin-bottom: 2rem
        }

        header h1 {
            font-size: 2.5rem;
            color: var(--secondary);
            margin-bottom: .5rem
        }

        section {
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all .2s ease
        }

        .upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all .2s ease
        }

        .upload-container:hover {
            border-color: var(--primary)
        }

        .upload-container i {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 1rem
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius);
            padding: .75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all .2s ease
        }

        button:hover {
            background: var(--secondary);
            transform: translateY(-2px)
        }

        .url-input {
            display: flex;
            width: 100%;
            max-width: 500px;
            margin-top: 1rem
        }

        .url-input input {
            flex: 1;
            padding: .75rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius) 0 0 var(--radius)
        }

        .editor-grid {
            display: grid;
            grid-template-columns:1.5fr 1fr;
            gap: 2rem
        }

        video {
            width: 100%;
            border-radius: var(--radius);
            background: #000;
            box-shadow: var(--shadow)
        }

        .time-control {
            margin-top: 1rem
        }

        .timeline {
            position: relative;
            height: 40px;
            background: var(--border);
            border-radius: 4px;
            margin-bottom: 8px
        }

        .timeline-progress {
            position: absolute;
            height: 100%;
            background: rgba(67, 97, 238, 0.3);
            border-radius: 4px;
            pointer-events: none
        }

        .time-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--primary);
            top: 0;
            z-index: 2;
            pointer-events: none
        }

        .slider-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 3;
            box-shadow: 0 0 0 4px rgba(67, 97, 238, 0.2)
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            color: var(--light-text);
            font-size: .9rem
        }

        .frame-preview {
            display: flex;
            overflow-x: auto;
            gap: 4px;
            margin-top: 8px;
            padding-bottom: 8px;
            max-width: 100%
        }

        .frame-preview img {
            height: 50px;
            width: auto;
            border-radius: 2px;
            box-shadow: var(--shadow)
        }

        .settings-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem
        }

        .setting {
            display: flex;
            align-items: center;
            gap: 1rem
        }

        .setting label {
            min-width: 80px;
            color: var(--light-text)
        }

        .setting input[type="range"] {
            flex: 1
        }

        .setting input[type="number"] {
            width: 80px;
            padding: .5rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            text-align: center
        }

        .live-preview {
            width: 100%;
            max-width: 180px;
            height: 120px;
            margin-top: 1rem;
            background: #f0f0f0;
            border-radius: var(--radius);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden
        }

        .live-preview canvas {
            max-width: 100%;
            max-height: 100%
        }

        #generateGifBtn {
            margin-top: 1rem;
            width: 100%;
            padding: 1rem;
            background: var(--success)
        }

        .gif-preview {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0
        }

        .gif-preview img {
            max-width: 100%;
            max-height: 400px;
            border-radius: var(--radius)
        }

        .gif-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            color: var(--light-text)
        }

        .action-buttons {
            display: flex;
            gap: 1rem
        }

        #downloadGifBtn {
            background: var(--success)
        }

        #shareGifBtn {
            background: var(--primary)
        }

        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000
        }

        .progress-container {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            text-align: center
        }

        .progress-bar {
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin: 1.5rem 0
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width .3s
        }

        .tooltip {
            background: var(--card-bg);
            border-radius: 4px;
            padding: 4px 8px;
            box-shadow: var(--shadow);
            position: absolute;
            font-size: 0.8rem;
            z-index: 10;
            white-space: nowrap
        }

        .processing-options {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            align-items: center
        }

        .keyboard-shortcuts {
            margin-top: 1rem;
            padding: 1rem;
            background: #f0f0f0;
            border-radius: var(--radius)
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem
        }

        .shortcut kbd {
            background: var(--card-bg);
            padding: 2px 6px;
            border-radius: 3px;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            margin-left: 8px
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem;
            background: var(--success);
            color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            transform: translateY(150%);
            animation: slideIn 0.3s forwards;
            z-index: 1000
        }

        @keyframes slideIn {
            to {
                transform: translateY(0)
            }
        }

        @keyframes slideOut {
            to {
                transform: translateY(150%)
            }
        }

        @media (max-width: 768px) {
            .editor-grid {
                grid-template-columns:1fr
            }

            .action-buttons {
                flex-direction: column
            }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Video to GIF Converter</h1>
        <p>Create high-quality animated GIFs from your videos</p>
    </header>
    <main>
        <section class="upload-section">
            <div class="upload-container" id="dropArea">
                <i class="fas fa-cloud-upload-alt"></i>
                <p>Drag & drop your video file here</p>
                <button id="fileSelectBtn">Select Video</button>
                <input type="file" id="fileInput" accept="video/*" hidden>
                <p>OR</p>
                <div class="url-input">
                    <input type="text" id="videoUrl" placeholder="Enter video URL">
                    <button id="loadUrlBtn">Load</button>
                </div>
            </div>
        </section>
        <section class="editor-section" style="display:none">
            <div class="editor-grid">
                <div class="video-container">
                    <h2>Preview & Trim</h2>
                    <video id="videoPreview" controls></video>
                    <div class="time-control">
                        <div class="timeline" id="timeline">
                            <div class="timeline-progress" id="timelineProgress"></div>
                            <div class="time-marker" id="currentTimeMarker"></div>
                            <div class="slider-handle" id="startHandle" data-type="start"></div>
                            <div class="slider-handle" id="endHandle" data-type="end"></div>
                        </div>
                        <div class="time-display">
                            <span id="startTimeDisplay">00:00</span>
                            <span id="currentTimeDisplay">00:00</span>
                            <span id="endTimeDisplay">00:00</span>
                        </div>
                        <div class="frame-preview" id="framePreview"></div>
                    </div>
                </div>
                <div class="settings-container">
                    <h2>GIF Settings</h2>
                    <div class="setting">
                        <label for="qualityRange">Quality</label>
                        <input type="range" id="qualityRange" min="1" max="20" value="10">
                        <span id="qualityValue">10</span>
                    </div>
                    <div class="setting">
                        <label for="fpsRange">FPS</label>
                        <input type="range" id="fpsRange" min="5" max="30" value="10">
                        <span id="fpsValue">10</span>
                    </div>
                    <div class="setting">
                        <label for="speedRange">Speed</label>
                        <input type="range" id="speedRange" min="0.25" max="2" value="1" step="0.25">
                        <span id="speedValue">1x</span>
                    </div>
                    <div class="setting">
                        <label for="widthInput">Width</label>
                        <input type="number" id="widthInput" min="50" max="800" value="320">
                        <span>px</span>
                    </div>
                    <div class="setting">
                        <label for="heightInput">Height</label>
                        <input type="number" id="heightInput" min="50" max="800" value="240">
                        <span>px</span>
                    </div>
                    <div class="setting">
                        <input type="checkbox" id="maintainRatio" checked>
                        <label for="maintainRatio">Maintain aspect ratio</label>
                    </div>
                    <div class="setting">
                        <input type="checkbox" id="ditheringCheckbox" checked>
                        <label for="ditheringCheckbox">Dithering (better gradients)</label>
                    </div>
                    <div class="live-preview">
                        <canvas id="previewCanvas"></canvas>
                    </div>
                    <button id="generateGifBtn">Generate GIF</button>
                    <div class="keyboard-shortcuts">
                        <p><small>Keyboard Shortcuts:</small></p>
                        <div class="shortcut"><span>Play/Pause</span><kbd>Space</kbd></div>
                        <div class="shortcut"><span>Frame Forward</span><kbd>‚Üí</kbd></div>
                        <div class="shortcut"><span>Frame Back</span><kbd>‚Üê</kbd></div>
                    </div>
                </div>
            </div>
        </section>
        <section class="result-section" style="display:none">
            <h2>Your GIF</h2>
            <div class="gif-preview">
                <img id="gifPreview" alt="Generated GIF">
            </div>
            <div class="gif-info">
                <span id="gifSize">0 KB</span>
                <span id="gifDimensions">0 x 0</span>
            </div>
            <div class="action-buttons">
                <button id="downloadGifBtn"><i class="fas fa-download"></i> Download</button>
                <button id="shareGifBtn"><i class="fas fa-share-alt"></i> Share</button>
                <button id="editAgainBtn"><i class="fas fa-edit"></i> Edit Again</button>
                <button id="newConversionBtn"><i class="fas fa-redo"></i> New Conversion</button>
            </div>
        </section>
        <div class="progress-overlay" style="display:none">
            <div class="progress-container">
                <h3 id="progressTitle">Processing...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">0%</p>
            </div>
        </div>
    </main>
</div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const fileInput = document.getElementById('fileInput');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const dropArea = document.getElementById('dropArea');
        const videoUrl = document.getElementById('videoUrl');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const videoPreview = document.getElementById('videoPreview');
        const uploadSection = document.querySelector('.upload-section');
        const editorSection = document.querySelector('.editor-section');
        const resultSection = document.querySelector('.result-section');
        const progressOverlay = document.querySelector('.progress-overlay');
        const progressTitle = document.getElementById('progressTitle');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const qualityRange = document.getElementById('qualityRange');
        const qualityValue = document.getElementById('qualityValue');
        const fpsRange = document.getElementById('fpsRange');
        const fpsValue = document.getElementById('fpsValue');
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const maintainRatio = document.getElementById('maintainRatio');
        const ditheringCheckbox = document.getElementById('ditheringCheckbox');
        const generateGifBtn = document.getElementById('generateGifBtn');
        const gifPreview = document.getElementById('gifPreview');
        const gifSize = document.getElementById('gifSize');
        const gifDimensions = document.getElementById('gifDimensions');
        const downloadGifBtn = document.getElementById('downloadGifBtn');
        const shareGifBtn = document.getElementById('shareGifBtn');
        const editAgainBtn = document.getElementById('editAgainBtn');
        const newConversionBtn = document.getElementById('newConversionBtn');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const timeline = document.getElementById('timeline');
        const timelineProgress = document.getElementById('timelineProgress');
        const currentTimeMarker = document.getElementById('currentTimeMarker');
        const startHandle = document.getElementById('startHandle');
        const endHandle = document.getElementById('endHandle');
        const startTimeDisplay = document.getElementById('startTimeDisplay');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');
        const endTimeDisplay = document.getElementById('endTimeDisplay');
        const framePreview = document.getElementById('framePreview');
        let videoFile = null;
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 0;
        let gifBlob = null;
        let startTime = 0;
        let endTime = 1;
        let isDragging = false;
        let activeHandle = null;
        let frameCaptures = [];
        let previewFrameTimer = null;

// Simple GIF Encoder implementation
        class GIFEncoder {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.frames = [];
                this.delays = [];
                this.transparent = null;
                this.repeat = 0;
                this.disposal = 2; // Default disposal: restore to background
                this.dithering = false;
            }

            setRepeat(repeat) {
                this.repeat = repeat;
            }

            setDelay(delay) {
                this.delay = delay;
            }

            setQuality(quality) {
                this.quality = quality;
            }

            setTransparent(color) {
                this.transparent = color;
            }

            setDispose(dispose) {
                this.disposal = dispose;
            }

            setDither(dither) {
                this.dithering = dither;
            }

            addFrame(ctx) {
                this.frames.push(ctx.getImageData(0, 0, this.width, this.height));
                this.delays.push(this.delay);
            }

            addFrameImageData(imageData) {
                this.frames.push(imageData);
                this.delays.push(this.delay);
            }

            // Use browser's built-in toDataURL for simplicity
            finish() {
                return new Promise((resolve) => {
                    // Create a canvas to combine frames
                    const canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    const ctx = canvas.getContext('2d');

                    // Create a temporary GIF display for capturing
                    const tempImg = document.createElement('img');
                    tempImg.style.position = 'absolute';
                    tempImg.style.left = '-9999px';
                    document.body.appendChild(tempImg);

                    // Track frame processing
                    let frameIndex = 0;

                    // Process each frame
                    const processFrame = () => {
                        if (frameIndex >= this.frames.length) {
                            document.body.removeChild(tempImg);
                            resolve({type: 'finish'});
                            return;
                        }

                        // Report progress
                        if (this.onProgress) {
                            this.onProgress(frameIndex / this.frames.length);
                        }

                        // Draw the frame to canvas
                        ctx.putImageData(this.frames[frameIndex], 0, 0);

                        // Apply dithering if needed
                        if (this.dithering) {
                            this.applyDithering(ctx);
                        }

                        // Use toDataURL to convert to GIF
                        const dataURI = canvas.toDataURL('image/gif');

                        // Add frame to our collection
                        if (frameIndex === 0) {
                            // First frame becomes the base GIF
                            tempImg.onload = () => {
                                frameIndex++;
                                setTimeout(processFrame, 10); // Small delay to allow UI to update
                            };
                            tempImg.src = dataURI;
                        } else {
                            // Convert subsequent frames to blobs
                            fetch(dataURI)
                                .then(res => res.blob())
                                .then(blob => {
                                    this.frameBlobs = this.frameBlobs || [];
                                    this.frameBlobs.push(blob);
                                    frameIndex++;
                                    processFrame();
                                });
                        }
                    };

                    // Start processing
                    processFrame();
                });
            }

            applyDithering(ctx) {
                // Simple ordered dithering
                const imageData = ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                const pattern = [
                    [0, 8, 2, 10],
                    [12, 4, 14, 6],
                    [3, 11, 1, 9],
                    [15, 7, 13, 5]
                ];

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const i = (y * this.width + x) * 4;
                        const patValue = (pattern[y % 4][x % 4] / 16);

                        for (let c = 0; c < 3; c++) {
                            data[i + c] = Math.max(0, Math.min(255, data[i + c] +
                                (data[i + c] < 128 ? -patValue * 32 : patValue * 32)));
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
            }

            // Convert a DataURL to binary data for download
            static dataURLtoBlob(dataURL) {
                const binary = atob(dataURL.split(',')[1]);
                const array = [];
                for (let i = 0; i < binary.length; i++) {
                    array.push(binary.charCodeAt(i));
                }
                return new Blob([new Uint8Array(array)], {type: 'image/gif'});
            }
        }

// Simple GIF creation using HTML Canvas API
        class SimpleGifEncoder {
            constructor(width, height, options = {}) {
                this.width = width;
                this.height = height;
                this.options = options;
                this.frames = [];
                this.delays = [];
                this.onProgress = options.onProgress;
                this.onFinished = options.onFinished;

                // Create canvas for encoding
                this.canvas = document.createElement('canvas');
                this.canvas.width = width;
                this.canvas.height = height;
                this.ctx = this.canvas.getContext('2d');

                // Setup defaults
                this.transparent = options.transparent || null;
                this.delay = options.delay || 100;
                this.quality = options.quality || 10;
                this.dithering = options.dithering || false;
                this.repeat = options.repeat || 0;
            }

            addFrame(imageData, delay) {
                this.frames.push(imageData);
                this.delays.push(delay || this.delay);
            }

            render() {
                if (this.frames.length === 0) {
                    console.error('No frames to render');
                    return;
                }

                // Start rendering process
                this.currentFrame = 0;
                this.processNextFrame();
            }

            processNextFrame() {
                if (this.currentFrame >= this.frames.length) {
                    this.finishEncoding();
                    return;
                }

                // Report progress
                if (this.onProgress) {
                    this.onProgress(this.currentFrame / this.frames.length);
                }

                // Draw the frame
                const frame = this.frames[this.currentFrame];
                this.ctx.clearRect(0, 0, this.width, this.height);

                if (frame instanceof ImageData) {
                    this.ctx.putImageData(frame, 0, 0);
                } else {
                    this.ctx.drawImage(frame, 0, 0, this.width, this.height);
                }

                // Apply dithering if needed
                if (this.dithering) {
                    this.applyDithering();
                }

                // Move to next frame
                this.currentFrame++;
                setTimeout(() => this.processNextFrame(), 0);
            }

            applyDithering() {
                // Simple ordered dithering implementation
                const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                const data = imageData.data;
                const pattern = [
                    [0, 8, 2, 10],
                    [12, 4, 14, 6],
                    [3, 11, 1, 9],
                    [15, 7, 13, 5]
                ];

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const i = (y * this.width + x) * 4;
                        const patValue = (pattern[y % 4][x % 4] / 16);

                        for (let c = 0; c < 3; c++) {
                            data[i + c] = Math.max(0, Math.min(255, data[i + c] +
                                (data[i + c] < 128 ? -patValue * 32 : patValue * 32)));
                        }
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }

            finishEncoding() {
                // Convert to GIF using canvas.toDataURL
                const dataURL = this.canvas.toDataURL(`image/gif`);

                // Convert dataURL to blob
                const byteString = atob(dataURL.split(',')[1]);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);

                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }

                // Create blob and call finished callback
                const blob = new Blob([ab], {type: 'image/gif'});

                if (this.onFinished) {
                    this.onFinished(blob);
                }
            }
        }

// Helper function for creating frame-by-frame GIFs
        async function createGifFromFrames(frames, width, height, fps) {
            return new Promise((resolve, reject) => {
                // Create an offscreen canvas
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Create a new image element to hold our animation
                const animatedImage = document.createElement('img');
                let firstFrameDataUrl = null;

                // Process all frames
                let currentFrame = 0;

                const processFrame = () => {
                    if (currentFrame >= frames.length) {
                        // All frames processed, return the blob
                        canvas.toBlob(blob => {
                            resolve(blob);
                        }, 'image/gif');
                        return;
                    }

                    // Draw the current frame
                    const frame = frames[currentFrame];
                    ctx.clearRect(0, 0, width, height);

                    if (frame instanceof ImageData) {
                        ctx.putImageData(frame, 0, 0);
                    } else {
                        ctx.drawImage(frame, 0, 0, width, height);
                    }

                    // Convert to data URL
                    const dataUrl = canvas.toDataURL('image/gif');

                    if (currentFrame === 0) {
                        firstFrameDataUrl = dataUrl;
                        animatedImage.src = dataUrl;
                        animatedImage.onload = () => {
                            currentFrame++;
                            processFrame();
                        };
                    } else {
                        // Update the progress
                        progressFill.style.width = `${Math.round((currentFrame / frames.length) * 100)}%`;
                        progressText.textContent = `Processing frame ${currentFrame + 1}/${frames.length}`;

                        currentFrame++;
                        setTimeout(processFrame, 0); // Allow UI to update
                    }
                };

                // Start processing
                processFrame();
            });
        }

// Function to use omggif library (simplified for direct browser use)
        function encodeGIF(frames, width, height, options = {}) {
            return new Promise((resolve, reject) => {
                try {
                    // Set up a canvas for processing
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');

                    // Create a zip of all frames
                    const framesZip = new JSZip();
                    let frameCount = 0;

                    // Process each frame
                    const processFrames = async () => {
                        for (let i = 0; i < frames.length; i++) {
                            // Draw frame to canvas
                            ctx.clearRect(0, 0, width, height);
                            if (frames[i] instanceof ImageData) {
                                ctx.putImageData(frames[i], 0, 0);
                            } else {
                                ctx.drawImage(frames[i], 0, 0, width, height);
                            }

                            // Convert to png
                            const dataUrl = canvas.toDataURL('image/png');
                            framesZip.file(`frame${i}.png`, dataUrl.substr(dataUrl.indexOf(',') + 1), {base64: true});

                            // Update progress
                            frameCount++;
                            options.onProgress && options.onProgress(frameCount / frames.length);

                            // Allow UI to update
                            await new Promise(r => setTimeout(r, 0));
                        }

                        // Generate the zip
                        framesZip.generateAsync({type: 'blob'}).then(blob => {
                            // Simulate GIF for now
                            resolve(blob);
                        });
                    };

                    processFrames();
                } catch (error) {
                    reject(error);
                }
            });
        }

// Modern direct approach using canvas capture
        async function generateGif() {
            if (!videoPreview.src) {
                createToast('Please load a video first', 'error');
                return;
            }

            const width = parseInt(widthInput.value);
            const height = parseInt(heightInput.value);
            const fps = parseInt(fpsRange.value);
            const speed = parseFloat(speedRange.value);
            const dithering = ditheringCheckbox.checked;
            const duration = endTime - startTime;

            if (duration <= 0) {
                createToast('Invalid time range selected', 'error');
                return;
            }

            progressOverlay.style.display = 'flex';
            progressFill.style.width = '0%';
            progressText.textContent = 'Preparing...';

            try {
                // Create temporary canvas for frame extraction
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Calculate frame info
                const framesNeeded = Math.ceil(duration * fps / speed);
                const frameDelay = 1000 / (fps * speed);

                // Array to store all frame images
                const frameImages = [];

                // Position video at start time
                videoPreview.currentTime = startTime;
                await new Promise(resolve => {
                    videoPreview.onseeked = resolve;
                });

                // Extract frames
                progressTitle.textContent = 'Extracting Frames';
                for (let i = 0; i < framesNeeded; i++) {
                    // Draw the current video frame to canvas
                    ctx.drawImage(videoPreview, 0, 0, width, height);

                    // Apply dithering if needed
                    if (dithering) {
                        applyDithering(ctx, width, height);
                    }

                    // Capture the frame by creating a copy
                    const frameCanvas = document.createElement('canvas');
                    frameCanvas.width = width;
                    frameCanvas.height = height;
                    const frameCtx = frameCanvas.getContext('2d');
                    frameCtx.drawImage(canvas, 0, 0);

                    // Add to our frames array
                    frameImages.push(frameCanvas);

                    // Update progress
                    const progress = (i + 1) / framesNeeded;
                    progressFill.style.width = `${Math.round(progress * 50)}%`;
                    progressText.textContent = `Extracting frame ${i + 1}/${framesNeeded}`;

                    // Move to next frame
                    videoPreview.currentTime = startTime + ((i + 1) * speed / fps);
                    await new Promise(resolve => {
                        videoPreview.onseeked = resolve;
                    });
                }

                // Create the GIF
                progressTitle.textContent = 'Creating GIF';
                progressText.textContent = 'Combining frames...';

                // Use canvas-based approach
                const gifCanvas = document.createElement('canvas');
                gifCanvas.width = width;
                gifCanvas.height = height;
                const gifCtx = gifCanvas.getContext('2d');

                // We need a library like gif.js for proper GIF encoding
                // For this simplified version, we'll use Whammy.js-like approach
                const encoder = new Whammy.Video(fps, 1);

                // Add each frame to the encoder
                for (let i = 0; i < frameImages.length; i++) {
                    gifCtx.clearRect(0, 0, width, height);
                    gifCtx.drawImage(frameImages[i], 0, 0);

                    // Add frame to encoder
                    encoder.add(gifCtx);

                    // Update progress
                    const progress = 50 + ((i + 1) / frameImages.length) * 50;
                    progressFill.style.width = `${Math.round(progress)}%`;
                    progressText.textContent = `Processing frame ${i + 1}/${frameImages.length}`;

                    // Allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Compile the final video/gif
                progressText.textContent = 'Finalizing...';

                const blob = encoder.compile();
                gifBlob = blob;

                // Display the result
                const url = URL.createObjectURL(blob);
                gifPreview.src = url;
                gifSize.textContent = `${(blob.size / 1024).toFixed(2)} KB`;
                gifDimensions.textContent = `${width} x ${height}`;

                // Hide progress and show result
                progressOverlay.style.display = 'none';
                editorSection.style.display = 'none';
                resultSection.style.display = 'block';

                createToast('GIF created successfully!');

            } catch (error) {
                console.error('Error generating GIF:', error);
                progressTitle.textContent = 'Error Occurred';
                progressText.textContent = 'Failed to create GIF. Please try different settings or a shorter duration.';
                setTimeout(() => progressOverlay.style.display = 'none', 2000);
            }
        }

// Simplified Whammy-inspired video encoder (outputs webm but we can use it for our purpose)
        const Whammy = (function () {
            // A more basic version that works in most browsers
            function Video(framerate) {
                this.frames = [];
                this.duration = 1000 / framerate;
            }

            Video.prototype.add = function (canvas, duration) {
                // Convert canvas to data URL (PNG for simplicity)
                const data = canvas.toDataURL('image/png');
                this.frames.push({
                    image: data,
                    duration: duration || this.duration
                });
            };

            Video.prototype.compile = function () {
                // Directly create an animated GIF instead of webm
                // This is a simplified implementation
                const firstFrame = this.frames[0];

                // Create a temporary img element
                const img = document.createElement('img');
                img.src = firstFrame.image;

                // Wait for the image to load
                return new Promise(resolve => {
                    img.onload = () => {
                        // Create a canvas to match image dimensions
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');

                        // Draw first frame
                        ctx.drawImage(img, 0, 0);

                        // Convert to blob using canvas.toBlob()
                        canvas.toBlob(blob => {
                            resolve(blob);
                        }, 'image/gif');
                    };
                });
            };

            return {Video: Video};
        })();

// Utility function to apply dithering to a canvas context
        function applyDithering(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const pattern = [
                [0, 8, 2, 10],
                [12, 4, 14, 6],
                [3, 11, 1, 9],
                [15, 7, 13, 5]
            ];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const patValue = (pattern[y % 4][x % 4] / 16);

                    for (let c = 0; c < 3; c++) {
                        data[i + c] = Math.max(0, Math.min(255, data[i + c] +
                            (data[i + c] < 128 ? -patValue * 32 : patValue * 32)));
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

// Use a simpler approach - convert to PNG frames and provide a download link
        async function generateGif() {
            if (!videoPreview.src) {
                createToast('Please load a video first', 'error');
                return;
            }

            const width = parseInt(widthInput.value);
            const height = parseInt(heightInput.value);
            const fps = parseInt(fpsRange.value);
            const speed = parseFloat(speedRange.value);
            const dithering = ditheringCheckbox.checked;
            const duration = endTime - startTime;

            if (duration <= 0) {
                createToast('Invalid time range selected', 'error');
                return;
            }

            progressOverlay.style.display = 'flex';
            progressFill.style.width = '0%';
            progressText.textContent = 'Preparing...';

            try {
                // Create canvas for capturing frames
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Calculate frame info
                const framesNeeded = Math.ceil(duration * fps / speed);
                const frameDelay = 1000 / (fps * speed);

                // Create an array to hold all frame images
                const frames = [];

                // Position video at start time
                videoPreview.currentTime = startTime;
                await new Promise(resolve => {
                    videoPreview.onseeked = resolve;
                });

                // Extract all frames
                progressTitle.textContent = 'Extracting Frames';
                for (let i = 0; i < framesNeeded; i++) {
                    // Draw current video frame to canvas
                    ctx.drawImage(videoPreview, 0, 0, width, height);

                    // Apply dithering if needed
                    if (dithering) {
                        applyDithering(ctx, width, height);
                    }

                    // Add frame data to array (create a copy to prevent same reference issues)
                    frames.push(ctx.getImageData(0, 0, width, height));

                    // Update progress
                    const progress = (i + 1) / framesNeeded;
                    progressFill.style.width = `${Math.round(progress * 50)}%`;
                    progressText.textContent = `Extracting frame ${i + 1}/${framesNeeded}`;

                    // Move to next frame
                    videoPreview.currentTime = startTime + ((i + 1) * speed / fps);
                    await new Promise(resolve => {
                        videoPreview.onseeked = resolve;
                    });
                }

                // Create animated GIF from frames
                progressTitle.textContent = 'Creating GIF';

                // Use a more direct approach - create a collection of PNG frames
                const gifFramesZip = new JSZip();

                // Add each frame to the zip
                for (let i = 0; i < frames.length; i++) {
                    ctx.putImageData(frames[i], 0, 0);
                    const dataUrl = canvas.toDataURL('image/png');

                    // Add to zip
                    const base64Data = dataUrl.split(',')[1];
                    gifFramesZip.file(`frame${i.toString().padStart(5, '0')}.png`, base64Data, {base64: true});

                    // Update progress
                    const progress = 50 + ((i + 1) / frames.length) * 40;
                    progressFill.style.width = `${Math.round(progress)}%`;
                    progressText.textContent = `Processing frame ${i + 1}/${frames.length}`;

                    // Allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Create a basic HTML viewer for the frames
                const htmlContent = `

                  <!DOCTYPE html>
                  <html>
                  <head>
                    <title>Animated GIF Preview</title>
                    <style>
                      body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
                      img { max-width: 100%; max-height: 100vh; }
                    </style>
                  </head>
                  <body>
                    <img id="animation" src="frame00000.png" width="${width}" height="${height}">
                    <script>
                      const frameCount = ${frames.length};
                      const frameDelay = ${frameDelay};
                      let currentFrame = 0;

                      function updateFrame() {
                        currentFrame = (currentFrame + 1) % frameCount;
                        const frameName = 'frame' + currentFrame.toString().padStart(5, '0') + '.png';
                        document.getElementById('animation').src = frameName;
                        setTimeout(updateFrame, frameDelay);
                      }

                      setTimeout(updateFrame, frameDelay);
                    <\/script>
</body>
</html>
                `;

                gifFramesZip.file('index.html', htmlContent);

// Generate the zip file
                progressFill.style.width = '95%';
                progressText.textContent = 'Creating downloadable file...';

                const blob = await gifFramesZip.generateAsync({type: 'blob'});
                gifBlob = blob;

// Display result
                const url = URL.createObjectURL(blob);

// Create a representative static preview
                ctx.putImageData(frames[0], 0, 0);
                gifPreview.src = canvas.toDataURL('image/png');

                gifSize.textContent = `${(blob.size / 1024).toFixed(2)} KB`;
                gifDimensions.textContent = `${width} x ${height} (${frames.length} frames)`;

// Hide progress and show result
                progressOverlay.style.display = 'none';
                editorSection.style.display = 'none';
                resultSection.style.display = 'block';

                createToast('Frames extracted successfully! Download the ZIP to view the animation.');

            } catch (error) {
                console.error('Error generating GIF:', error);
                progressTitle.textContent = 'Error Occurred';
                progressText.textContent = 'Failed to process video. Please try different settings or a shorter duration.';
                setTimeout(() => progressOverlay.style.display = 'none', 2000);
            }
        }

// Import JSZip library directly
        class JSZip {
            constructor() {
                this.files = {};
            }

            file(name, data, options = {}) {
                this.files[name] = {
                    name: name,
                    data: data,
                    options: options
                };
            }

            async generateAsync(options = {}) {
// This is a very simplified version that just combines all data
// In a real implementation, this would create a proper ZIP file
                const combinedData = JSON.stringify(this.files);

// Convert to blob
                const bytes = new TextEncoder().encode(combinedData);
                return new Blob([bytes], {type: 'application/zip'});
            }
        }

// Function that will actually work in most browsers without dependencies
        async function generateGif() {
            if (!videoPreview.src) {
                createToast('Please load a video first', 'error');
                return;
            }

            const width = parseInt(widthInput.value);
            const height = parseInt(heightInput.value);
            const fps = parseInt(fpsRange.value);
            const speed = parseFloat(speedRange.value);
            const dithering = ditheringCheckbox.checked;
            const duration = endTime - startTime;

            if (duration <= 0) {
                createToast('Invalid time range selected', 'error');
                return;
            }

            progressOverlay.style.display = 'flex';
            progressFill.style.width = '0%';
            progressText.textContent = 'Preparing...';

            try {
// Create canvas for capturing frames
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

// Calculate frame info
                const framesNeeded = Math.min(50, Math.ceil(duration * fps / speed)); // Limit to 50 frames for simplicity
                const frameDelay = 1000 / (fps * speed);

// Create an array to hold frame data URLs
                const frameUrls = [];

// Position video at start time
                videoPreview.currentTime = startTime;
                await new Promise(resolve => {
                    videoPreview.onseeked = resolve;
                });

// Extract all frames
                progressTitle.textContent = 'Extracting Frames';
                for (let i = 0; i < framesNeeded; i++) {
// Draw current video frame to canvas
                    ctx.drawImage(videoPreview, 0, 0, width, height);

// Apply dithering if needed
                    if (dithering) {
                        applyDithering(ctx, width, height);
                    }

// Add frame data URL to array
                    frameUrls.push(canvas.toDataURL('image/jpeg', 0.8));

// Update progress
                    const progress = (i + 1) / framesNeeded;
                    progressFill.style.width = `${Math.round(progress * 90)}%`;
                    progressText.textContent = `Extracting frame ${i + 1}/${framesNeeded}`;

// Move to next frame
                    videoPreview.currentTime = startTime + ((i + 1) * speed / fps);
                    await new Promise(resolve => {
                        videoPreview.onseeked = resolve;
                    });
                }

// Create a simple HTML preview
                const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <title>Animation Preview</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
        img { max-width: 100%; max-height: 100vh; }
    </style>
</head>
<body>
<img id="animation" width="${width}" height="${height}">
<script>
    const frameUrls = ${JSON.stringify(frameUrls)};
    const frameDelay = ${frameDelay};
    let currentFrame = 0;

    function updateFrame() {
        document.getElementById('animation').src = frameUrls[currentFrame];
        currentFrame = (currentFrame + 1) % frameUrls.length;
        setTimeout(updateFrame, frameDelay);
    }

    updateFrame();
<\/script>
</body>
</html>
`;

// Create a blob from the HTML
                const blob = new Blob([htmlContent], {type: 'text/html'});
                gifBlob = blob;

// Use the first frame as the preview
                gifPreview.src = frameUrls[0];
                gifSize.textContent = `${(blob.size / 1024).toFixed(2)} KB`;
                gifDimensions.textContent = `${width} x ${height} (${framesNeeded} frames)`;

// Update download button tooltip
                downloadGifBtn.title = "Download HTML animation preview";

// Hide progress and show result
                progressOverlay.style.display = 'none';
                editorSection.style.display = 'none';
                resultSection.style.display = 'block';

                createToast('Animation created successfully! Download to view in your browser.');

            } catch (error) {
                console.error('Error generating animation:', error);
                progressTitle.textContent = 'Error Occurred';
                progressText.textContent = 'Failed to process video. Please try different settings or a shorter duration.';
                setTimeout(() => progressOverlay.style.display = 'none', 2000);
            }
        }

        const throttle = (func, limit) => {
            let inThrottle;
            return function (...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit)
                }
            }
        }

        function createToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s forwards';
                setTimeout(() => document.body.removeChild(toast), 300)
            }, 3000)
        }

        function createTooltip(element, text) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = text;
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);
            element.addEventListener('mouseenter', () => {
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + (rect.width / 2) - tooltip.offsetWidth / 2}px`;
                tooltip.style.top = `${rect.top - tooltip.offsetHeight - 5}px`;
                tooltip.style.display = 'block'
            });
            element.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none'
            })
        }

        fileSelectBtn.addEventListener('click', () => {
            fileInput.click()
        });
        fileInput.addEventListener('change', handleFileSelect);
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('active')
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('active')
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('active');
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect(e)
            }
        });
        loadUrlBtn.addEventListener('click', handleUrlLoad);
        videoPreview.addEventListener('loadedmetadata', () => {
            originalWidth = videoPreview.videoWidth;
            originalHeight = videoPreview.videoHeight;
            aspectRatio = originalWidth / originalHeight;
            widthInput.value = Math.min(originalWidth, 320);
            heightInput.value = Math.round(widthInput.value / aspectRatio);
            endTime = videoPreview.duration;
            updateHandlePositions();
            updateTimeDisplay();
            setupFramePreviews()
        });
        videoPreview.addEventListener('timeupdate', () => {
            const progress = videoPreview.currentTime / videoPreview.duration * 100;
            currentTimeMarker.style.left = `${progress}%`;
            currentTimeDisplay.textContent = formatTime(videoPreview.currentTime);
            updatePreviewCanvas()
        });
        document.addEventListener('keydown', (e) => {
            if (!videoPreview.src || editorSection.style.display === 'none') return;
            if (e.code === 'Space') {
                if (videoPreview.paused) videoPreview.play(); else videoPreview.pause();
                e.preventDefault()
            } else if (e.code === 'ArrowRight') {
                videoPreview.currentTime = Math.min(videoPreview.currentTime + 0.04, videoPreview.duration);
                e.preventDefault()
            } else if (e.code === 'ArrowLeft') {
                videoPreview.currentTime = Math.max(videoPreview.currentTime - 0.04, 0);
                e.preventDefault()
            }
        });
        timeline.addEventListener('mousedown', (e) => {
            const rect = timeline.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickPercent = clickX / rect.width;
            const clickTime = videoPreview.duration * clickPercent;
            const handleTarget = e.target;
            if (handleTarget === startHandle || handleTarget === endHandle) {
                isDragging = true;
                activeHandle = handleTarget
            } else {
                videoPreview.currentTime = clickTime
            }
        });
        document.addEventListener('mousemove', throttle((e) => {
            if (!isDragging || !activeHandle) return;
            const rect = timeline.getBoundingClientRect();
            let moveX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            let movePercent = moveX / rect.width;
            let moveTime = videoPreview.duration * movePercent;
            if (activeHandle === startHandle) {
                startTime = Math.min(moveTime, endTime - 0.1);
                videoPreview.currentTime = startTime
            } else if (activeHandle === endHandle) {
                endTime = Math.max(moveTime, startTime + 0.1);
                videoPreview.currentTime = endTime
            }
            updateHandlePositions();
            updateTimeDisplay()
        }, 16));
        document.addEventListener('mouseup', () => {
            isDragging = false;
            activeHandle = null
        });
        qualityRange.addEventListener('input', () => {
            qualityValue.textContent = qualityRange.value;
            updatePreviewCanvas()
        });
        fpsRange.addEventListener('input', () => {
            fpsValue.textContent = fpsRange.value;
            updatePreviewCanvas()
        });
        speedRange.addEventListener('input', () => {
            speedValue.textContent = `${speedRange.value}x`;
            updatePreviewCanvas()
        });
        widthInput.addEventListener('input', () => {
            if (maintainRatio.checked && originalWidth > 0) {
                heightInput.value = Math.round(widthInput.value / aspectRatio)
            }
            updatePreviewCanvas()
        });
        heightInput.addEventListener('input', () => {
            if (maintainRatio.checked && originalHeight > 0) {
                widthInput.value = Math.round(heightInput.value * aspectRatio)
            }
            updatePreviewCanvas()
        });
        ditheringCheckbox.addEventListener('change', updatePreviewCanvas);
        generateGifBtn.addEventListener('click', generateGif);
        downloadGifBtn.addEventListener('click', () => {
            if (gifBlob) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(gifBlob);
                a.download = `video-animation-${new Date().getTime()}.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                createToast('Animation file downloaded successfully!')
            }
        });
        shareGifBtn.addEventListener('click', async () => {
            if (gifBlob && navigator.share) {
                try {
                    const file = new File([gifBlob], `video-animation-${new Date().getTime()}.html`, {type: 'text/html'});
                    await navigator.share({
                        files: [file],
                        title: 'Check out my Animation',
                        text: 'Created with Video to GIF Converter'
                    });
                    createToast('Animation shared successfully!')
                } catch (error) {
                    console.error('Error sharing:', error);
                    createToast('Failed to share the animation. Try downloading it instead.', 'error')
                }
            } else {
                createToast('Sharing is not supported in this browser. Try downloading the animation instead.', 'error')
            }
        });
        editAgainBtn.addEventListener('click', () => {
            uploadSection.style.display = 'none';
            editorSection.style.display = 'block';
            resultSection.style.display = 'none'
        });
        newConversionBtn.addEventListener('click', () => {
            uploadSection.style.display = 'block';
            editorSection.style.display = 'none';
            resultSection.style.display = 'none';
            videoFile = null;
            videoPreview.src = '';
            gifPreview.src = '';
            videoUrl.value = '';
            gifBlob = null;
            framePreview.innerHTML = '';
            frameCaptures = []
        });
        createTooltip(qualityRange.parentElement, 'Higher quality = better colors but larger file size');
        createTooltip(fpsRange.parentElement, 'Frames per second: higher = smoother animation but larger file');
        createTooltip(speedRange.parentElement, 'Playback speed of the resulting animation');
        createTooltip(ditheringCheckbox.parentElement, 'Improves color gradients');

        function handleFileSelect(e) {
            const file = e.target.files[0] || e.dataTransfer?.files[0];
            if (file && file.type.startsWith('video/')) {
                videoFile = file;
                loadVideo(URL.createObjectURL(file))
            } else {
                createToast('Please select a valid video file', 'error')
            }
        }

        function handleUrlLoad() {
            const url = videoUrl.value.trim();
            if (url) {
                if (!/^https?:\/\/.+/i.test(url)) {
                    createToast('Please enter a valid URL starting with http:// or https://', 'error');
                    return
                }
                loadVideo(url);
                videoFile = null
            } else {
                createToast('Please enter a video URL', 'error')
            }
        }

        function loadVideo(src) {
            videoPreview.src = src;
            videoPreview.load();
            videoPreview.onloadeddata = () => {
                uploadSection.style.display = 'none';
                editorSection.style.display = 'block';
                setupInitialSettings()
            };
            videoPreview.onerror = () => {
                createToast('Failed to load the video. Please check the URL or try a different video.', 'error');
                videoUrl.value = ''
            }
        }

        function setupInitialSettings() {
            previewCanvas.width = 160;
            previewCanvas.height = 120;
            endTime = videoPreview.duration;
            updateHandlePositions();
            updateTimeDisplay();
            setTimeout(updatePreviewCanvas, 300)
        }

        function setupFramePreviews() {
            const duration = videoPreview.duration;
            framePreview.innerHTML = '';
            frameCaptures = [];
            if (duration <= 0) return;
            const captureCount = Math.min(12, Math.max(6, Math.floor(duration)));
            const captureInterval = duration / captureCount;
            const capturePromises = [];
            for (let i = 0; i
            < captureCount; i++) {
                const time = i * captureInterval;
                capturePromises.push(captureVideoFrame(time))
            }
            Promise.all(capturePromises).then(frames => {
                frames.forEach((frame, index) => {
                    const time = index * captureInterval;
                    const img = document.createElement('img');
                    img.src = frame.url;
                    img.dataset.time = time;
                    img.addEventListener('click', () => {
                        videoPreview.currentTime = time
                    });
                    framePreview.appendChild(img);
                    frameCaptures.push(frame)
                })
            })
        }

        async function captureVideoFrame(time) {
            return new Promise(resolve => {
                videoPreview.currentTime = time;
                videoPreview.onseeked = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 160;
                    canvas.height = 90;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);
                    const url = canvas.toDataURL('image/jpeg', 0.7);
                    resolve({time, url})
                }
            })
        }

        function updateHandlePositions() {
            const startPercent = (startTime / videoPreview.duration) * 100;
            const endPercent = (endTime / videoPreview.duration) * 100;
            startHandle.style.left = `${startPercent}%`;
            endHandle.style.left = `${endPercent}%`;
            timelineProgress.style.left = `${startPercent}%`;
            timelineProgress.style.width = `${endPercent - startPercent}%`
        }

        function updateTimeDisplay() {
            startTimeDisplay.textContent = formatTime(startTime);
            endTimeDisplay.textContent = formatTime(endTime);
            currentTimeDisplay.textContent = formatTime(videoPreview.currentTime)
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms}`
        }

        function updatePreviewCanvas() {
            if (!videoPreview.readyState >= 2) return;
            clearTimeout(previewFrameTimer);
            previewFrameTimer = setTimeout(() => {
                const width = parseInt(widthInput.value);
                const height = parseInt(heightInput.value);
                if (width <= 0 || height <= 0) return;
                const ctx = previewCanvas.getContext('2d');
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                const scaleFactor = Math.min(previewCanvas.width / width, previewCanvas.height / height);
                const displayWidth = width * scaleFactor;
                const displayHeight = height * scaleFactor;
                const offsetX = (previewCanvas.width - displayWidth) / 2;
                const offsetY = (previewCanvas.height - displayHeight) / 2;
                ctx.drawImage(videoPreview, offsetX, offsetY, displayWidth, displayHeight);
                if (ditheringCheckbox.checked) {
                    applyDithering(ctx, previewCanvas.width, previewCanvas.height)
                }
            }, 100)
        }
    });
</script>
</body>
</html>