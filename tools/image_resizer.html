<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Image Resizer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
  <style>
    /* Keep all existing styles */
    :root {
      --primary-color: #4361ee;
      --secondary-color: #3f37c9;
      --success-color: #4cc9f0;
      --light-bg: #f8f9fa;
      --border-radius: 10px;
    }
    body {
      background-color: var(--light-bg);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .container {
      max-width: 1200px;
      margin: 30px auto;
    }
    .card {
      border: none;
      border-radius: var(--border-radius);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    .card-header {
      background-color: var(--primary-color);
      color: white;
      font-weight: 600;
      padding: 15px 20px;
    }
    .btn-primary {
      background-color: var(--primary-color);
      border-color: var(--primary-color);
    }
    .btn-primary:hover {
      background-color: var(--secondary-color);
      border-color: var(--secondary-color);
    }
    .drop-area {
      border: 2px dashed #ccc;
      border-radius: var(--border-radius);
      padding: 30px;
      text-align: center;
      margin-bottom: 20px;
      transition: all 0.3s;
      cursor: pointer;
    }
    .drop-area:hover, .drop-area.dragover {
      border-color: var(--primary-color);
      background-color: rgba(67, 97, 238, 0.05);
    }
    .drop-area i {
      font-size: 48px;
      color: #ccc;
      margin-bottom: 10px;
    }
    .image-preview {
      position: relative;
      border-radius: var(--border-radius);
      overflow: hidden;
      margin-bottom: 15px;
      background-color: #eee;
      text-align: center;
    }
    .image-preview img {
      max-width: 100%;
      max-height: 300px;
    }
    .image-preview .info-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 12px;
    }
    .form-label {
      font-weight: 500;
    }
    .input-group {
      margin-bottom: 15px;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .slider-container .form-range {
      flex-grow: 1;
    }
    .slider-container .form-control {
      width: 80px;
      text-align: center;
    }
    .custom-tooltip {
      position: relative;
      cursor: help;
    }
    .custom-tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .custom-tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    .comparison-container {
      display: flex;
      gap: 20px;
      overflow-x: auto;
    }
    .comparison-container > div {
      flex: 1;
      min-width: 250px;
    }
    .rotate-controls {
      margin-bottom: 15px;
      text-align: center;
    }
    .rotate-controls button {
      padding: 5px 10px;
      margin: 0 5px;
    }
    .preview-label {
      background: var(--primary-color);
      color: white;
      text-align: center;
      padding: 5px;
      border-top-left-radius: var(--border-radius);
      border-top-right-radius: var(--border-radius);
    }
    .progress-container {
      height: 5px;
      width: 100%;
      background-color: #e9ecef;
      border-radius: 2px;
      margin-bottom: 15px;
    }
    .progress-bar {
      height: 100%;
      background-color: var(--primary-color);
      width: 0%;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      .comparison-container {
        flex-direction: column;
      }
    }
    /* New styles for warnings and loading */
    .warning-badge {
      display: inline-block;
      padding: 0.25em 0.4em;
      font-size: 75%;
      font-weight: 700;
      line-height: 1;
      text-align: center;
      white-space: nowrap;
      vertical-align: baseline;
      border-radius: 0.25rem;
      color: #fff;
      background-color: #ffc107;
      color: #212529;
    }
    .loading-spinner {
      display: inline-block;
      width: 1rem;
      height: 1rem;
      border: 0.2em solid currentColor;
      border-right-color: transparent;
      border-radius: 50%;
      animation: spinner-border .75s linear infinite;
    }
    @keyframes spinner-border {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0"><i class="bi bi-image-alt me-2"></i>Advanced Image Resizer</h5>
      <span id="current-date" class="text-light small"></span>
    </div>
    <div class="card-body">
      <div class="row">
        <div class="col-lg-5">
          <div class="input-section mb-4">
            <h6 class="mb-3"><i class="bi bi-upload me-2"></i>Image Input</h6>
            <div id="drop-area" class="drop-area">
              <i class="bi bi-cloud-arrow-up"></i>
              <p class="mb-2">Drag & drop your image here or</p>
              <input type="file" id="image-input" accept="image/*" class="d-none">
              <button class="btn btn-primary btn-sm" id="select-file-btn">Select File</button>
            </div>
            <div class="input-group mt-3">
              <span class="input-group-text"><i class="bi bi-link"></i></span>
              <input type="text" class="form-control" id="url-input" placeholder="Or enter image URL">
              <button class="btn btn-outline-primary" id="load-url-btn">Load</button>
            </div>
            <div id="original-info" class="mt-2 small text-muted"></div>
            <div id="progress-container" class="progress-container d-none">
              <div id="progress-bar" class="progress-bar"></div>
            </div>
          </div>

          <div class="resize-section mb-4">
            <h6 class="mb-3"><i class="bi bi-aspect-ratio me-2"></i>Resize Options</h6>

            <div class="mb-3">
              <label class="form-label d-flex justify-content-between">
                Width
                <div class="form-check form-switch d-inline">
                  <input class="form-check-input" type="checkbox" id="width-percent" role="switch">
                  <label class="form-check-label small" for="width-percent">%</label>
                </div>
              </label>
              <div class="slider-container">
                <input type="range" class="form-range" id="width-slider" min="1" max="100" value="100">
                <input type="number" class="form-control" id="width-input" min="1">
              </div>
            </div>

            <div class="mb-3">
              <label class="form-label d-flex justify-content-between">
                Height
                <div class="form-check form-switch d-inline">
                  <input class="form-check-input" type="checkbox" id="height-percent" role="switch">
                  <label class="form-check-label small" for="height-percent">%</label>
                </div>
              </label>
              <div class="slider-container">
                <input type="range" class="form-range" id="height-slider" min="1" max="100" value="100">
                <input type="number" class="form-control" id="height-input" min="1">
              </div>
            </div>

            <div class="form-group mb-3">
              <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="aspect-ratio-checkbox" checked>
                <label class="form-check-label" for="aspect-ratio-checkbox">
                  Maintain aspect ratio
                </label>
              </div>
            </div>

            <div class="form-group mb-3" id="fit-mode-container">
              <label for="fit-mode-select" class="form-label">Fitting mode</label>
              <select class="form-select" id="fit-mode-select">
                <option value="stretch">Stretch/Compress</option>
                <option value="crop">Crop to Fill</option>
                <option value="letterbox">Add Black Bars</option>
              </select>
              <small class="form-text text-muted">How to handle aspect ratio differences</small>
            </div>

            <div class="row">
              <div class="col-md-6">
                <div class="form-group mb-3">
                  <label for="format-select" class="form-label">Format</label>
                  <select class="form-select" id="format-select">
                    <option value="jpeg">JPEG</option>
                    <option value="png">PNG</option>
                    <option value="webp">WebP</option>
                    <option value="gif">GIF</option>
                  </select>
                </div>
              </div>
              <div class="col-md-6" id="quality-control">
                <div class="form-group mb-3">
                  <label for="quality-input" class="form-label">Quality</label>
                  <div class="d-flex align-items-center">
                    <input type="range" class="form-range me-2" id="quality-input" min="1" max="100" value="90">
                    <span id="quality-value">90%</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="rotate-controls">
              <button class="btn btn-outline-secondary btn-sm" id="rotate-left"><i class="bi bi-arrow-counterclockwise"></i> Rotate Left</button>
              <button class="btn btn-outline-secondary btn-sm" id="rotate-right"><i class="bi bi-arrow-clockwise"></i> Rotate Right</button>
              <button class="btn btn-outline-secondary btn-sm" id="flip-horizontal">
                <i class="bi bi-symmetry-vertical"></i>
              </button>
              <button class="btn btn-outline-secondary btn-sm" id="flip-vertical">
                <i class="bi bi-symmetry-horizontal"></i>
              </button>
            </div>

            <div class="d-grid gap-2">
              <button id="reset-btn" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-repeat me-2"></i>Reset
              </button>
            </div>
          </div>
        </div>

        <div class="col-lg-7">
          <div class="comparison-container">
            <div id="original-container" class="d-none">
              <div class="preview-label">Original</div>
              <div class="image-preview">
                <img id="original-preview" alt="Original image">
                <div class="info-overlay" id="original-overlay"></div>
              </div>
            </div>

            <div id="result-container" class="d-none">
              <div class="preview-label">Resized</div>
              <div class="image-preview">
                <img id="result-preview" alt="Resized image">
                <div class="info-overlay" id="result-overlay"></div>
              </div>
              <div class="d-grid gap-2 mt-3">
                <a id="download-btn" class="btn btn-success" download="resized_image">
                  <i class="bi bi-download me-2"></i>Download Image
                </a>
              </div>
            </div>
          </div>

          <div id="error-container" class="mt-3"></div>
        </div>
      </div>
    </div>
    <div class="card-footer bg-white text-center text-muted small py-2">
      Made with 🦃 by GPTGames
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // DOM elements
    const dropArea = document.getElementById('drop-area');
    const imageInput = document.getElementById('image-input');
    const selectFileBtn = document.getElementById('select-file-btn');
    const urlInput = document.getElementById('url-input');
    const loadUrlBtn = document.getElementById('load-url-btn');
    const widthInput = document.getElementById('width-input');
    const heightInput = document.getElementById('height-input');
    const widthSlider = document.getElementById('width-slider');
    const heightSlider = document.getElementById('height-slider');
    const widthPercent = document.getElementById('width-percent');
    const heightPercent = document.getElementById('height-percent');
    const aspectRatioCheckbox = document.getElementById('aspect-ratio-checkbox');
    const formatSelect = document.getElementById('format-select');
    const qualityInput = document.getElementById('quality-input');
    const qualityValue = document.getElementById('quality-value');
    const rotateLeft = document.getElementById('rotate-left');
    const rotateRight = document.getElementById('rotate-right');
    const flipHorizontal = document.getElementById('flip-horizontal');
    const flipVertical = document.getElementById('flip-vertical');
    const resetBtn = document.getElementById('reset-btn');
    const originalPreview = document.getElementById('original-preview');
    const resultPreview = document.getElementById('result-preview');
    const originalContainer = document.getElementById('original-container');
    const resultContainer = document.getElementById('result-container');
    const originalInfo = document.getElementById('original-info');
    const originalOverlay = document.getElementById('original-overlay');
    const resultOverlay = document.getElementById('result-overlay');
    const downloadBtn = document.getElementById('download-btn');
    const errorContainer = document.getElementById('error-container');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const qualityControl = document.getElementById('quality-control');
    const currentDate = document.getElementById('current-date');
    const fitModeSelect = document.getElementById('fit-mode-select');
    const fitModeContainer = document.getElementById('fit-mode-container');

    // Variables
    let originalImage = null;
    let rotation = 0;
    let flipH = false;
    let flipV = false;
    let origWidth = 0;
    let origHeight = 0;
    let imageLoaded = false;
    let resizeTimeout = null;
    let processingImage = false;
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    const MAX_DIMENSION = 4000; // 4000px max dimension
    const IMAGE_PROCESS_TIMEOUT = 30000; // 30 seconds timeout for processing

    // Browser capability detection
    const browserSupportsWebP = (() => {
      const canvas = document.createElement('canvas');
      if (canvas.getContext && canvas.getContext('2d')) {
        return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
      }
      return false;
    })();

    // Update WebP option availability
    if (!browserSupportsWebP) {
      const webpOption = Array.from(formatSelect.options).find(option => option.value === 'webp');
      if (webpOption) {
        webpOption.disabled = true;
        webpOption.text = 'WebP (not supported)';
      }
    }

    // Set current date
    const now = new Date();
    currentDate.textContent = now.toLocaleDateString();

    // Initialize from localStorage
    function loadSettings() {
      try {
        const settings = JSON.parse(localStorage.getItem('imageResizerSettings')) || {};
        if (settings.aspectRatio !== undefined) aspectRatioCheckbox.checked = settings.aspectRatio;
        if (settings.format) {
          // Only set format if it's supported
          if (settings.format !== 'webp' || browserSupportsWebP) {
            formatSelect.value = settings.format;
          }
        }
        if (settings.quality) {
          qualityInput.value = settings.quality;
          qualityValue.textContent = settings.quality + '%';
        }
        if (settings.fitMode) {
          fitModeSelect.value = settings.fitMode;
        }
        updateQualityVisibility();
        updateFitModeVisibility();
      } catch (error) {
        console.error('Error loading settings:', error);
        localStorage.removeItem('imageResizerSettings');
      }
    }

    function saveSettings() {
      try {
        const settings = {
          aspectRatio: aspectRatioCheckbox.checked,
          format: formatSelect.value,
          quality: qualityInput.value,
          fitMode: fitModeSelect.value // Save the fit mode
        };
        localStorage.setItem('imageResizerSettings', JSON.stringify(settings));
      } catch (error) {
        console.error('Error saving settings:', error);
        showError('Unable to save settings to browser storage');
      }
    }

    function updateFitModeVisibility() {
      fitModeContainer.style.display = aspectRatioCheckbox.checked ? 'none' : 'block';
    }

    // Helper functions
    function formatBytes(bytes, decimals = 2) {
      if (!bytes || bytes === 0) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function showError(message, duration = 5000) {
      errorContainer.innerHTML = `<div class="alert alert-danger">${message}</div>`;
      if (duration > 0) {
        setTimeout(() => {
          errorContainer.innerHTML = '';
        }, duration);
      }
    }

    function showWarning(message, duration = 5000) {
      errorContainer.innerHTML = `<div class="alert alert-warning">${message}</div>`;
      if (duration > 0) {
        setTimeout(() => {
          errorContainer.innerHTML = '';
        }, duration);
      }
    }

    function showProgress(show) {
      progressContainer.classList.toggle('d-none', !show);
      if (show) {
        progressBar.style.width = '0%';
        setTimeout(() => {
          progressBar.style.width = '100%';
        }, 10);
      }
    }

    function updateQualityVisibility() {
      const format = formatSelect.value;
      qualityControl.style.display = (format === 'jpeg' || format === 'webp') ? 'block' : 'none';
    }

    function validateUrl(url) {
      try {
        new URL(url);
        return true;
      } catch (e) {
        return false;
      }
    }

    function updateSliderRanges() {
      if (!imageLoaded) return;

      // Determine effective dimensions based on rotation
      let effectiveWidth = origWidth;
      let effectiveHeight = origHeight;

      // Swap dimensions if rotated 90 or 270 degrees
      if (Math.abs(rotation % 180) === 90) {
        effectiveWidth = origHeight;
        effectiveHeight = origWidth;
      }

      // Set slider max values based on original image dimensions
      let widthMax = widthPercent.checked ? 200 : Math.min(MAX_DIMENSION, effectiveWidth * 2);
      let heightMax = heightPercent.checked ? 200 : Math.min(MAX_DIMENSION, effectiveHeight * 2);

      widthSlider.min = widthPercent.checked ? 1 : 1;
      heightSlider.min = heightPercent.checked ? 1 : 1;
      widthSlider.max = widthMax;
      heightSlider.max = heightMax;

      // Default to 100% or original dimensions
      if (widthPercent.checked) {
        widthSlider.value = 100;
        widthInput.value = 100;
      } else {
        widthSlider.value = effectiveWidth;
        widthInput.value = effectiveWidth;
      }

      if (heightPercent.checked) {
        heightSlider.value = 100;
        heightInput.value = 100;
      } else {
        heightSlider.value = effectiveHeight;
        heightInput.value = effectiveHeight;
      }
    }

    function calculateSize(width, height) {
      if (!imageLoaded) return { width: 0, height: 0 };

      // Determine effective dimensions based on rotation
      let effectiveWidth = origWidth;
      let effectiveHeight = origHeight;
      let effectiveAspectRatio = origWidth / origHeight;

      // Swap dimensions if rotated 90 or 270 degrees
      if (Math.abs(rotation % 180) === 90) {
        effectiveWidth = origHeight;
        effectiveHeight = origWidth;
        effectiveAspectRatio = origHeight / origWidth;
      }

      if (widthPercent.checked && width) {
        width = Math.round(effectiveWidth * width / 100);
      }

      if (heightPercent.checked && height) {
        height = Math.round(effectiveHeight * height / 100);
      }

      if (aspectRatioCheckbox.checked) {
        if (width && !height) {
          height = Math.round(width / effectiveAspectRatio);
        } else if (!width && height) {
          width = Math.round(height * effectiveAspectRatio);
        } else if (width && height) {
          // Use the most recently changed dimension as primary
          if (document.activeElement === widthInput || document.activeElement === widthSlider) {
            height = Math.round(width / effectiveAspectRatio);
          } else {
            width = Math.round(height * effectiveAspectRatio);
          }
        } else {
          width = effectiveWidth;
          height = effectiveHeight;
        }
      } else {
        width = width || effectiveWidth;
        height = height || effectiveHeight;
      }

      // Ensure we have valid dimensions within limits
      width = Math.max(1, Math.min(MAX_DIMENSION, width));
      height = Math.max(1, Math.min(MAX_DIMENSION, height));

      return { width, height };
    }

    // Fix the updateSizeInputs function to properly respect aspect ratio setting:
    function updateSizeInputs() {
      if (!imageLoaded) return;

      const activeElement = document.activeElement;
      let width, height;

      // Determine which input/slider was changed
      if (activeElement === widthInput || activeElement === widthSlider) {
        width = parseInt(widthInput.value) || 0;
        height = parseInt(heightInput.value) || 0;

        // Only recalculate height if maintaining aspect ratio
        if (aspectRatioCheckbox.checked) {
          height = null; // Force recalculation in calculateSize
        }
      } else if (activeElement === heightInput || activeElement === heightSlider) {
        width = parseInt(widthInput.value) || 0;
        height = parseInt(heightInput.value) || 0;

        // Only recalculate width if maintaining aspect ratio
        if (aspectRatioCheckbox.checked) {
          width = null; // Force recalculation in calculateSize
        }
      } else {
        width = parseInt(widthInput.value) || 0;
        height = parseInt(heightInput.value) || 0;
      }

      const newSize = calculateSize(width, height);

      // Only update the non-active input when aspect ratio is checked
      if (aspectRatioCheckbox.checked) {
        // Update width if height was changed
        if (activeElement === heightInput || activeElement === heightSlider) {
          widthInput.value = newSize.width;
          widthSlider.value = widthPercent.checked ?
                  Math.min(200, Math.round((newSize.width / (Math.abs(rotation % 180) === 90 ? origHeight : origWidth)) * 100)) :
                  newSize.width;
        }

        // Update height if width was changed
        if (activeElement === widthInput || activeElement === widthSlider) {
          heightInput.value = newSize.height;
          heightSlider.value = heightPercent.checked ?
                  Math.min(200, Math.round((newSize.height / (Math.abs(rotation % 180) === 90 ? origWidth : origHeight)) * 100)) :
                  newSize.height;
        }
      }

      // If no active element (like during initialization), update both
      if (!activeElement) {
        widthInput.value = newSize.width;
        heightInput.value = newSize.height;

        widthSlider.value = widthPercent.checked ?
                Math.min(200, Math.round((newSize.width / (Math.abs(rotation % 180) === 90 ? origHeight : origWidth)) * 100)) :
                newSize.width;

        heightSlider.value = heightPercent.checked ?
                Math.min(200, Math.round((newSize.height / (Math.abs(rotation % 180) === 90 ? origWidth : origHeight)) * 100)) :
                newSize.height;
      }

      // Trigger resize with debounce
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resizeImage();
      }, 300);
    }

    function syncSliderAndInput(slider, input) {
      const value = parseInt(input.value) || 0;
      if (value > 0) {
        slider.value = Math.min(slider.max, value);
      }
    }

    function syncInputAndSlider(input, slider) {
      input.value = slider.value;
    }

    // Event listeners
    selectFileBtn.addEventListener('click', () => {
      imageInput.click();
    });

    dropArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropArea.classList.add('dragover');
    });

    dropArea.addEventListener('dragleave', () => {
      dropArea.classList.remove('dragover');
    });

    dropArea.addEventListener('drop', (e) => {
      e.preventDefault();
      dropArea.classList.remove('dragover');
      if (e.dataTransfer.files.length) {
        handleFile(e.dataTransfer.files[0]);
      }
    });

    imageInput.addEventListener('change', () => {
      if (imageInput.files.length) {
        handleFile(imageInput.files[0]);
      }
    });

    loadUrlBtn.addEventListener('click', () => {
      const url = urlInput.value.trim();
      if (url) {
        if (validateUrl(url)) {
          loadImageFromURL(url);
        } else {
          showError('Please enter a valid URL');
        }
      } else {
        showError('Please enter an image URL');
      }
    });

    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        loadUrlBtn.click();
      }
    });

    // Width input and slider events
    widthInput.addEventListener('input', () => {
      const value = parseInt(widthInput.value) || 0;
      if (value <= 0) {
        widthInput.value = 1;
      } else if (value > MAX_DIMENSION) {
        widthInput.value = MAX_DIMENSION;
        showWarning(`Width limited to ${MAX_DIMENSION}px for browser stability`);
      }
      syncSliderAndInput(widthSlider, widthInput);
      updateSizeInputs();
    });

    widthSlider.addEventListener('input', () => {
      syncInputAndSlider(widthInput, widthSlider);
      updateSizeInputs();
    });

    // Height input and slider events
    heightInput.addEventListener('input', () => {
      const value = parseInt(heightInput.value) || 0;
      if (value <= 0) {
        heightInput.value = 1;
      } else if (value > MAX_DIMENSION) {
        heightInput.value = MAX_DIMENSION;
        showWarning(`Height limited to ${MAX_DIMENSION}px for browser stability`);
      }
      syncSliderAndInput(heightSlider, heightInput);
      updateSizeInputs();
    });

    heightSlider.addEventListener('input', () => {
      syncInputAndSlider(heightInput, heightSlider);
      updateSizeInputs();
    });

    widthPercent.addEventListener('change', () => {
      updateSliderRanges();
      updateSizeInputs();
    });

    heightPercent.addEventListener('change', () => {
      updateSliderRanges();
      updateSizeInputs();
    });

    aspectRatioCheckbox.addEventListener('change', () => {
      updateSizeInputs();
      updateFitModeVisibility();
      saveSettings();
    });

    fitModeSelect.addEventListener('change', () => {
      saveSettings();
      if (imageLoaded) {
        resizeImage();
      }
    });

    formatSelect.addEventListener('change', () => {
      updateQualityVisibility();
      saveSettings();
      if (imageLoaded) {
        resizeImage();
      }
    });

    qualityInput.addEventListener('input', () => {
      qualityValue.textContent = qualityInput.value + '%';
      saveSettings();
      if (imageLoaded) {
        // Use debounce for quality changes
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resizeImage();
        }, 300);
      }
    });

    rotateLeft.addEventListener('click', () => {
      if (!imageLoaded) return;
      rotation = (rotation - 90) % 360;
      if (rotation < 0) rotation += 360;
      updateOriginalPreview();
      updateSliderRanges();
      updateSizeInputs();
    });

    rotateRight.addEventListener('click', () => {
      if (!imageLoaded) return;
      rotation = (rotation + 90) % 360;
      updateOriginalPreview();
      updateSliderRanges();
      updateSizeInputs();
    });

    flipHorizontal.addEventListener('click', () => {
      if (!imageLoaded) return;
      flipH = !flipH;
      updateOriginalPreview();
      resizeImage();
    });

    flipVertical.addEventListener('click', () => {
      if (!imageLoaded) return;
      flipV = !flipV;
      updateOriginalPreview();
      resizeImage();
    });

    resetBtn.addEventListener('click', () => {
      resetForm();
    });

    // Functions to handle image loading and processing
    function handleFile(file) {
      if (!file.type.match('image.*')) {
        showError('Please select a valid image file');
        return;
      }

      if (file.size > MAX_FILE_SIZE) {
        showWarning(`The file is large (${formatBytes(file.size)}). Processing might be slow or fail.`);
      }

      const reader = new FileReader();
      showProgress(true);

      reader.onload = (e) => {
        loadImage(e.target.result, file.name, file.size);
      };

      reader.onerror = () => {
        showProgress(false);
        showError('Error reading file. The file may be corrupted or too large.');
      };

      reader.readAsDataURL(file);
    }

    function loadImageFromURL(url) {
      showProgress(true);

      // Clear previous timeouts if any
      if (window.imageLoadTimeout) {
        clearTimeout(window.imageLoadTimeout);
      }

      // Set a timeout for image loading
      window.imageLoadTimeout = setTimeout(() => {
        showProgress(false);
        showError('Image loading timed out. The image might be too large or the server is not responding.');
      }, 20000); // 20 seconds timeout

      const img = new Image();

      img.onload = function() {
        clearTimeout(window.imageLoadTimeout);
        showProgress(false);

        // Check if image dimensions are too large
        if (img.width * img.height > MAX_DIMENSION * MAX_DIMENSION) {
          showWarning(`This image is very large (${img.width}×${img.height}). Processing might be slow.`);
        }

        // Convert the image to a data URL
        try {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          try {
            const dataUrl = canvas.toDataURL('image/png');
            loadImage(dataUrl, url.split('/').pop() || 'image', null);

            // Clean up
            canvas.width = 1;
            canvas.height = 1;
          } catch (error) {
            showError('Error processing image from URL. It might be protected or from a different domain.');
          }
        } catch (error) {
          showError('Failed to process the image. The image might be too large or corrupt.');
        }
      };

      img.onerror = function() {
        clearTimeout(window.imageLoadTimeout);
        showProgress(false);
        showError(`Failed to load image from URL. The image might not exist or CORS policy is preventing access. Try downloading the image and uploading it directly.`);
      };

      try {
        img.crossOrigin = 'anonymous';
        img.src = url;
      } catch (error) {
        clearTimeout(window.imageLoadTimeout);
        showProgress(false);
        showError('Invalid URL format or access denied.');
      }
    }

    function loadImage(src, filename, fileSize) {
      if (processingImage) return;
      processingImage = true;
      showProgress(true);

      // Clear previous timeouts if any
      if (window.imageProcessTimeout) {
        clearTimeout(window.imageProcessTimeout);
      }

      // Set a timeout for image processing
      window.imageProcessTimeout = setTimeout(() => {
        processingImage = false;
        showProgress(false);
        showError('Image processing timed out. The image might be too large for your browser to handle.');
      }, IMAGE_PROCESS_TIMEOUT);

      const img = new Image();

      img.onload = function() {
        clearTimeout(window.imageProcessTimeout);
        showProgress(false);
        processingImage = false;

        // Check image dimensions
        if (img.width <= 0 || img.height <= 0) {
          showError('Invalid image dimensions. The image appears to be empty or corrupted.');
          return;
        }

        if (img.width > MAX_DIMENSION || img.height > MAX_DIMENSION) {
          showWarning(`Image dimensions (${img.width}×${img.height}) exceed recommended maximum. Resizing might be limited.`);
        }

        // Store image data
        originalImage = img;
        origWidth = img.width;
        origHeight = img.height;
        imageLoaded = true;
        rotation = 0;
        flipH = false;
        flipV = false;

        // Update UI
        originalContainer.classList.remove('d-none');
        updateOriginalPreview();

        // Set up sliders
        updateSliderRanges();

        // Show image info
        const fileSizeText = fileSize ? formatBytes(fileSize) : 'Unknown';
        originalInfo.innerHTML = `
          <strong>${filename}</strong><br>
          Original size: ${origWidth} × ${origHeight} pixels | ${fileSizeText}
        `;
        originalOverlay.textContent = `${origWidth} × ${origHeight}`;

        // Perform initial resize
        resizeImage();
      };

      img.onerror = function() {
        clearTimeout(window.imageProcessTimeout);
        showProgress(false);
        processingImage = false;
        showError('Error loading image. The image might be corrupted or in an unsupported format.');
      };

      try {
        img.src = src;
      } catch (error) {
        clearTimeout(window.imageProcessTimeout);
        showProgress(false);
        processingImage = false;
        showError('Failed to process the image data.');
      }
    }

    function updateOriginalPreview() {
      if (!originalImage) return;

      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Handle rotation by adjusting canvas dimensions
        if (rotation % 180 === 0) {
          canvas.width = originalImage.width;
          canvas.height = originalImage.height;
        } else {
          canvas.width = originalImage.height;
          canvas.height = originalImage.width;
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply transformations
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
        ctx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
        ctx.restore();

        // Update preview
        originalPreview.src = canvas.toDataURL();

        // Clean up canvas
        canvas.width = 1;
        canvas.height = 1;
      } catch (error) {
        console.error('Error updating preview:', error);
        showError('Failed to update preview. Try a smaller image or reload the page.');
      }
    }

    function resizeImage() {
      if (!originalImage || processingImage) return;
      processingImage = true;
      const width = parseInt(widthInput.value) || 0;
      const height = parseInt(heightInput.value) || 0;

      if (width <= 0 && height <= 0) {
        processingImage = false;
        showError('Please enter valid dimensions');
        return;
      }

      // Optional progress indicator for large images
      if (origWidth * origHeight > 4000000) { // Over 4 megapixels
        showProgress(true);
      }

      // Use requestAnimationFrame to prevent UI blocking
      requestAnimationFrame(() => {
        try {
          const size = calculateSize(width, height);
          const format = formatSelect.value;
          const quality = parseInt(qualityInput.value) / 100;
          const fitMode = aspectRatioCheckbox.checked ? 'maintain' : fitModeSelect.value;

          // Check if WebP is supported when selected
          if (format === 'webp' && !browserSupportsWebP) {
            showError('WebP format is not supported in your browser. Using PNG instead.');
            formatSelect.value = 'png';
          }

          // Create a new canvas for the resized image
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Handle rotation by adjusting canvas dimensions
          let targetWidth = size.width;
          let targetHeight = size.height;
          if (Math.abs(rotation % 180) === 90) {
            [targetWidth, targetHeight] = [targetHeight, targetWidth];
          }

          canvas.width = targetWidth;
          canvas.height = targetHeight;

          // Clear canvas with black background (for letterbox mode)
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Apply transformations based on fit mode
          ctx.save();

          // Get source dimensions
          let sourceWidth = originalImage.width;
          let sourceHeight = originalImage.height;

          // Calculate source aspect ratio
          const sourceRatio = sourceWidth / sourceHeight;
          const targetRatio = targetWidth / targetHeight;

          // Variables for drawing the image
          let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

          if (fitMode === 'maintain' || fitMode === 'stretch') {
            // Stretch or maintain aspect ratio - full canvas drawing
            drawWidth = targetWidth;
            drawHeight = targetHeight;
          } else if (fitMode === 'crop') {
            // Crop to fill - maintain aspect ratio but crop edges
            if (sourceRatio > targetRatio) {
              // Source is wider, crop sides
              drawHeight = targetHeight;
              drawWidth = targetHeight * sourceRatio;
              offsetX = (targetWidth - drawWidth) / 2;
            } else {
              // Source is taller, crop top/bottom
              drawWidth = targetWidth;
              drawHeight = targetWidth / sourceRatio;
              offsetY = (targetHeight - drawHeight) / 2;
            }
          } else if (fitMode === 'letterbox') {
            // Add black bars - maintain aspect ratio and center
            if (sourceRatio > targetRatio) {
              // Source is wider, add black bars on top/bottom
              drawWidth = targetWidth;
              drawHeight = targetWidth / sourceRatio;
              offsetY = (targetHeight - drawHeight) / 2;
            } else {
              // Source is taller, add black bars on sides
              drawHeight = targetHeight;
              drawWidth = targetHeight * sourceRatio;
              offsetX = (targetWidth - drawWidth) / 2;
            }
          }

          // Apply rotation and flipping
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);

          // Draw the image with the calculated dimensions
          if (fitMode === 'maintain' || fitMode === 'stretch') {
            ctx.drawImage(
                    originalImage,
                    -targetWidth / 2,
                    -targetHeight / 2,
                    targetWidth,
                    targetHeight
            );
          } else {
            // For crop and letterbox, position relative to calculated offsets
            ctx.drawImage(
                    originalImage,
                    -drawWidth / 2,
                    -drawHeight / 2,
                    drawWidth,
                    drawHeight
            );
          }

          ctx.restore();

          // Rest of the function remains the same...
          let mimeType = 'image/jpeg';
          if (format === 'png') mimeType = 'image/png';
          else if (format === 'webp') mimeType = 'image/webp';
          else if (format === 'gif') mimeType = 'image/gif';

          let dataUrl;
          try {
            if (format === 'jpeg' || format === 'webp') {
              dataUrl = canvas.toDataURL(mimeType, quality);
            } else {
              dataUrl = canvas.toDataURL(mimeType);
            }

            // Update preview and download link
            resultPreview.src = dataUrl;
            downloadBtn.href = dataUrl;
            downloadBtn.download = `resized.${format}`;
            resultContainer.classList.remove('d-none');

            // Calculate file size
            fetch(dataUrl)
                    .then(res => res.blob())
                    .then(blob => {
                      const fileSize = blob.size;
                      resultOverlay.textContent = `${targetWidth} × ${targetHeight} | ${formatBytes(fileSize)}`;

                      // Check compression ratio
                      if (fileSize) {
                        const originalSize = originalImage.src.length * 0.75; // Rough estimate for base64
                        const compressionRatio = (1 - (fileSize / originalSize)) * 100;
                        if (compressionRatio > 0) {
                          resultOverlay.textContent += ` | ${compressionRatio.toFixed(0)}% smaller`;
                        }
                      }
                    })
                    .catch(err => {
                      console.error('Error calculating file size:', err);
                    })
                    .finally(() => {
                      processingImage = false;
                      showProgress(false);
                    });

            saveSettings();

            // Clean up canvas memory
            setTimeout(() => {
              canvas.width = 1;
              canvas.height = 1;
            }, 100);
          } catch (error) {
            processingImage = false;
            showProgress(false);
            console.error('Canvas operation error:', error);
            showError('Error generating image. Try a different format or smaller size.');

            // Clean up
            canvas.width = 1;
            canvas.height = 1;
          }
        } catch (error) {
          processingImage = false;
          showProgress(false);
          console.error('Resize error:', error);
          showError('Error resizing image: ' + error.message);
        }
      });
    }

    function resetForm() {
      if (processingImage) {
        showWarning('Please wait for current processing to complete');
        return;
      }

      imageInput.value = '';
      urlInput.value = '';

      if (imageLoaded) {
        // If image is loaded, reset to original dimensions
        rotation = 0;
        flipH = false;
        flipV = false;
        updateOriginalPreview();
        updateSliderRanges();
        resizeImage();
      } else {
        // Full reset
        widthInput.value = '';
        heightInput.value = '';
        widthSlider.value = 100;
        heightSlider.value = 100;
        widthPercent.checked = false;
        heightPercent.checked = false;
        originalImage = null;
        imageLoaded = false;

        originalContainer.classList.add('d-none');
        resultContainer.classList.add('d-none');
        originalInfo.innerHTML = '';
        errorContainer.innerHTML = '';
      }

      // Keep format and quality settings
      updateQualityVisibility();
    }

    // Initialize
    loadSettings();
    updateQualityVisibility();

    // Add window beforeunload warning if processing
    window.addEventListener('beforeunload', (e) => {
      if (processingImage) {
        e.preventDefault();
        e.returnValue = 'Image processing is still in progress. Are you sure you want to leave?';
        return e.returnValue;
      }
    });

    // Clean up on page visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && !imageLoaded) {
        // Clean up unused resources when tab is not visible
        resetForm();
      }
    });
  });
</script>
<script src="../logo.js"></script>
</body>
</html>