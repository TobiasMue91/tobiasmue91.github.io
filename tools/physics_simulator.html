<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fun Physics Simulator - Interactive 2D Physics Playground | GPTGames</title>
    <meta name="description" content="Experiment with an interactive physics playground. Create objects, adjust gravity, bounce, and friction to see real physics in action. Try fun presets like Newton's Cradle, Domino Effect, and Pinball.">
    <meta name="keywords" content="physics simulator, interactive physics, 2D physics, educational games, physics playground, physics experiment, matter.js">
    <meta name="author" content="Claude 3.7 Sonnet prompted by Tobias MÃ¼ller">
    <link rel="canonical" href="https://www.gptgames.dev/tools/physics_simulator.html">
    <meta property="og:title" content="Fun Physics Simulator - Interactive 2D Physics Playground">
    <meta property="og:description" content="Experiment with an interactive physics playground. Create objects, adjust gravity, bounce, and friction to see real physics in action.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_188.webp">
    <meta property="og:url" content="https://www.gptgames.dev/tools/physics_simulator.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="GPTGames.dev">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Fun Physics Simulator - Interactive 2D Physics Playground">
    <meta name="twitter:description" content="Experiment with an interactive physics playground. Create objects, adjust physics properties, and try fun presets.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_188.webp">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <meta name="robots" content="index, follow">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f5ff;
            color: #333;
            overflow: hidden;
            touch-action: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: #4a6fa5;
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .main {
            display: flex;
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            background: #fff;
            touch-action: none;
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            width: 250px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(5px);
            z-index: 5;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: #4a6fa5;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .panel-content {
            padding: 1rem;
            max-height: 80vh;
            overflow-y: auto;
        }

        .tool-btn {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 0.25rem;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tool-btn.active {
            background: #e6f0ff;
            border-color: #4a6fa5;
        }

        .tool-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .tools-container {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .property-group {
            margin-bottom: 1rem;
        }

        .property-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #4a6fa5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .slider-label {
            width: 80px;
            font-size: 0.8rem;
        }

        .slider {
            flex: 1;
        }

        .presets-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .preset-btn {
            background: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }

        .preset-btn:hover {
            background: #3a5985;
        }

        .btn {
            background: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.3rem 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3a5985;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
        }

        .minimize-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .info-overlay {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .panel-minimized {
            width: auto;
        }

        .panel-minimized .panel-content {
            display: none;
        }

        .object-counter {
            font-size: 0.8rem;
            color: #666;
        }

        .toast {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .toast.visible {
            opacity: 1;
        }

        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .tutorial-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tutorial-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #4a6fa5;
        }

        .tutorial-content {
            margin-bottom: 1rem;
        }

        .tutorial-step {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.8rem;
            align-items: center;
        }

        .step-icon {
            font-size: 1.5rem;
            color: #4a6fa5;
            min-width: 30px;
            text-align: center;
        }

        .close-tutorial {
            display: block;
            margin: 1rem auto 0;
            padding: 0.5rem 1.5rem;
        }

        @media (max-width: 768px) {
            .ui-panel {
                width: 200px;
            }

            .panel-header {
                font-size: 0.9rem;
            }

            .tool-btn {
                padding: 0.3rem;
            }

            h1 {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .ui-panel:not(.panel-minimized) {
                width: 100%;
                right: 0;
                top: 0;
                border-radius: 0;
            }

            .panel-header {
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Fun Physics Simulator</h1>
        <div class="btn-group">
            <button id="play-pause" class="btn">Pause</button>
            <button id="reset" class="btn">Reset</button>
            <button id="show-tutorial" class="btn">Help</button>
        </div>
    </header>
    <div class="main">
        <canvas id="canvas"></canvas>
        <div class="ui-panel" id="ui-panel">
            <div class="panel-header">
                <span>Tools & Controls</span>
                <button class="minimize-btn" id="minimize-panel">-</button>
            </div>
            <div class="panel-content">
                <div class="property-group">
                    <div class="property-title">Create Objects <span class="object-counter" id="object-counter">0 objects</span>
                    </div>
                    <div class="tools-container">
                        <button class="tool-btn active" id="tool-circle">
                            <div class="tool-icon">â</div>
                            Circle
                        </button>
                        <button class="tool-btn" id="tool-rectangle">
                            <div class="tool-icon">â </div>
                            Rectangle
                        </button>
                        <button class="tool-btn" id="tool-polygon">
                            <div class="tool-icon">â¬¢</div>
                            Polygon
                        </button>
                        <button class="tool-btn" id="tool-drag">
                            <div class="tool-icon">â</div>
                            Drag
                        </button>
                    </div>
                </div>
                <div class="property-group">
                    <div class="property-title">Physics Properties</div>
                    <div class="slider-container">
                        <div class="slider-label">Gravity</div>
                        <input type="range" min="0" max="2" step="0.1" value="1" class="slider" id="gravity-slider">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">Bounce</div>
                        <input type="range" min="0" max="1" step="0.1" value="0.6" class="slider" id="bounce-slider">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">Friction</div>
                        <input type="range" min="0" max="1" step="0.1" value="0.1" class="slider" id="friction-slider">
                    </div>
                </div>
                <div class="property-group">
                    <div class="property-title">Fun Presets</div>
                    <div class="presets-container">
                        <button class="preset-btn" id="preset-domino">Domino Effect</button>
                        <button class="preset-btn" id="preset-newton">Newton's Cradle</button>
                        <button class="preset-btn" id="preset-tower">Tower Stack</button>
                        <button class="preset-btn" id="preset-slingshot">Slingshot</button>
                        <button class="preset-btn" id="preset-pinball">Pinball</button>
                        <button class="preset-btn" id="preset-pool">Pool Break</button>
                    </div>
                </div>
                <div class="property-group">
                    <button class="btn" id="clear-all" style="width:100%">Clear All Objects</button>
                </div>
            </div>
        </div>
        <div class="info-overlay" id="info-overlay">Click and drag to create objects</div>
    </div>
</div>

<div class="toast" id="toast"></div>

<div class="tutorial-overlay" id="tutorial-overlay" style="display: none;">
    <div class="tutorial-card">
        <div class="tutorial-title">How to Use the Physics Simulator</div>
        <div class="tutorial-content">
            <div class="tutorial-step">
                <div class="step-icon">â</div>
                <div>Select a shape tool (Circle, Rectangle, Polygon) and drag on the canvas to create objects of
                    different sizes.
                </div>
            </div>
            <div class="tutorial-step">
                <div class="step-icon">â</div>
                <div>Use the Drag tool to move objects around. Click and drag to fling objects across the screen!</div>
            </div>
            <div class="tutorial-step">
                <div class="step-icon">âï¸</div>
                <div>Adjust physics properties like gravity, bounce, and friction to see how they affect the
                    simulation.
                </div>
            </div>
            <div class="tutorial-step">
                <div class="step-icon">ð®</div>
                <div>Try the preset scenarios for instant fun physics experiments!</div>
            </div>
            <div class="tutorial-step">
                <div class="step-icon">â¸ï¸</div>
                <div>Use Pause to freeze the simulation and Reset to start over.</div>
            </div>
        </div>
        <button class="btn close-tutorial" id="close-tutorial">Got it!</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
    // Physics simulation with Matter.js
    const PhysicsSimulator = (function () {
        // Matter.js modules
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Body = Matter.Body,
            Composite = Matter.Composite,
            MouseConstraint = Matter.MouseConstraint,
            Mouse = Matter.Mouse,
            Events = Matter.Events,
            Constraint = Matter.Constraint,
            Vector = Matter.Vector,
            Common = Matter.Common;

        // Simulation variables
        let engine, render, runner, world, canvas, mouseConstraint, mouse;
        let currentTool = 'circle';
        let isCreating = false;
        let creationStart = null;
        let currentBody = null;
        let isPaused = false;
        let defaultRestitution = 0.6;
        let defaultFriction = 0.1;
        let isMobile = 'ontouchstart' in window;

        // DOM elements
        const canvasContainer = document.querySelector('.main');
        const infoOverlay = document.getElementById('info-overlay');
        const objectCounter = document.getElementById('object-counter');
        const toast = document.getElementById('toast');

        // Initialize the simulation
        function init() {
            // Create engine with better precision for small objects
            engine = Engine.create({
                positionIterations: 8,
                velocityIterations: 8
            });
            world = engine.world;

            // Setup canvas to fill available space
            canvas = document.getElementById('canvas');
            canvas.width = canvasContainer.offsetWidth;
            canvas.height = canvasContainer.offsetHeight;

            // Create renderer with better settings
            render = Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: canvas.width,
                    height: canvas.height,
                    wireframes: false,
                    background: '#ffffff',
                    showAngleIndicator: false,
                    pixelRatio: window.devicePixelRatio
                }
            });

            // Create runner with fixed timestep for consistent simulation
            runner = Runner.create({
                isFixed: true,
                delta: 1000 / 60
            });

            // Add walls to contain the simulation
            addWalls();

            // Setup mouse/touch control
            setupMouseControl();

            // Start the engine and renderer
            Render.run(render);
            Runner.run(runner, engine);

            // Setup event listeners
            setupEventListeners();

            // Initial gravity setting
            engine.world.gravity.y = 1;

            // Add some objects on startup
            addInitialObjects();

            // Setup Matter.js events for better interaction feedback
            setupEvents();

            // Maybe show the tutorial on first load
            if (!localStorage.getItem('tutorialSeen')) {
                document.getElementById('tutorial-overlay').style.display = 'flex';
                localStorage.setItem('tutorialSeen', 'true');
            }

            // Update object counter initially
            updateObjectCounter();
        }

        // Setup Matter.js events
        function setupEvents() {
            // Add hover effects to objects
            Events.on(mouseConstraint, 'mousemove', function (event) {
                const mousePosition = event.mouse.position;
                const hoveredBody = Matter.Query.point(Composite.allBodies(world), mousePosition)[0];

                // Reset all body colors to their original
                const allBodies = Composite.allBodies(world);
                for (let i = 0; i < allBodies.length; i++) {
                    const body = allBodies[i];
                    if (body.isStatic && body.render.fillStyle === '#e0e0e0') continue; // Skip walls

                    if (body.originalColor && body !== hoveredBody) {
                        body.render.fillStyle = body.originalColor;
                        body.render.lineWidth = 0;
                    }
                }

                // Highlight hovered body
                if (hoveredBody && !hoveredBody.isStatic && currentTool === 'drag') {
                    if (!hoveredBody.originalColor) {
                        hoveredBody.originalColor = hoveredBody.render.fillStyle;
                    }
                    hoveredBody.render.lineWidth = 2;
                    hoveredBody.render.strokeStyle = '#4a6fa5';
                }
            });

            // Track when objects are being dragged
            Events.on(mouseConstraint, 'startdrag', function (event) {
                const body = event.body;
                if (!body.originalColor) {
                    body.originalColor = body.render.fillStyle;
                }
                body.render.fillStyle = lightenColor(body.originalColor, 20);
            });

            Events.on(mouseConstraint, 'enddrag', function (event) {
                const body = event.body;
                if (body.originalColor) {
                    body.render.fillStyle = body.originalColor;
                }
            });

            // Update object counter when bodies are added or removed
            Events.on(engine.world, 'afterAdd', updateObjectCounter);
            Events.on(engine.world, 'afterRemove', updateObjectCounter);
        }

        // Add walls to contain the simulation
        function addWalls() {
            const wallOptions = {
                isStatic: true,
                render: {fillStyle: '#e0e0e0'},
                friction: 0.1,
                restitution: 0.3
            };

            // Ground
            const ground = Bodies.rectangle(
                canvas.width / 2,
                canvas.height,
                canvas.width + 100,
                50,
                wallOptions
            );

            // Left wall
            const leftWall = Bodies.rectangle(
                -25,
                canvas.height / 2,
                50,
                canvas.height + 100,
                wallOptions
            );

            // Right wall
            const rightWall = Bodies.rectangle(
                canvas.width + 25,
                canvas.height / 2,
                50,
                canvas.height + 100,
                wallOptions
            );

            // Add all walls to the world
            Composite.add(world, [ground, leftWall, rightWall]);
        }

        // Setup mouse/touch control
        function setupMouseControl() {
            // Create mouse/touch input
            mouse = Mouse.create(render.canvas);

            // Configure mouse constraint with proper settings
            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });

            // Fix for mouse position offset with high DPI screens
            mouse.pixelRatio = render.options.pixelRatio;

            // Add mouse constraint to world
            Composite.add(world, mouseConstraint);

            // Sync mouse with renderer
            render.mouse = mouse;

            // Start with mouse constraint disabled (since we start with circle tool)
            mouseConstraint.enabled = false;
        }

        // Add some initial objects for better first impression
        function addInitialObjects() {
            const colors = ['#FF6B6B', '#4ECDC4', '#556270', '#C7F464', '#FF8C42'];

            // Add some random shapes
            for (let i = 0; i < 5; i++) {
                const x = canvas.width * (0.3 + Math.random() * 0.4);
                const y = canvas.height * (0.2 + Math.random() * 0.3);
                const color = colors[Math.floor(Math.random() * colors.length)];

                let body;
                const type = Math.floor(Math.random() * 3);

                const options = {
                    restitution: defaultRestitution,
                    friction: defaultFriction,
                    render: {fillStyle: color}
                };

                switch (type) {
                    case 0: // Circle
                        body = Bodies.circle(x, y, 20 + Math.random() * 20, options);
                        break;
                    case 1: // Rectangle
                        body = Bodies.rectangle(x, y, 30 + Math.random() * 30, 30 + Math.random() * 30, options);
                        break;
                    case 2: // Polygon
                        body = Bodies.polygon(x, y, 5 + Math.floor(Math.random() * 3), 20 + Math.random() * 15, options);
                        break;
                }

                body.originalColor = color;
                Composite.add(world, body);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Canvas interactions - handle both mouse and touch events
            if (isMobile) {
                canvas.addEventListener('touchstart', handleTouchStart);
                canvas.addEventListener('touchmove', handleTouchMove);
                canvas.addEventListener('touchend', handleTouchEnd);
            } else {
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
            }

            // Tool buttons
            document.getElementById('tool-circle').addEventListener('click', () => setTool('circle'));
            document.getElementById('tool-rectangle').addEventListener('click', () => setTool('rectangle'));
            document.getElementById('tool-polygon').addEventListener('click', () => setTool('polygon'));
            document.getElementById('tool-drag').addEventListener('click', () => setTool('drag'));

            // Physics controls
            document.getElementById('gravity-slider').addEventListener('input', (e) => {
                engine.world.gravity.y = parseFloat(e.target.value);
            });

            document.getElementById('bounce-slider').addEventListener('input', (e) => {
                defaultRestitution = parseFloat(e.target.value);
            });

            document.getElementById('friction-slider').addEventListener('input', (e) => {
                defaultFriction = parseFloat(e.target.value);
            });

            // Buttons
            document.getElementById('play-pause').addEventListener('click', togglePause);
            document.getElementById('reset').addEventListener('click', resetSimulation);
            document.getElementById('clear-all').addEventListener('click', clearAll);

            // Panel minimize
            document.getElementById('minimize-panel').addEventListener('click', togglePanel);

            // Tutorial
            document.getElementById('show-tutorial').addEventListener('click', showTutorial);
            document.getElementById('close-tutorial').addEventListener('click', closeTutorial);

            // Presets
            document.getElementById('preset-domino').addEventListener('click', () => loadPreset(createDominoEffect, 'Domino Effect loaded! Watch the chain reaction.'));
            document.getElementById('preset-newton').addEventListener('click', () => loadPreset(createNewtonsCradle, 'Newton\'s Cradle loaded! Physics in action.'));
            document.getElementById('preset-tower').addEventListener('click', () => loadPreset(createTowerStack, 'Tower Stack loaded! Can you make it taller?'));
            document.getElementById('preset-slingshot').addEventListener('click', () => loadPreset(createSlingshot, 'Slingshot loaded! Drag the ball and release to fire.'));
            document.getElementById('preset-pinball').addEventListener('click', () => loadPreset(createPinball, 'Pinball loaded! Bounce the ball around!'));
            document.getElementById('preset-pool').addEventListener('click', () => loadPreset(createPoolBreak, 'Pool Break loaded! Make a perfect shot!'));

            // Window resize
            window.addEventListener('resize', handleResize);

            // Prevent pinch-to-zoom on mobile
            document.addEventListener('touchmove', function (e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, {passive: false});
        }

        // Handle mouse events
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / render.options.pixelRatio;
            const y = (e.clientY - rect.top) / render.options.pixelRatio;

            if (currentTool === 'drag') {
                mouseConstraint.enabled = true;
                return;
            }

            mouseConstraint.enabled = false;
            creationStart = {x, y};
            isCreating = true;
            createTemporaryObject(x, y);
        }

        function handleMouseMove(e) {
            if (!isCreating || currentTool === 'drag') return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / render.options.pixelRatio;
            const y = (e.clientY - rect.top) / render.options.pixelRatio;

            updateTemporaryObject(x, y);
            updateInfoOverlay({x, y});
        }

        function handleMouseUp(e) {
            if (currentTool === 'drag') {
                return;
            }

            if (!isCreating) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / render.options.pixelRatio;
            const y = (e.clientY - rect.top) / render.options.pixelRatio;

            finishObjectCreation(x, y);

            isCreating = false;
            creationStart = null;
            currentBody = null;

            infoOverlay.textContent = 'Click and drag to create objects';
        }

        // Handle touch events
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length !== 1) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / render.options.pixelRatio;
            const y = (touch.clientY - rect.top) / render.options.pixelRatio;

            if (currentTool === 'drag') {
                mouseConstraint.enabled = true;
                return;
            }

            mouseConstraint.enabled = false;
            creationStart = {x, y};
            isCreating = true;
            createTemporaryObject(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length !== 1 || !isCreating || currentTool === 'drag') return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / render.options.pixelRatio;
            const y = (touch.clientY - rect.top) / render.options.pixelRatio;

            updateTemporaryObject(x, y);
            updateInfoOverlay({x, y});
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (currentTool === 'drag') {
                return;
            }

            if (!isCreating) return;

            // Use the last known position for touch end
            const x = creationStart.x + 100; // Add some size by default for touch
            const y = creationStart.y + 100;

            finishObjectCreation(x, y);

            isCreating = false;
            creationStart = null;
            currentBody = null;

            infoOverlay.textContent = 'Tap and drag to create objects';
        }

        // Create a temporary object during creation
        function createTemporaryObject(x, y) {
            // Remove any existing temporary object
            if (currentBody) {
                Composite.remove(world, currentBody);
            }

            const options = {
                restitution: defaultRestitution,
                friction: defaultFriction,
                render: {fillStyle: getRandomColor()},
                isStatic: true
            };

            switch (currentTool) {
                case 'circle':
                    currentBody = Bodies.circle(x, y, 5, options);
                    break;
                case 'rectangle':
                    currentBody = Bodies.rectangle(x, y, 10, 10, options);
                    break;
                case 'polygon':
                    currentBody = Bodies.polygon(x, y, 6, 5, options);
                    break;
            }

            currentBody.originalColor = options.render.fillStyle;
            Composite.add(world, currentBody);
        }

        // Update the temporary object during creation
        function updateTemporaryObject(x, y) {
            if (!currentBody) return;

            const width = Math.abs(x - creationStart.x);
            const height = Math.abs(y - creationStart.y);
            const centerX = (x + creationStart.x) / 2;
            const centerY = (y + creationStart.y) / 2;

            // Remove the previous temporary object
            Composite.remove(world, currentBody);

            const options = {
                restitution: defaultRestitution,
                friction: defaultFriction,
                render: {fillStyle: currentBody.originalColor},
                isStatic: true
            };

            switch (currentTool) {
                case 'circle':
                    const radius = Math.max(5, Math.sqrt(width * width + height * height) / 2);
                    currentBody = Bodies.circle(creationStart.x, creationStart.y, radius, options);
                    break;
                case 'rectangle':
                    currentBody = Bodies.rectangle(centerX, centerY, Math.max(10, width), Math.max(10, height), options);
                    break;
                case 'polygon':
                    const size = Math.max(5, Math.sqrt(width * width + height * height) / 2);
                    currentBody = Bodies.polygon(creationStart.x, creationStart.y, 6, size, options);
                    break;
            }

            currentBody.originalColor = options.render.fillStyle;
            Composite.add(world, currentBody);
        }

        // Finish creating an object
        function finishObjectCreation(x, y) {
            if (!currentBody) return;

            // Remove the temporary static object
            Composite.remove(world, currentBody);

            const width = Math.abs(x - creationStart.x);
            const height = Math.abs(y - creationStart.y);
            const centerX = (x + creationStart.x) / 2;
            const centerY = (y + creationStart.y) / 2;

            // Don't create if too small
            if (width < 5 && height < 5) return;

            const options = {
                restitution: defaultRestitution,
                friction: defaultFriction,
                render: {fillStyle: currentBody.originalColor},
                isStatic: false
            };

            let newBody;

            switch (currentTool) {
                case 'circle':
                    const radius = Math.max(5, Math.sqrt(width * width + height * height) / 2);
                    newBody = Bodies.circle(creationStart.x, creationStart.y, radius, options);
                    break;
                case 'rectangle':
                    newBody = Bodies.rectangle(centerX, centerY, Math.max(10, width), Math.max(10, height), options);
                    break;
                case 'polygon':
                    const size = Math.max(5, Math.sqrt(width * width + height * height) / 2);
                    newBody = Bodies.polygon(creationStart.x, creationStart.y, 6, size, options);
                    break;
            }

            newBody.originalColor = options.render.fillStyle;
            Composite.add(world, newBody);

            // Add a little bounce for fun
            Body.setVelocity(newBody, {x: (Math.random() - 0.5) * 2, y: -1});
        }

        // Set the current tool
        function setTool(tool) {
            currentTool = tool;

            // Update tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tool-${tool}`).classList.add('active');

            // Update mouse constraint based on the tool
            mouseConstraint.enabled = tool === 'drag';

            // Update info text
            if (tool === 'drag') {
                infoOverlay.textContent = isMobile ?
                    'Tap and drag objects to move them' :
                    'Click and drag objects to move them';
            } else {
                infoOverlay.textContent = isMobile ?
                    'Tap and drag to create objects' :
                    'Click and drag to create objects';
            }
        }

        // Load a preset with visual feedback
        function loadPreset(presetFunction, message) {
            // Store mouse constraint reference
            const mousePos = {...mouse.position};

            // Run the preset function
            presetFunction();

            // Show a toast message
            showToast(message);

            // Ensure mouseConstraint is in the world - this is the key fix!
            if (!Composite.get(world, mouseConstraint.id, 'mouseConstraint')) {
                Composite.add(world, mouseConstraint);
            }

            // Make sure drag tool is set correctly after preset loads
            if (currentTool === 'drag') {
                mouseConstraint.enabled = true;
            } else {
                mouseConstraint.enabled = false;
            }
        }

        // Show a toast notification
        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('visible');

            setTimeout(() => {
                toast.classList.remove('visible');
            }, 3000);
        }

        // Toggle pause state
        function togglePause() {
            isPaused = !isPaused;

            if (isPaused) {
                Runner.stop(runner);
                document.getElementById('play-pause').textContent = 'Play';
            } else {
                Runner.run(runner, engine);
                document.getElementById('play-pause').textContent = 'Pause';
            }
        }

        // Reset the simulation
        function resetSimulation() {
            // Store mouse constraint to prevent it from being removed
            const mouseConstraintId = mouseConstraint.id;

            // Clear all non-static bodies
            clearBodies();

            // Reset physics properties
            document.getElementById('gravity-slider').value = 1;
            document.getElementById('bounce-slider').value = 0.6;
            document.getElementById('friction-slider').value = 0.1;

            engine.world.gravity.y = 1;
            defaultRestitution = 0.6;
            defaultFriction = 0.1;

            // Add initial objects
            addInitialObjects();

            // Ensure the simulation is running
            if (isPaused) {
                togglePause();
            }

            // Reset to circle tool
            setTool('circle');

            showToast('Simulation reset!');
        }

        // Clear all bodies except walls
        function clearAll() {
            clearBodies();
            showToast('All objects cleared!');
        }

        // Clear bodies except walls and mouse constraint
        function clearBodies() {
            // Store the mouseConstraint id to avoid removing it
            const mouseConstraintId = mouseConstraint.id;

            // Remove bodies but keep static walls
            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (!body.isStatic || body.label === 'pendulum' || body.label === 'slingshot') {
                    Composite.remove(world, body);
                }
            }

            // Remove constraints except mouseConstraint
            const constraints = Composite.allConstraints(world);
            for (let i = 0; i < constraints.length; i++) {
                const constraint = constraints[i];
                if (constraint.id !== mouseConstraintId) {
                    Composite.remove(world, constraint);
                }
            }

            // Ensure mouseConstraint is still in the world
            if (!Composite.get(world, mouseConstraintId, 'mouseConstraint')) {
                Composite.add(world, mouseConstraint);
            }
        }

        // Toggle panel state
        function togglePanel() {
            const panel = document.getElementById('ui-panel');
            const button = document.getElementById('minimize-panel');

            panel.classList.toggle('panel-minimized');

            if (panel.classList.contains('panel-minimized')) {
                button.textContent = '+';
            } else {
                button.textContent = '-';
            }
        }

        // Handle window resize
        function handleResize() {
            // Store mouseConstraint id
            const mouseConstraintId = mouseConstraint.id;

            // Get new dimensions
            canvas.width = canvasContainer.offsetWidth;
            canvas.height = canvasContainer.offsetHeight;

            // Update renderer size
            render.options.width = canvas.width;
            render.options.height = canvas.height;
            render.options.pixelRatio = window.devicePixelRatio || 1;

            // Update mouse scaling
            if (mouse) {
                mouse.pixelRatio = render.options.pixelRatio;
            }

            // Update walls
            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.isStatic && body.render.fillStyle === '#e0e0e0') {
                    Composite.remove(world, body);
                }
            }

            addWalls();

            // Ensure mouseConstraint is still in the world
            if (!Composite.get(world, mouseConstraintId, 'mouseConstraint')) {
                Composite.add(world, mouseConstraint);
            }
        }

        // Update info overlay during creation
        function updateInfoOverlay(currentPos) {
            if (!creationStart) return;

            const width = Math.abs(currentPos.x - creationStart.x);
            const height = Math.abs(currentPos.y - creationStart.y);

            switch (currentTool) {
                case 'circle':
                    const radius = Math.sqrt(width * width + height * height) / 2;
                    infoOverlay.textContent = `Circle: Radius ${Math.round(radius)}px`;
                    break;
                case 'rectangle':
                    infoOverlay.textContent = `Rectangle: ${Math.round(width)}px Ã ${Math.round(height)}px`;
                    break;
                case 'polygon':
                    const size = Math.sqrt(width * width + height * height) / 2;
                    infoOverlay.textContent = `Hexagon: Size ${Math.round(size)}px`;
                    break;
            }
        }

        // Generate a random color for new objects
        function getRandomColor() {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#556270', '#C7F464',
                '#FF8C42', '#A3A948', '#69D2E7', '#F38630',
                '#E0E4CC', '#FA6900', '#C02942', '#542437'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Create domino effect preset
        function createDominoEffect() {
            clearBodies();

            const dominoOptions = {
                restitution: 0.1,
                friction: 0.1,
                render: {fillStyle: '#556270'}
            };

            // Create a row of dominoes
            const dominoWidth = 10;
            const dominoHeight = 60;
            const spacing = 30;
            const startX = canvas.width * 0.2;
            const startY = canvas.height - 60;

            for (let i = 0; i < 10; i++) {
                const domino = Bodies.rectangle(
                    startX + i * spacing,
                    startY - dominoHeight / 2,
                    dominoWidth,
                    dominoHeight,
                    dominoOptions
                );
                domino.originalColor = dominoOptions.render.fillStyle;
                Composite.add(world, domino);
            }

            // Create a ball to knock them over
            const ball = Bodies.circle(
                startX - 50,
                startY - 100,
                20,
                {restitution: 0.6, render: {fillStyle: '#FF6B6B'}}
            );
            ball.originalColor = '#FF6B6B';

            // Give the ball an initial velocity
            Body.setVelocity(ball, {x: 4, y: -2});

            Composite.add(world, ball);

            // Ensure drag tool is active after creating preset
            setTool('drag');
        }

        // Create Newton's cradle preset
        function createNewtonsCradle() {
            clearBodies();

            const cradleWidth = Math.min(canvas.width * 0.8, 500);
            const cradleHeight = Math.min(canvas.height * 0.7, 400);
            const ballRadius = Math.min(canvas.width * 0.03, 30);

            const cradle = Matter.Composites.newtonsCradle(
                canvas.width / 2 - cradleWidth / 4,
                canvas.height / 4,
                5,
                ballRadius,
                cradleHeight * 0.7
            );

            // Customize colors
            cradle.bodies.forEach((body, index) => {
                const color = getRandomColor();
                body.render.fillStyle = color;
                body.originalColor = color;
            });

            Composite.add(world, cradle);

            // Pull back the first ball
            Body.translate(cradle.bodies[0], {x: -ballRadius * 4, y: -ballRadius});

            // Ensure drag tool is active after creating preset
            setTool('drag');
        }

        // Create tower stack preset
        function createTowerStack() {
            clearBodies();

            const boxOptions = {
                restitution: 0.1,
                friction: 0.6
            };

            // Create a pyramid stack
            const stackSize = Math.min(8, Math.floor(canvas.width / 70));
            const size = Math.min(canvas.width * 0.04, 30);
            const startX = canvas.width / 2 - (size * stackSize) / 2;
            const startY = canvas.height - 50;

            // Build from bottom up
            for (let row = 0; row < stackSize; row++) {
                const numBoxes = stackSize - row;
                for (let col = 0; col < numBoxes; col++) {
                    const color = getRandomColor();
                    const box = Bodies.rectangle(
                        startX + (col * size) + (row * size / 2),
                        startY - (row * size),
                        size,
                        size,
                        {
                            ...boxOptions,
                            render: {fillStyle: color}
                        }
                    );
                    box.originalColor = color;
                    Composite.add(world, box);
                }
            }

            // Ensure drag tool is active after creating preset
            setTool('drag');
        }

        // Create slingshot preset
        function createSlingshot() {
            clearBodies();

            // Create a slingshot anchor point
            const anchor = {x: canvas.width / 3, y: canvas.height / 2};

            // Create the projectile
            const projectile = Bodies.circle(
                anchor.x,
                anchor.y,
                25,
                {
                    label: 'slingshot',
                    restitution: 0.8,
                    friction: 0.01,
                    render: {fillStyle: '#FF6B6B'}
                }
            );
            projectile.originalColor = '#FF6B6B';

            // Create elastic constraint
            const elastic = Constraint.create({
                pointA: anchor,
                bodyB: projectile,
                stiffness: 0.01,
                damping: 0.1,
                render: {
                    lineWidth: 3,
                    strokeStyle: '#556270'
                }
            });

            // Create some targets
            const targetOptions = {
                restitution: 0.3,
                friction: 0.1
            };

            const targetColors = ['#4ECDC4', '#C7F464', '#A3A948', '#F38630', '#FA6900'];

            for (let i = 0; i < 5; i++) {
                const color = targetColors[i % targetColors.length];
                const target = Bodies.rectangle(
                    canvas.width * 0.7 + (i % 2) * 40,
                    canvas.height * 0.4 + i * 40,
                    40,
                    40,
                    {
                        ...targetOptions,
                        render: {fillStyle: color}
                    }
                );
                target.originalColor = color;
                Composite.add(world, target);
            }

            Composite.add(world, [projectile, elastic]);

            // Set tool to drag and ensure mouse constraint is active
            setTool('drag');
        }

        // Create pinball preset
        function createPinball() {
            clearBodies();

            // Add bumpers
            const bumperRadius = Math.min(30, canvas.width * 0.05);
            const bumperOptions = {
                isStatic: true,
                restitution: 1.5,
                friction: 0.01,
                render: {fillStyle: '#FA6900'}
            };

            const bumperPositions = [
                {x: canvas.width * 0.3, y: canvas.height * 0.3},
                {x: canvas.width * 0.7, y: canvas.height * 0.3},
                {x: canvas.width * 0.5, y: canvas.height * 0.5},
                {x: canvas.width * 0.3, y: canvas.height * 0.7},
                {x: canvas.width * 0.7, y: canvas.height * 0.7}
            ];

            bumperPositions.forEach(pos => {
                const bumper = Bodies.circle(pos.x, pos.y, bumperRadius, bumperOptions);
                Composite.add(world, bumper);
            });

            // Add ball
            const ball = Bodies.circle(
                canvas.width * 0.5,
                canvas.height * 0.1,
                15,
                {
                    restitution: 0.9,
                    friction: 0.01,
                    render: {fillStyle: '#4ECDC4'}
                }
            );
            ball.originalColor = '#4ECDC4';

            Composite.add(world, ball);

            // Add flippers
            const flipperLength = Math.min(100, canvas.width * 0.15);
            const flipperHeight = 15;

            const leftFlipper = Bodies.rectangle(
                canvas.width * 0.3,
                canvas.height * 0.85,
                flipperLength,
                flipperHeight,
                {
                    label: 'flipper',
                    restitution: 0.3,
                    render: {fillStyle: '#FF6B6B'}
                }
            );

            const rightFlipper = Bodies.rectangle(
                canvas.width * 0.7,
                canvas.height * 0.85,
                flipperLength,
                flipperHeight,
                {
                    label: 'flipper',
                    restitution: 0.3,
                    render: {fillStyle: '#FF6B6B'}
                }
            );

            const leftPivot = Bodies.circle(
                canvas.width * 0.3 - flipperLength / 2 + 5,
                canvas.height * 0.85,
                5,
                {isStatic: true, render: {visible: false}}
            );

            const rightPivot = Bodies.circle(
                canvas.width * 0.7 + flipperLength / 2 - 5,
                canvas.height * 0.85,
                5,
                {isStatic: true, render: {visible: false}}
            );

            const leftConstraint = Constraint.create({
                bodyA: leftFlipper,
                pointA: {x: -flipperLength / 2 + 5, y: 0},
                bodyB: leftPivot,
                pointB: {x: 0, y: 0},
                stiffness: 1,
                render: {visible: false}
            });

            const rightConstraint = Constraint.create({
                bodyA: rightFlipper,
                pointA: {x: flipperLength / 2 - 5, y: 0},
                bodyB: rightPivot,
                pointB: {x: 0, y: 0},
                stiffness: 1,
                render: {visible: false}
            });

            Composite.add(world, [
                leftFlipper, rightFlipper,
                leftPivot, rightPivot,
                leftConstraint, rightConstraint
            ]);

            // Ensure drag tool is active
            setTool('drag');

            // Show instruction
            showToast('Click and drag the ball! Try to hit all the bumpers!');
        }

        // Create pool break preset
        function createPoolBreak() {
            clearBodies();

            // Set low gravity
            engine.world.gravity.y = 0;
            document.getElementById('gravity-slider').value = 0;

            // Pool table settings
            const tableWidth = canvas.width * 0.8;
            const tableHeight = canvas.height * 0.7;
            const tableLeft = (canvas.width - tableWidth) / 2;
            const tableTop = (canvas.height - tableHeight) / 2;

            // Add table walls
            const wallOptions = {
                isStatic: true,
                restitution: 0.9,
                friction: 0.1,
                render: {fillStyle: '#2F4858'}
            };

            // Top, Bottom, Left, Right walls
            const walls = [
                Bodies.rectangle(canvas.width / 2, tableTop, tableWidth, 20, wallOptions),
                Bodies.rectangle(canvas.width / 2, tableTop + tableHeight, tableWidth, 20, wallOptions),
                Bodies.rectangle(tableLeft, tableTop + tableHeight / 2, 20, tableHeight, wallOptions),
                Bodies.rectangle(tableLeft + tableWidth, tableTop + tableHeight / 2, 20, tableHeight, wallOptions)
            ];

            Composite.add(world, walls);

            // Add pool balls
            const ballRadius = 15;
            const ballOptions = {
                restitution: 0.9,
                friction: 0.1,
                frictionAir: 0.01,
                density: 0.8
            };

            // Colors for the balls
            const ballColors = [
                '#FF6B6B', '#FFE66D', '#4ECDC4', '#1A535C',
                '#F7B267', '#F25F5C', '#A393BF', '#779FA1',
                '#E0E4CC', '#FF8C42', '#062F4F', '#813772',
                '#2274A5', '#32936F', '#26408B'
            ];

            // Create triangle rack of balls
            const startX = canvas.width / 2 + tableWidth / 4;
            const startY = canvas.height / 2;
            const rows = 5;
            let ballIndex = 0;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col <= row; col++) {
                    const x = startX + (row * 2 * ballRadius * 1.05);
                    const y = startY - (row * ballRadius) + (col * 2 * ballRadius);

                    const ball = Bodies.circle(
                        x, y, ballRadius,
                        {
                            ...ballOptions,
                            render: {
                                fillStyle: ballColors[ballIndex % ballColors.length],
                                strokeStyle: '#000',
                                lineWidth: 1
                            }
                        }
                    );
                    ball.originalColor = ballColors[ballIndex % ballColors.length];
                    Composite.add(world, ball);
                    ballIndex++;
                }
            }

            // Add cue ball
            const cueBall = Bodies.circle(
                tableLeft + tableWidth / 4,
                canvas.height / 2,
                ballRadius,
                {
                    ...ballOptions,
                    render: {fillStyle: '#fff'}
                }
            );
            cueBall.originalColor = '#fff';
            Composite.add(world, cueBall);

            // Set drag tool active
            setTool('drag');

            // Show instruction
            showToast('Drag the white cue ball to break the rack!');
        }

        // Show tutorial
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        // Close tutorial
        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
        }

        // Update object counter
        function updateObjectCounter() {
            const bodies = Composite.allBodies(world);
            let count = 0;

            for (let i = 0; i < bodies.length; i++) {
                if (!bodies[i].isStatic || bodies[i].label === 'pendulum' || bodies[i].label === 'slingshot' || bodies[i].label === 'flipper') {
                    count++;
                }
            }

            objectCounter.textContent = count === 1 ? '1 object' : `${count} objects`;
        }

        // Utility to lighten a color for hover effects
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;

            return "#" + (
                0x1000000 +
                (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
                (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
                (B < 255 ? (B < 1 ? 0 : B) : 255)
            ).toString(16).slice(1);
        }

        // Public API
        return {
            init: init
        };
    })();

    // Initialize the simulator when the page loads
    window.addEventListener('load', PhysicsSimulator.init);
</script>
<script src="../logo.js"></script>
</body>
</html>