<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Chain Reaction - An addictive click game where you create explosive chain reactions. Click circles before they expire to trigger massive cascading combos. Features 4 unique zones, power-ups, and progressive difficulty.">
    <meta name="keywords" content="chain reaction game, clicking game, arcade game, browser game, HTML5 game, casual game, reaction game, combo game, free online game">
    <meta name="author" content="Claude Sonnet 4.5 prompted by Tobias Müller">
    <meta property="og:title" content="Chain Reaction - Explosive Combo Game">
    <meta property="og:description" content="Create massive chain reactions in this addictive clicking game. Features 4 zones, multiple circle types, power-ups, and endless progression. How high can you combo?">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_227.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/chain_reaction.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Chain Reaction - Explosive Combo Game">
    <meta name="twitter:description" content="Create massive chain reactions in this addictive clicking game. Features 4 zones, multiple circle types, power-ups, and endless progression.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_227.webp">
    <link rel="canonical" href="https://www.gptgames.dev/games/chain_reaction.html">
    <title>Chain Reaction</title>
    <style>* {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #0f0f0f;
        color: #fff;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        user-select: none
    }

    #gameCanvas {
        display: block;
        background: #1a1a1a;
        transition: box-shadow 0.5s;
        cursor: crosshair
    }

    #gameCanvas.zone-1 {
        box-shadow: 0 0 40px rgba(0, 217, 255, 0.4)
    }

    #gameCanvas.zone-2 {
        box-shadow: 0 0 40px rgba(147, 51, 234, 0.4)
    }

    #gameCanvas.zone-3 {
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.4)
    }

    #gameCanvas.zone-4 {
        box-shadow: 0 0 40px rgba(234, 179, 8, 0.4)
    }

    #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 18px;
        z-index: 10;
        pointer-events: none;
        max-width: 250px;
        text-align: center;
    }

    #score {
        font-size: 42px;
        font-weight: bold;
        color: #00d9ff;
        margin-bottom: 5px;
        text-shadow: 0 0 10px rgba(0, 217, 255, 0.6);
        transition: color 0.5s
    }

    #wave {
        font-size: 20px;
        color: #aaa;
        margin-bottom: 8px
    }

    #waveProgress {
        width: 200px;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        margin-bottom: 10px;
        overflow: hidden
    }

    #waveProgressBar {
        height: 100%;
        background: #00d9ff;
        border-radius: 3px;
        transition: width 0.3s, background 0.5s
    }

    #lives {
        display: flex;
        gap: 8px;
        margin-top: 8px
    }

    .life {
        width: 22px;
        height: 22px;
        background: #ff4444;
        border-radius: 50%;
        box-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
        transition: all 0.3s
    }

    .life.lost {
        background: #331111;
        box-shadow: none
    }

    #combo {
        font-size: 28px;
        color: #ffd700;
        margin-top: 12px;
        font-weight: bold;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        transition: all 0.2s;
        word-wrap: break-word
    }

    #stats {
        position: absolute;
        top: 20px;
        right: 20px;
        text-align: right;
        font-size: 16px;
        color: #aaa;
        pointer-events: none
    }

    #stats div {
        margin-bottom: 5px
    }

    #powerups {
        position: absolute;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
        pointer-events: none
    }

    .powerup-icon {
        width: 50px;
        height: 50px;
        border-radius: 10px;
        background: rgba(0, 217, 255, 0.2);
        border: 2px solid #00d9ff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
        position: relative
    }

    .powerup-icon.active {
        animation: pulse 0.5s infinite
    }

    @keyframes pulse {
        0%, 100% {
            transform: scale(1)
        }
        50% {
            transform: scale(1.1)
        }
    }

    .powerup-timer {
        position: absolute;
        bottom: -5px;
        left: 0;
        right: 0;
        height: 4px;
        background: #00d9ff;
        border-radius: 2px;
        transition: width 0.1s linear
    }

    #achievements {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 50
    }

    .achievement {
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #ffd700;
        border-radius: 12px;
        padding: 20px 30px;
        font-size: 32px;
        color: #ffd700;
        font-weight: bold;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        animation: achievementPop 2s forwards;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.5)
    }

    @keyframes achievementPop {
        0% {
            transform: scale(0);
            opacity: 0
        }
        10% {
            transform: scale(1.2);
            opacity: 1
        }
        85% {
            transform: scale(1);
            opacity: 1
        }
        100% {
            transform: scale(0.8);
            opacity: 0
        }
    }

    #menu, #gameOver, #pauseMenu {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100
    }

    #menu h1, #gameOver h1 {
        font-size: 72px;
        margin-bottom: 20px;
        color: #00d9ff;
        text-shadow: 0 0 30px rgba(0, 217, 255, 0.8);
        animation: glow 2s ease-in-out infinite
    }

    @keyframes glow {
        0%, 100% {
            text-shadow: 0 0 30px rgba(0, 217, 255, 0.8)
        }
        50% {
            text-shadow: 0 0 50px rgba(0, 217, 255, 1)
        }
    }

    #menu p {
        font-size: 18px;
        margin-bottom: 30px;
        color: #aaa;
        max-width: 700px;
        text-align: center;
        line-height: 1.8
    }

    #controls {
        font-size: 16px;
        color: #666;
        margin-top: 20px
    }

    .btn {
        padding: 15px 45px;
        font-size: 24px;
        background: #00d9ff;
        color: #0f0f0f;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        box-shadow: 0 4px 20px rgba(0, 217, 255, 0.5);
        pointer-events: all
    }

    .btn:hover {
        background: #00b8d4;
        transform: translateY(-2px);
        box-shadow: 0 6px 25px rgba(0, 217, 255, 0.7)
    }

    .btn:active {
        transform: translateY(0)
    }

    #finalScore {
        font-size: 56px;
        color: #ffd700;
        margin: 20px 0;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.6)
    }

    #gameOver .stats-grid {
        display: grid;
        grid-template-columns:1fr 1fr;
        gap: 20px;
        margin: 20px 0;
        font-size: 18px
    }

    #gameOver .stat-item {
        background: rgba(0, 217, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid rgba(0, 217, 255, 0.3)
    }

    #gameOver .stat-label {
        color: #aaa;
        font-size: 14px
    }

    #gameOver .stat-value {
        color: #00d9ff;
        font-size: 24px;
        font-weight: bold;
        margin-top: 5px
    }

    #pauseMenu h2 {
        font-size: 48px;
        margin-bottom: 30px;
        color: #00d9ff
    }

    .hidden {
        display: none !important
    }</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="800" class="zone-1"></canvas>
<div id="ui">
    <div id="score">0</div>
    <div id="wave">Wave 1 - Blue Zone</div>
    <div id="waveProgress">
        <div id="waveProgressBar" style="width:0%"></div>
    </div>
    <div id="lives"></div>
    <div id="combo">x1</div>
</div>
<div id="stats">
    <div>Best Chain: <span id="bestChain">0</span></div>
    <div>Cleared: <span id="cleared">0</span></div>
</div>
<div id="powerups"></div>
<div id="achievements"></div>
<div id="menu"><h1>CHAIN REACTION</h1>
    <p>Click circles to trigger explosive chain reactions! Each zone brings new challenges. Bonus circles, fast circles,
        and mini circles appear as you progress. Create massive combos for huge scores!</p>
    <button class="btn" onclick="game.startGame()">START GAME</button>
    <div id="controls">Click to explode • ESC to pause</div>
</div>
<div id="pauseMenu" class="hidden"><h2>PAUSED</h2>
    <button class="btn" onclick="game.resume()">RESUME</button>
    <button class="btn" onclick="game.quitToMenu()" style="margin-top:15px;background:#666">QUIT</button>
</div>
<div id="gameOver" class="hidden"><h1>GAME OVER</h1>
    <div id="finalScore">Score: 0</div>
    <div class="stats-grid">
        <div class="stat-item">
            <div class="stat-label">High Score</div>
            <div class="stat-value" id="highScore">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Best Chain</div>
            <div class="stat-value" id="finalBestChain">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Wave Reached</div>
            <div class="stat-value" id="finalWave">1</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Circles Cleared</div>
            <div class="stat-value" id="finalCleared">0</div>
        </div>
    </div>
    <button class="btn" onclick="game.startGame()">PLAY AGAIN</button>
</div>
<script>const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ZONES = {
    1: {name: 'Blue Zone', color: '#00d9ff', bgGlow: 'rgba(0,217,255,0.05)', waves: 3},
    2: {name: 'Purple Zone', color: '#9333ea', bgGlow: 'rgba(147,51,234,0.05)', waves: 6},
    3: {name: 'Red Zone', color: '#ef4444', bgGlow: 'rgba(239,68,68,0.05)', waves: 9},
    4: {name: 'Gold Zone', color: '#eab308', bgGlow: 'rgba(234,179,8,0.05)', waves: 999}
};
const game = {
    state: 'MENU',
    score: 0,
    highScore: localStorage.getItem('highScore') || 0,
    lives: 3,
    wave: 1,
    circles: [],
    particles: [],
    powerups: [],
    activePowerups: [],
    floatingTexts: [],
    nextSpawn: 0,
    spawnRate: 100,
    time: 0,
    waveTime: 0,
    combo: 0,
    comboTimer: 0,
    bestChain: 0,
    cleared: 0,
    shake: {x: 0, y: 0, intensity: 0},
    audioCtx: null,
    paused: false,
    achievements: [],
    currentZone: 1,
    init() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        canvas.addEventListener('click', e => this.handleClick(e));
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                if (this.state === 'PLAYING') {
                    this.paused ? this.resume() : this.pause()
                }
            }
        });
        this.updateLivesDisplay();
        requestAnimationFrame(t => this.loop(t))
    },
    startGame() {
        this.state = 'PLAYING';
        this.score = 0;
        this.lives = 3;
        this.wave = 1;
        this.currentZone = 1;
        this.circles = [];
        this.particles = [];
        this.powerups = [];
        this.activePowerups = [];
        this.floatingTexts = [];
        this.achievements = [];
        this.nextSpawn = 0;
        this.time = 0;
        this.waveTime = 0;
        this.combo = 0;
        this.bestChain = 0;
        this.cleared = 0;
        this.spawnRate = 100;
        this.paused = false;
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameOver').classList.add('hidden');
        document.getElementById('pauseMenu').classList.add('hidden');
        this.updateScore();
        this.updateLivesDisplay();
        this.updateStats();
        this.updateWave();
        this.updateZone()
    },
    pause() {
        this.paused = true;
        document.getElementById('pauseMenu').classList.remove('hidden')
    },
    resume() {
        this.paused = false;
        document.getElementById('pauseMenu').classList.add('hidden')
    },
    quitToMenu() {
        this.state = 'MENU';
        this.paused = false;
        document.getElementById('pauseMenu').classList.add('hidden');
        document.getElementById('menu').classList.remove('hidden')
    },
    getZone() {
        if (this.wave <= 3) return 1;
        if (this.wave <= 6) return 2;
        if (this.wave <= 9) return 3;
        return 4
    },
    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        if (this.state === 'PLAYING' && !this.paused) {
            this.update(dt)
        }
        this.render();
        requestAnimationFrame(t => this.loop(t))
    },
    update(dt) {
        this.time += dt;
        this.waveTime += dt;
        const waveLength = 30;
        const progress = Math.min(this.waveTime / waveLength, 1);
        document.getElementById('waveProgressBar').style.width = `${progress * 100}%`;
        if (this.waveTime >= waveLength) {
            this.wave++;
            this.waveTime = 0;
            this.updateWave();
            const newZone = this.getZone();
            if (newZone !== this.currentZone) {
                this.currentZone = newZone;
                this.updateZone();
                this.showAchievement(`${ZONES[newZone].name} Unlocked!`)
            }
            this.spawnRate = Math.max(50, 100 - this.wave * 3)
        }
        this.nextSpawn -= dt * 1000;
        if (this.nextSpawn <= 0) {
            this.spawnCircle();
            this.nextSpawn = this.spawnRate
        }
        if (Math.random() < 0.0008 && this.powerups.length < 2) {
            this.spawnPowerup()
        }
        this.circles.forEach((c, i) => {
            if (c.exploding) {
                c.explosionRadius += dt * 500;
                c.life -= dt * 2.5;
                if (c.life <= 0) {
                    this.circles.splice(i, 1)
                }
            } else {
                c.countdown -= dt * (this.getActivePowerup('slow') ? 0.3 : 1);
                if (c.countdown <= 0) {
                    this.loseLife();
                    this.circles.splice(i, 1)
                }
            }
        });
        this.powerups.forEach((p, i) => {
            p.life -= dt;
            if (p.life <= 0) this.powerups.splice(i, 1); else {
                p.angle += dt * 2;
                p.scale = 1 + Math.sin(this.time * 4) * 0.1
            }
        });
        this.activePowerups.forEach((p, i) => {
            p.duration -= dt;
            if (p.duration <= 0) this.activePowerups.splice(i, 1)
        });
        this.particles.forEach((p, i) => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 300 * dt;
            p.life -= dt * 2;
            if (p.life <= 0) this.particles.splice(i, 1)
        });
        this.floatingTexts.forEach((t, i) => {
            t.y -= dt * 60;
            t.life -= dt;
            if (t.life <= 0) this.floatingTexts.splice(i, 1)
        });
        if (this.comboTimer > 0) {
            this.comboTimer -= dt;
            if (this.comboTimer <= 0) {
                this.combo = 0;
                this.updateCombo()
            }
        }
        if (this.shake.intensity > 0) {
            this.shake.intensity -= dt * 5;
            this.shake.x = (Math.random() - 0.5) * this.shake.intensity * 10;
            this.shake.y = (Math.random() - 0.5) * this.shake.intensity * 10
        }
        this.updatePowerupDisplay()
    },
    render() {
        ctx.save();
        ctx.translate(this.shake.x, this.shake.y);
        const zone = ZONES[this.currentZone];
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (zone.bgGlow) {
            ctx.fillStyle = zone.bgGlow;
            ctx.fillRect(0, 0, canvas.width, canvas.height)
        }
        this.powerups.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            ctx.scale(p.scale, p.scale);
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = p.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.icon, 0, 0);
            ctx.restore()
        });
        this.circles.forEach(c => {
            if (c.exploding) {
                const color = c.type === 'bonus' ? '255,215,0' : '0,217,255';
                const grad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.explosionRadius);
                grad.addColorStop(0, `rgba(${color},${c.life * 0.8})`);
                grad.addColorStop(0.5, `rgba(${color},${c.life * 0.4})`);
                grad.addColorStop(1, `rgba(${color},0)`);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.explosionRadius, 0, Math.PI * 2);
                ctx.fill()
            } else {
                const timeRatio = c.countdown / c.maxCountdown;
                const pulseSpeed = c.type === 'fast' ? 16 : 8;
                const pulseScale = 1 + Math.sin(this.time * pulseSpeed) * 0.05;
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.scale(pulseScale, pulseScale);
                ctx.beginPath();
                ctx.arc(0, 0, c.radius, 0, Math.PI * 2);
                let fillColor;
                if (c.type === 'bonus') fillColor = '#ffd700'; else if (c.type === 'fast') fillColor = timeRatio > 0.5 ? '#ff6b6b' : '#ff3333'; else fillColor = timeRatio > 0.5 ? zone.color : timeRatio > 0.25 ? '#ffaa00' : '#ff4444';
                ctx.fillStyle = fillColor;
                ctx.shadowBlur = 15;
                ctx.shadowColor = fillColor;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = c.type === 'bonus' ? 3 : 2;
                ctx.stroke();
                if (c.type !== 'mini') {
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${c.type === 'bonus' ? 20 : 18}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.ceil(c.countdown), 0, 0)
                }
                ctx.restore()
            }
        });
        this.particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.type === 'spark' ? `rgba(255,215,0,${p.life})` : p.type === 'bonus' ? `rgba(255,215,0,${p.life})` : `rgba(0,217,255,${p.life})`;
            ctx.fill()
        });
        this.floatingTexts.forEach(t => {
            ctx.font = `bold ${t.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = `rgba(255,215,0,${t.life})`;
            ctx.strokeStyle = `rgba(0,0,0,${t.life * 0.5})`;
            ctx.lineWidth = 3;
            ctx.strokeText(t.text, t.x, t.y);
            ctx.fillText(t.text, t.x, t.y)
        });
        ctx.restore()
    },
    spawnCircle() {
        const maxAttempts = 20;
        for (let i = 0; i < maxAttempts; i++) {
            const x = 70 + Math.random() * (canvas.width - 140);
            const y = 70 + Math.random() * (canvas.height - 140);
            let valid = true;
            for (let c of this.circles) {
                if (!c.exploding) {
                    const dx = c.x - x;
                    const dy = c.y - y;
                    if (Math.sqrt(dx * dx + dy * dy) < 65) {
                        valid = false;
                        break
                    }
                }
            }
            if (valid) {
                let type = 'normal', radius = 28, countdown = Math.max(2, 5 - this.wave * 0.12);
                if (this.wave >= 5 && Math.random() < 0.15) {
                    type = 'bonus';
                    countdown *= 1.2
                } else if (this.wave >= 10 && Math.random() < 0.2) {
                    type = 'fast';
                    countdown *= 0.6
                } else if (this.wave >= 15 && Math.random() < 0.15) {
                    type = 'mini';
                    radius = 18;
                    countdown *= 1.1
                }
                this.circles.push({
                    x,
                    y,
                    radius,
                    countdown,
                    maxCountdown: countdown,
                    type,
                    exploding: false,
                    explosionRadius: 0,
                    life: 1
                });
                break
            }
        }
    },
    spawnPowerup() {
        const types = ['slow', 'freeze', 'nuke', 'multi'];
        const type = types[Math.floor(Math.random() * types.length)];
        const colors = {slow: '#00d9ff', freeze: '#4444ff', nuke: '#ff4444', multi: '#ffd700'};
        const icons = {slow: '⏱', freeze: '❄', nuke: '💣', multi: '✨'};
        this.powerups.push({
            x: 70 + Math.random() * (canvas.width - 140),
            y: 70 + Math.random() * (canvas.height - 140),
            type,
            color: colors[type],
            icon: icons[type],
            angle: 0,
            scale: 1,
            life: 8
        })
    },
    handleClick(e) {
        if (this.state !== 'PLAYING' || this.paused) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        for (let p of this.powerups) {
            const dx = p.x - x;
            const dy = p.y - y;
            if (Math.sqrt(dx * dx + dy * dy) < 25) {
                this.activatePowerup(p);
                this.powerups.splice(this.powerups.indexOf(p), 1);
                return
            }
        }
        for (let i = this.circles.length - 1; i >= 0; i--) {
            const c = this.circles[i];
            const dx = c.x - x;
            const dy = c.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < c.radius && !c.exploding) {
                this.explodeCircle(c, 0, x, y);
                break
            }
        }
    },
    activatePowerup(powerup) {
        const duration = {slow: 5, freeze: 3, nuke: 0, multi: 10}[powerup.type];
        if (powerup.type === 'nuke') {
            this.circles.forEach(c => {
                if (!c.exploding) this.explodeCircle(c, 0, c.x, c.y)
            });
            this.addFloatingText('NUKE!', canvas.width / 2, canvas.height / 2, 48)
        } else if (powerup.type === 'freeze') {
            this.circles.forEach(c => c.countdown += 3);
            this.addFloatingText('FREEZE!', canvas.width / 2, canvas.height / 2, 48)
        } else {
            this.activePowerups.push({type: powerup.type, duration, maxDuration: duration})
        }
        this.playSound(800, 0.2)
    },
    getActivePowerup(type) {
        return this.activePowerups.find(p => p.type === type)
    },
    explodeCircle(circle, depth, originX, originY) {
        if (circle.exploding) return;
        circle.exploding = true;
        circle.explosionRadius = 0;
        circle.life = 1;
        this.cleared++;
        const mult = this.getActivePowerup('multi') ? 2 : 1;
        const bonusMult = circle.type === 'bonus' ? 3 : 1;
        const chainMult = Math.pow(2, Math.min(depth, 8));
        const points = 10 * chainMult * mult * bonusMult;
        this.score += points;
        this.combo = Math.max(this.combo, depth + 1);
        this.bestChain = Math.max(this.bestChain, this.combo);
        this.comboTimer = 1.5;
        this.updateScore();
        this.updateCombo();
        this.updateStats();
        this.checkAchievements();
        if (depth > 0) {
            this.addFloatingText(`+${points}`, circle.x, circle.y - 20, 20 + Math.min(depth * 2, 30))
        }
        this.playSound(400 + depth * 100, 0.1 + Math.min(depth * 0.02, 0.2));
        if (depth > 2) {
            this.shake.intensity = Math.min(depth * 0.3, 3)
        }
        const particleCount = circle.type === 'bonus' ? 35 : 25;
        for (let i = 0; i < particleCount; i++) {
            this.particles.push({
                x: circle.x,
                y: circle.y,
                vx: (Math.random() - 0.5) * 500,
                vy: (Math.random() - 0.5) * 500 - 100,
                life: 0.8 + Math.random() * 0.4,
                size: 2 + Math.random() * 4,
                type: circle.type === 'bonus' ? 'bonus' : Math.random() < 0.3 ? 'spark' : 'normal'
            })
        }
        setTimeout(() => {
            this.circles.forEach(c => {
                if (!c.exploding) {
                    const dx = c.x - circle.x;
                    const dy = c.y - circle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        this.explodeCircle(c, depth + 1, originX, originY)
                    }
                }
            })
        }, 70)
    },
    checkAchievements() {
        if (this.combo === 10 && !this.achievements.includes('chain10')) {
            this.showAchievement('10 Chain Combo!');
            this.achievements.push('chain10')
        }
        if (this.combo === 25 && !this.achievements.includes('chain25')) {
            this.showAchievement('25 Chain Combo!');
            this.achievements.push('chain25')
        }
        if (this.cleared === 100 && !this.achievements.includes('clear100')) {
            this.showAchievement('100 Circles Cleared!');
            this.achievements.push('clear100')
        }
        if (this.cleared === 500 && !this.achievements.includes('clear500')) {
            this.showAchievement('500 Circles Cleared!');
            this.achievements.push('clear500')
        }
    },
    showAchievement(text) {
        const div = document.createElement('div');
        div.className = 'achievement';
        div.textContent = text;
        document.getElementById('achievements').appendChild(div);
        setTimeout(() => div.remove(), 2000);
        this.playSound(1000, 0.15)
    },
    addFloatingText(text, x, y, size) {
        this.floatingTexts.push({text, x, y, size, life: 1})
    },
    updateScore() {
        document.getElementById('score').textContent = this.score;
        const zone = ZONES[this.currentZone];
        document.getElementById('score').style.color = zone.color;
        document.getElementById('waveProgressBar').style.background = zone.color;
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('highScore', this.highScore)
        }
    },
    updateCombo() {
        const comboEl = document.getElementById('combo');
        comboEl.textContent = `x${this.combo}`;
        const scale = Math.min(1 + this.combo * 0.04, 1.5);
        comboEl.style.transform = `scale(${scale})`;
        comboEl.style.color = this.combo > 5 ? '#ff4444' : this.combo > 3 ? '#ffaa00' : '#ffd700'
    },
    updateStats() {
        document.getElementById('bestChain').textContent = this.bestChain;
        document.getElementById('cleared').textContent = this.cleared
    },
    updateWave() {
        const zone = ZONES[this.currentZone];
        document.getElementById('wave').textContent = `Wave ${this.wave} - ${zone.name}`;
        this.addFloatingText(`WAVE ${this.wave}`, canvas.width / 2, canvas.height / 2, 56)
    },
    updateZone() {
        const zone = this.currentZone;
        canvas.className = `zone-${zone}`;
        this.addFloatingText(`${ZONES[zone].name}!`, canvas.width / 2, canvas.height / 2 - 60, 48)
    },
    updatePowerupDisplay() {
        const container = document.getElementById('powerups');
        container.innerHTML = '';
        this.activePowerups.forEach(p => {
            const div = document.createElement('div');
            div.className = 'powerup-icon active';
            const icons = {slow: '⏱', multi: '✨'};
            div.innerHTML = icons[p.type];
            const timer = document.createElement('div');
            timer.className = 'powerup-timer';
            timer.style.width = `${(p.duration / p.maxDuration) * 100}%`;
            div.appendChild(timer);
            container.appendChild(div)
        })
    },
    loseLife() {
        this.lives--;
        this.updateLivesDisplay();
        this.playSound(150, 0.25);
        this.shake.intensity = 2;
        if (this.lives <= 0) {
            this.gameOver()
        }
    },
    updateLivesDisplay() {
        const livesEl = document.getElementById('lives');
        livesEl.innerHTML = '';
        for (let i = 0; i < 3; i++) {
            const life = document.createElement('div');
            life.className = i < this.lives ? 'life' : 'life lost';
            livesEl.appendChild(life)
        }
    },
    gameOver() {
        this.state = 'GAME_OVER';
        document.getElementById('finalScore').textContent = `Score: ${this.score}`;
        document.getElementById('highScore').textContent = this.highScore;
        document.getElementById('finalBestChain').textContent = this.bestChain;
        document.getElementById('finalWave').textContent = this.wave;
        document.getElementById('finalCleared').textContent = this.cleared;
        document.getElementById('gameOver').classList.remove('hidden')
    },
    playSound(freq, vol) {
        if (!this.audioCtx) return;
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(vol, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.25);
        osc.start();
        osc.stop(this.audioCtx.currentTime + 0.25)
    }
};
game.init();</script>
<script src="../logo.js"></script>
</body>
</html>