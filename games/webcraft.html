<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play WebCraft, a browser-based Minecraft-inspired voxel game. Build, explore, and survive in a procedurally generated 3D world with day/night cycles, caves, and multiple block types.">
    <meta name="keywords" content="webcraft, minecraft clone, voxel game, browser game, 3d game, building game, sandbox game, free online game">
    <meta name="author" content="Claude Opus 4.5 prompted by Tobias Müller">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/webcraft.html">
    <meta property="og:title" content="WebCraft - Browser-Based Voxel Adventure">
    <meta property="og:description" content="Build, explore, and survive in a procedurally generated 3D voxel world. Features day/night cycles, caves, ores, and 18 different block types.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/webcraft.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_232.webp">
    <meta property="og:image:alt" content="WebCraft gameplay screenshot showing voxel terrain">
    <meta property="og:site_name" content="GPT Games">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="WebCraft - Browser-Based Voxel Adventure">
    <meta name="twitter:description" content="Build, explore, and survive in a procedurally generated 3D voxel world. Free to play in your browser.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_232.webp">
    <meta name="theme-color" content="#5a9f3a">
    <title>WebCraft</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e
        }

        #game {
            width: 100vw;
            height: 100vh;
            display: block
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            mix-blend-mode: difference
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%)
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%)
        }

        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.75);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.15)
        }

        .slot {
            width: 52px;
            height: 52px;
            background: rgba(60, 60, 80, 0.8);
            border: 3px solid rgba(100, 100, 120, 0.5);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all .15s
        }

        .slot.active {
            border-color: #5f5;
            background: rgba(80, 120, 80, 0.9);
            box-shadow: 0 0 15px rgba(100, 255, 100, 0.4)
        }

        .slot canvas {
            width: 36px;
            height: 36px;
            image-rendering: pixelated
        }

        .slot-num {
            position: absolute;
            top: 2px;
            left: 5px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8)
        }

        .slot-name {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #fff;
            white-space: nowrap;
            opacity: 0;
            transition: opacity .2s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8)
        }

        .slot.active .slot-name {
            opacity: 1
        }

        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(10, 10, 20, 0.95) 0%, rgba(20, 30, 40, 0.98) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100
        }

        #menu.hidden {
            display: none
        }

        #menu h1 {
            font-size: 60px;
            color: #5a5;
            margin-bottom: 8px;
            text-shadow: 4px 4px 0 #232, 2px 2px 0 #343, -1px -1px 0 #7c7;
            letter-spacing: 8px;
            font-weight: 900
        }

        #menu p {
            color: #999;
            margin-bottom: 40px;
            font-size: 15px
        }

        .menu-btn {
            background: #4a4;
            color: #fff;
            border: none;
            padding: 14px 60px;
            font-size: 17px;
            cursor: pointer;
            border-radius: 4px;
            transition: all .15s;
            margin: 6px;
            min-width: 240px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px
        }

        .menu-btn:hover {
            background: #5b5;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4)
        }

        .menu-btn.secondary {
            background: #445
        }

        .menu-btn.secondary:hover {
            background: #556
        }

        #controls {
            margin-top: 50px;
            color: #666;
            font-size: 13px;
            text-align: center;
            line-height: 2.2
        }

        #controls strong {
            color: #999;
            font-size: 15px;
            display: block;
            margin-bottom: 10px
        }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            background: rgba(0, 0, 0, 0.65);
            padding: 12px 16px;
            border-radius: 6px;
            line-height: 1.7
        }

        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.65);
            padding: 12px 16px;
            border-radius: 6px;
            text-align: right;
            line-height: 1.7
        }

        #break-progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 20px);
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
            opacity: 0;
            transition: opacity .15s
        }

        #break-progress.active {
            opacity: 1
        }

        #break-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a4, #6d6);
            width: 0%;
            border-radius: 3px
        }

        #block-highlight {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 16px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity .2s
        }

        #block-highlight.visible {
            opacity: 1
        }
    </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
    <div id="crosshair"></div>
    <div id="break-progress">
        <div id="break-progress-bar"></div>
    </div>
    <div id="block-highlight"></div>
    <div id="hotbar"></div>
    <div id="debug"></div>
    <div id="status"></div>
    <div id="menu">
        <h1>WEBCRAFT</h1>
        <p>A browser-based voxel adventure</p>
        <button class="menu-btn" id="play-btn">▶ Play Game</button>
        <button class="menu-btn secondary" id="new-btn">↻ New World</button>
        <div id="controls">
            <strong>— Controls —</strong>
            WASD - Move | Space - Jump | Shift - Sprint<br>
            Mouse - Look | Left Click - Break | Right Click - Place<br>
            1-9 - Select Block | F - Toggle Fly | T - Time Skip | ESC - Pause
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
    const CHUNK = 16, HEIGHT = 80, RDIST = 4, SEA = 20;
    const B = {
        AIR: 0,
        GRASS: 1,
        DIRT: 2,
        STONE: 3,
        WOOD: 4,
        LEAVES: 5,
        SAND: 6,
        BRICK: 7,
        WATER: 8,
        COBBLE: 9,
        PLANK: 10,
        GLASS: 11,
        COAL: 12,
        IRON: 13,
        GOLD: 14,
        SNOW: 15,
        GRAVEL: 16,
        BEDROCK: 17
    };
    const BNAME = ['Air', 'Grass', 'Dirt', 'Stone', 'Oak Log', 'Leaves', 'Sand', 'Brick', 'Water', 'Cobblestone', 'Oak Planks', 'Glass', 'Coal Ore', 'Iron Ore', 'Gold Ore', 'Snow', 'Gravel', 'Bedrock'];
    const HARD = {
        [B.BEDROCK]: 999,
        [B.STONE]: 1.5,
        [B.COBBLE]: 1.5,
        [B.COAL]: 2,
        [B.IRON]: 2.5,
        [B.GOLD]: 3,
        [B.BRICK]: 2,
        [B.WOOD]: 1,
        [B.PLANK]: 0.8,
        [B.DIRT]: 0.5,
        [B.GRASS]: 0.6,
        [B.SAND]: 0.4,
        [B.GRAVEL]: 0.5,
        [B.LEAVES]: 0.2,
        [B.GLASS]: 0.3,
        [B.SNOW]: 0.2,
        [B.WATER]: 999
    };
    const TRANSPARENT = new Set([B.AIR, B.WATER, B.GLASS, B.LEAVES]);
    const NOCOLLIDE = new Set([B.AIR, B.WATER]);

    class Noise {
        constructor(s = Math.random() * 99999) {
            this.seed = s;
            this.p = [];
            for (let i = 0; i < 512; i++) this.p[i] = Math.floor(this.rand() * 256)
        }

        rand() {
            this.seed = (this.seed * 9301 + 49297) % 233280;
            return this.seed / 233280
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10)
        }

        lerp(a, b, t) {
            return a + t * (b - a)
        }

        grad(h, x, y, z) {
            const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
        }

        noise3(x, y, z) {
            const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = this.fade(x), v = this.fade(y), w = this.fade(z);
            const A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z, B = this.p[X + 1] + Y,
                BA = this.p[B] + Z, BB = this.p[B + 1] + Z;
            return this.lerp(this.lerp(this.lerp(this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z), u), this.lerp(this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z), u), v), this.lerp(this.lerp(this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1), u), this.lerp(this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1), u), v), w)
        }

        noise2(x, y) {
            return this.noise3(x, y, 0)
        }

        fbm2(x, y, oct = 4) {
            let v = 0, a = 1, f = 1, m = 0;
            for (let i = 0; i < oct; i++) {
                v += a * this.noise2(x * f, y * f);
                m += a;
                a *= 0.5;
                f *= 2
            }
            return v / m
        }

        fbm3(x, y, z, oct = 3) {
            let v = 0, a = 1, f = 1, m = 0;
            for (let i = 0; i < oct; i++) {
                v += a * this.noise3(x * f, y * f, z * f);
                m += a;
                a *= 0.5;
                f *= 2
            }
            return v / m
        }
    }

    let seed = Date.now(), noise, caveNoise;
    let scene, camera, renderer, world = {}, player, keys = {}, isLocked = false, selectedSlot = 0;
    let gameTime = 0.25, flyMode = false, breakTarget = null, breakProgress = 0, audioCtx = null, highlightMesh;
    const hotbar = [B.GRASS, B.DIRT, B.STONE, B.COBBLE, B.WOOD, B.PLANK, B.BRICK, B.GLASS, B.SAND];
    const texCache = {}, matCache = {};

    function initNoise() {
        noise = new Noise(seed);
        caveNoise = new Noise(seed + 12345)
    }

    initNoise();

    function createTexture(type, face = 'side') {
        const c = document.createElement('canvas');
        c.width = c.height = 16;
        const g = c.getContext('2d');
        const fill = col => {
            g.fillStyle = col;
            g.fillRect(0, 0, 16, 16)
        };
        const dots = (col, n, sz = 1) => {
            g.fillStyle = col;
            for (let i = 0; i < n; i++) g.fillRect(Math.random() * 15 | 0, Math.random() * 15 | 0, sz, sz)
        };
        switch (type) {
            case B.GRASS:
                if (face === 'top') {
                    fill('#5a9f3a');
                    dots('#4a8f2a', 30);
                    dots('#6ab04a', 20)
                } else if (face === 'bottom') {
                    fill('#8b6b4a');
                    dots('#7a5a3a', 25);
                    dots('#9b7b5a', 15)
                } else {
                    fill('#8b6b4a');
                    dots('#7a5a3a', 25);
                    g.fillStyle = '#5a9f3a';
                    g.fillRect(0, 0, 16, 4);
                    for (let i = 0; i < 8; i++) {
                        g.fillStyle = '#4a8f2a';
                        g.fillRect(Math.random() * 15 | 0, 4, 1, 1 + Math.random() * 2 | 0)
                    }
                }
                break;
            case B.DIRT:
                fill('#8b6b4a');
                dots('#7a5a3a', 30);
                dots('#9b7b5a', 20);
                break;
            case B.STONE:
                fill('#8a8a8a');
                dots('#7a7a7a', 35);
                dots('#9a9a9a', 25);
                dots('#6a6a6a', 15);
                break;
            case B.COBBLE:
                fill('#7a7a7a');
                for (let i = 0; i < 15; i++) {
                    g.fillStyle = ['#6a6a6a', '#8a8a8a', '#5a5a5a', '#9a9a9a'][Math.random() * 4 | 0];
                    const s = 2 + Math.random() * 4 | 0;
                    g.fillRect(Math.random() * 14 | 0, Math.random() * 14 | 0, s, s)
                }
                g.strokeStyle = '#555';
                g.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    g.beginPath();
                    g.moveTo(Math.random() * 16, Math.random() * 16);
                    g.lineTo(Math.random() * 16, Math.random() * 16);
                    g.stroke()
                }
                break;
            case B.WOOD:
                if (face === 'top' || face === 'bottom') {
                    fill('#b5894c');
                    g.strokeStyle = '#8a6a3c';
                    g.lineWidth = 1;
                    for (let r = 2; r < 8; r += 2) {
                        g.beginPath();
                        g.arc(8, 8, r, 0, Math.PI * 2);
                        g.stroke()
                    }
                } else {
                    fill('#8a6a3c');
                    g.fillStyle = '#6a4a2c';
                    for (let y = 0; y < 16; y += 3) {
                        g.fillRect(0, y, 16, 1)
                    }
                    dots('#9a7a4c', 12);
                    dots('#5a3a1c', 8)
                }
                break;
            case B.PLANK:
                fill('#c4a060');
                g.fillStyle = '#a48040';
                for (let y = 0; y < 16; y += 4) {
                    g.fillRect(0, y, 16, 1)
                }
                g.fillStyle = '#b49050';
                for (let x = 0; x < 16; x += 4) {
                    g.fillRect(x, 0, 1, 16)
                }
                dots('#d4b070', 10);
                break;
            case B.LEAVES:
                g.fillStyle = '#3a8a30';
                g.fillRect(0, 0, 16, 16);
                dots('#2a7a20', 50);
                dots('#4a9a40', 40);
                dots('#5aaa50', 20);
                break;
            case B.SAND:
                fill('#e6d6a6');
                dots('#d6c696', 45);
                dots('#f6e6b6', 35);
                break;
            case B.BRICK:
                fill('#964b3c');
                g.fillStyle = '#b8a898';
                for (let y = 0; y < 16; y += 4) {
                    g.fillRect(0, y, 16, 1);
                    const off = (y / 4) % 2 * 4;
                    for (let x = off; x < 16; x += 8) {
                        g.fillRect(x, y, 1, 4)
                    }
                }
                break;
            case B.WATER:
                g.fillStyle = 'rgba(60,130,200,0.7)';
                g.fillRect(0, 0, 16, 16);
                g.fillStyle = 'rgba(80,150,220,0.5)';
                dots('rgba(40,110,180,0.6)', 25);
                break;
            case B.GLASS:
                g.fillStyle = 'rgba(220,240,255,0.25)';
                g.fillRect(0, 0, 16, 16);
                g.strokeStyle = 'rgba(255,255,255,0.5)';
                g.lineWidth = 1;
                g.strokeRect(0.5, 0.5, 15, 15);
                g.strokeRect(4, 4, 8, 8);
                break;
            case B.COAL:
                fill('#8a8a8a');
                dots('#7a7a7a', 25);
                g.fillStyle = '#2a2a2a';
                for (let i = 0; i < 6; i++) {
                    const x = 2 + Math.random() * 11 | 0, y = 2 + Math.random() * 11 | 0;
                    g.fillRect(x, y, 3, 3)
                }
                break;
            case B.IRON:
                fill('#8a8a8a');
                dots('#7a7a7a', 25);
                g.fillStyle = '#d4b8a0';
                for (let i = 0; i < 5; i++) {
                    const x = 2 + Math.random() * 11 | 0, y = 2 + Math.random() * 11 | 0;
                    g.fillRect(x, y, 3, 2)
                }
                break;
            case B.GOLD:
                fill('#8a8a8a');
                dots('#7a7a7a', 25);
                g.fillStyle = '#fcdc4a';
                for (let i = 0; i < 5; i++) {
                    const x = 2 + Math.random() * 11 | 0, y = 2 + Math.random() * 11 | 0;
                    g.fillRect(x, y, 3, 2)
                }
                break;
            case B.SNOW:
                fill('#f0f5ff');
                dots('#e0e8f8', 35);
                dots('#ffffff', 30);
                break;
            case B.GRAVEL:
                fill('#888');
                for (let i = 0; i < 40; i++) {
                    g.fillStyle = ['#666', '#777', '#999', '#aaa', '#888'][Math.random() * 5 | 0];
                    g.fillRect(Math.random() * 15 | 0, Math.random() * 15 | 0, 2, 2)
                }
                break;
            case B.BEDROCK:
                fill('#222');
                dots('#333', 40);
                dots('#111', 30);
                dots('#444', 20);
                for (let i = 0; i < 5; i++) {
                    g.fillStyle = '#1a1a1a';
                    g.fillRect(Math.random() * 12 | 0, Math.random() * 12 | 0, 4, 4)
                }
                break;
        }
        return c;
    }

    function getTexture(type, face = 'side') {
        const k = `${type}_${face}`;
        if (!texCache[k]) {
            const t = new THREE.CanvasTexture(createTexture(type, face));
            t.magFilter = THREE.NearestFilter;
            t.minFilter = THREE.NearestFilter;
            texCache[k] = t;
        }
        return texCache[k];
    }

    function getMaterial(type, face = 'side') {
        const k = `${type}_${face}`;
        if (!matCache[k]) {
            const opts = {map: getTexture(type, face)};
            if (type === B.WATER || type === B.GLASS) {
                opts.transparent = true;
                opts.opacity = type === B.WATER ? 0.7 : 0.4
            }
            if (type === B.LEAVES) {
                opts.transparent = true;
                opts.alphaTest = 0.1
            }
            matCache[k] = new THREE.MeshLambertMaterial(opts);
        }
        return matCache[k];
    }

    const FACES = [
        {
            dir: [1, 0, 0],
            name: 'px',
            verts: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]],
            norm: [1, 0, 0],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]]
        },
        {
            dir: [-1, 0, 0],
            name: 'nx',
            verts: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]],
            norm: [-1, 0, 0],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]]
        },
        {
            dir: [0, 1, 0],
            name: 'py',
            verts: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]],
            norm: [0, 1, 0],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]],
            face: 'top'
        },
        {
            dir: [0, -1, 0],
            name: 'ny',
            verts: [[0, 0, 1], [0, 0, 0], [1, 0, 0], [1, 0, 1]],
            norm: [0, -1, 0],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]],
            face: 'bottom'
        },
        {
            dir: [0, 0, 1],
            name: 'pz',
            verts: [[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 1]],
            norm: [0, 0, 1],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]]
        },
        {
            dir: [0, 0, -1],
            name: 'nz',
            verts: [[0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]],
            norm: [0, 0, -1],
            uv: [[0, 0], [0, 1], [1, 1], [1, 0]]
        }
    ];

    class Chunk {
        constructor(cx, cz) {
            this.cx = cx;
            this.cz = cz;
            this.data = new Uint8Array(CHUNK * HEIGHT * CHUNK);
            this.mesh = null;
            this.dirty = true;
            this.generated = false;
        }

        idx(x, y, z) {
            return (y * CHUNK + z) * CHUNK + x
        }

        get(x, y, z) {
            if (x < 0 || x >= CHUNK || y < 0 || y >= HEIGHT || z < 0 || z >= CHUNK) return B.AIR;
            return this.data[this.idx(x, y, z)];
        }

        set(x, y, z, v) {
            if (x >= 0 && x < CHUNK && y >= 0 && y < HEIGHT && z >= 0 && z < CHUNK) {
                this.data[this.idx(x, y, z)] = v;
                this.dirty = true;
            }
        }

        generate() {
            if (this.generated) return;
            this.generated = true;
            for (let x = 0; x < CHUNK; x++) {
                for (let z = 0; z < CHUNK; z++) {
                    const wx = this.cx * CHUNK + x, wz = this.cz * CHUNK + z;
                    const n1 = noise.fbm2(wx * 0.01, wz * 0.01, 4);
                    const n2 = noise.fbm2(wx * 0.03, wz * 0.03, 3) * 0.3;
                    const h = Math.floor(SEA + n1 * 25 + n2 * 8);
                    const temp = noise.fbm2(wx * 0.008 + 100, wz * 0.008 + 100, 2);
                    const isBeach = h >= SEA - 2 && h <= SEA + 2;
                    for (let y = 0; y < HEIGHT; y++) {
                        let t = B.AIR;
                        if (y === 0) t = B.BEDROCK;
                        else if (y < h - 4) t = B.STONE;
                        else if (y < h) t = isBeach ? B.SAND : B.DIRT;
                        else if (y === h) {
                            if (isBeach) t = B.SAND;
                            else if (temp > 0.3 && h > SEA + 15) t = B.SNOW;
                            else t = B.GRASS;
                        } else if (y <= SEA && y > h) t = B.WATER;
                        if (t === B.STONE && y > 3 && y < h - 2) {
                            const cv = caveNoise.fbm3(wx * 0.06, y * 0.09, wz * 0.06, 2);
                            if (cv > 0.35) t = B.AIR;
                        }
                        if (t === B.STONE && y > 5 && y < h - 2) {
                            const ore = noise.fbm3(wx * 0.15 + 500, y * 0.15, wz * 0.15 + 500, 2);
                            if (ore > 0.5) t = B.COAL;
                            else if (ore < -0.45 && y < 35) t = B.IRON;
                            else if (ore > 0.48 && ore < 0.5 && y < 20) t = B.GOLD;
                        }
                        this.set(x, y, z, t);
                    }
                }
            }
            for (let x = 2; x < CHUNK - 2; x++) {
                for (let z = 2; z < CHUNK - 2; z++) {
                    const wx = this.cx * CHUNK + x, wz = this.cz * CHUNK + z;
                    let h = 0;
                    for (let y = HEIGHT - 1; y >= 0; y--) {
                        const b = this.get(x, y, z);
                        if (b !== B.AIR && b !== B.WATER && b !== B.LEAVES) {
                            h = y;
                            break
                        }
                    }
                    if (this.get(x, h, z) === B.GRASS && noise.noise2(wx * 0.4, wz * 0.4) > 0.3 && Math.random() < 0.03) {
                        const th = 4 + Math.floor(Math.random() * 3);
                        for (let y = 1; y <= th; y++) this.set(x, h + y, z, B.WOOD);
                        for (let ly = -1; ly <= 2; ly++) {
                            const r = ly < 1 ? 2 : 1;
                            for (let lx = -r; lx <= r; lx++) {
                                for (let lz = -r; lz <= r; lz++) {
                                    if (Math.abs(lx) === r && Math.abs(lz) === r && Math.random() < 0.3) continue;
                                    const tx = x + lx, tz = z + lz, ty = h + th + ly;
                                    if (tx >= 0 && tx < CHUNK && tz >= 0 && tz < CHUNK && this.get(tx, ty, tz) === B.AIR) {
                                        this.set(tx, ty, tz, B.LEAVES);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        getNeighborBlock(x, y, z) {
            if (y < 0 || y >= HEIGHT) return B.AIR;
            if (x >= 0 && x < CHUNK && z >= 0 && z < CHUNK) return this.get(x, y, z);
            const ncx = this.cx + (x < 0 ? -1 : x >= CHUNK ? 1 : 0);
            const ncz = this.cz + (z < 0 ? -1 : z >= CHUNK ? 1 : 0);
            const chunk = world[`${ncx},${ncz}`];
            if (!chunk) return B.AIR;
            const nx = ((x % CHUNK) + CHUNK) % CHUNK;
            const nz = ((z % CHUNK) + CHUNK) % CHUNK;
            return chunk.get(nx, y, nz);
        }

        build() {
            if (this.mesh) {
                scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
            }
            const positions = [], normals = [], uvs = [], indices = [];
            const groups = {};
            let indexOffset = 0;
            for (let y = 0; y < HEIGHT; y++) {
                for (let z = 0; z < CHUNK; z++) {
                    for (let x = 0; x < CHUNK; x++) {
                        const block = this.get(x, y, z);
                        if (block === B.AIR) continue;
                        for (const face of FACES) {
                            const nx = x + face.dir[0], ny = y + face.dir[1], nz = z + face.dir[2];
                            const neighbor = this.getNeighborBlock(nx, ny, nz);
                            const shouldRender = TRANSPARENT.has(neighbor) && (block !== neighbor || block === B.LEAVES);
                            if (!shouldRender) continue;
                            const faceType = face.face || 'side';
                            const matKey = `${block}_${faceType}`;
                            if (!groups[matKey]) groups[matKey] = {indices: [], block, faceType};
                            const vi = positions.length / 3;
                            for (let i = 0; i < 4; i++) {
                                positions.push(x + face.verts[i][0], y + face.verts[i][1], z + face.verts[i][2]);
                                normals.push(face.norm[0], face.norm[1], face.norm[2]);
                                uvs.push(face.uv[i][0], face.uv[i][1]);
                            }
                            groups[matKey].indices.push(vi, vi + 1, vi + 2, vi, vi + 2, vi + 3);
                        }
                    }
                }
            }
            if (positions.length === 0) {
                this.dirty = false;
                return
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            const materials = [];
            let currentIndex = 0;
            const sortedGroups = Object.entries(groups).sort((a, b) => {
                const aT = TRANSPARENT.has(a[1].block) ? 1 : 0;
                const bT = TRANSPARENT.has(b[1].block) ? 1 : 0;
                return aT - bT;
            });
            for (const [key, group] of sortedGroups) {
                const start = currentIndex;
                for (const idx of group.indices) {
                    indices.push(idx)
                }
                geo.addGroup(start, group.indices.length, materials.length);
                materials.push(getMaterial(group.block, group.faceType));
                currentIndex += group.indices.length;
            }
            geo.setIndex(indices);
            geo.computeBoundingSphere();
            this.mesh = new THREE.Mesh(geo, materials);
            this.mesh.position.set(this.cx * CHUNK, 0, this.cz * CHUNK);
            scene.add(this.mesh);
            this.dirty = false;
        }
    }

    function getChunk(cx, cz) {
        const k = `${cx},${cz}`;
        if (!world[k]) {
            world[k] = new Chunk(cx, cz);
            world[k].generate()
        }
        return world[k];
    }

    function getBlock(x, y, z) {
        if (y < 0 || y >= HEIGHT) return B.AIR;
        const cx = Math.floor(x / CHUNK), cz = Math.floor(z / CHUNK);
        const c = world[`${cx},${cz}`];
        if (!c) return B.AIR;
        return c.get(((x % CHUNK) + CHUNK) % CHUNK, y, ((z % CHUNK) + CHUNK) % CHUNK);
    }

    function setBlock(x, y, z, type) {
        if (y < 0 || y >= HEIGHT) return;
        const cx = Math.floor(x / CHUNK), cz = Math.floor(z / CHUNK);
        const c = getChunk(cx, cz);
        const lx = ((x % CHUNK) + CHUNK) % CHUNK, lz = ((z % CHUNK) + CHUNK) % CHUNK;
        c.set(lx, y, lz, type);
        if (lx === 0 && world[`${cx - 1},${cz}`]) world[`${cx - 1},${cz}`].dirty = true;
        if (lx === CHUNK - 1 && world[`${cx + 1},${cz}`]) world[`${cx + 1},${cz}`].dirty = true;
        if (lz === 0 && world[`${cx},${cz - 1}`]) world[`${cx},${cz - 1}`].dirty = true;
        if (lz === CHUNK - 1 && world[`${cx},${cz + 1}`]) world[`${cx},${cz + 1}`].dirty = true;
    }

    class Player {
        constructor() {
            this.pos = new THREE.Vector3(CHUNK / 2, 50, CHUNK / 2);
            this.vel = new THREE.Vector3();
            this.yaw = 0;
            this.pitch = 0;
            this.onGround = false;
            this.height = 1.62;
            this.width = 0.3;
        }

        update(dt) {
            const speed = keys.shift ? (flyMode ? 15 : 7) : 5;
            const dir = new THREE.Vector3();
            if (keys.w) dir.z -= 1;
            if (keys.s) dir.z += 1;
            if (keys.a) dir.x -= 1;
            if (keys.d) dir.x += 1;
            if (dir.length() > 0) dir.normalize();
            dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.yaw);
            if (flyMode) {
                this.vel.x = dir.x * speed;
                this.vel.z = dir.z * speed;
                this.vel.y = 0;
                if (keys.space) this.vel.y = speed;
                if (keys.shift) this.vel.y = -speed;
            } else {
                this.vel.x = dir.x * speed;
                this.vel.z = dir.z * speed;
                if (keys.space && this.onGround) {
                    this.vel.y = 8;
                    this.onGround = false
                }
                this.vel.y -= 25 * dt;
                if (this.vel.y < -50) this.vel.y = -50;
            }
            const steps = Math.ceil(Math.max(Math.abs(this.vel.x), Math.abs(this.vel.y), Math.abs(this.vel.z)) * dt * 10);
            const sdt = dt / Math.max(steps, 1);
            for (let i = 0; i < steps; i++) {
                let nx = this.pos.x + this.vel.x * sdt;
                let ny = this.pos.y + this.vel.y * sdt;
                let nz = this.pos.z + this.vel.z * sdt;
                if (this.collides(nx, this.pos.y, this.pos.z)) {
                    this.vel.x = 0;
                    nx = this.pos.x
                }
                if (this.collides(nx, this.pos.y, nz)) {
                    this.vel.z = 0;
                    nz = this.pos.z
                }
                if (this.collides(nx, ny, nz)) {
                    if (this.vel.y < 0) this.onGround = true;
                    this.vel.y = 0;
                    ny = this.pos.y;
                } else {
                    this.onGround = false
                }
                this.pos.set(nx, ny, nz);
            }
            if (this.pos.y < -20) {
                this.pos.set(CHUNK / 2, 50, CHUNK / 2);
                this.vel.set(0, 0, 0)
            }
            camera.position.set(this.pos.x, this.pos.y + this.height, this.pos.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = -this.yaw;
            camera.rotation.x = -this.pitch;
        }

        collides(x, y, z) {
            if (flyMode) return false;
            const w = this.width, h = this.height;
            const minX = x - w, maxX = x + w;
            const minY = y, maxY = y + h;
            const minZ = z - w, maxZ = z + w;
            for (let bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (let by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (let bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        const block = getBlock(bx, by, bz);
                        if (!NOCOLLIDE.has(block)) {
                            if (maxX > bx && minX < bx + 1 && maxY > by && minY < by + 1 && maxZ > bz && minZ < bz + 1) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
    }

    function raycast(maxDist = 5) {
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const origin = camera.position.clone();
        const step = 0.05;
        let prev = origin.clone();
        for (let t = 0; t < maxDist; t += step) {
            const p = origin.clone().add(dir.clone().multiplyScalar(t));
            const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
            const block = getBlock(bx, by, bz);
            if (block !== B.AIR && block !== B.WATER) {
                return {
                    hit: true, x: bx, y: by, z: bz, block,
                    prev: {x: Math.floor(prev.x), y: Math.floor(prev.y), z: Math.floor(prev.z)}
                };
            }
            prev = p.clone();
        }
        return {hit: false};
    }

    function playSound(type) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        const t = audioCtx.currentTime;
        filter.type = 'lowpass';
        filter.frequency.value = 1000;
        if (type === 'break') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(80 + Math.random() * 40, t);
            osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
            gain.gain.setValueAtTime(0.12, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.start(t);
            osc.stop(t + 0.15);
        } else if (type === 'place') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(200 + Math.random() * 100, t);
            osc.frequency.exponentialRampToValueAtTime(150, t + 0.08);
            gain.gain.setValueAtTime(0.08, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
            osc.start(t);
            osc.stop(t + 0.08);
        } else if (type === 'step') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(60 + Math.random() * 30, t);
            gain.gain.setValueAtTime(0.03, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
            osc.start(t);
            osc.stop(t + 0.05);
        }
    }

    function updateChunks() {
        const pcx = Math.floor(player.pos.x / CHUNK), pcz = Math.floor(player.pos.z / CHUNK);
        for (let dx = -RDIST; dx <= RDIST; dx++) {
            for (let dz = -RDIST; dz <= RDIST; dz++) {
                getChunk(pcx + dx, pcz + dz);
            }
        }
        for (const k in world) {
            const [cx, cz] = k.split(',').map(Number);
            if (Math.abs(cx - pcx) > RDIST + 2 || Math.abs(cz - pcz) > RDIST + 2) {
                if (world[k].mesh) {
                    scene.remove(world[k].mesh);
                    world[k].mesh.geometry?.dispose()
                }
                delete world[k];
            }
        }
    }

    function buildHotbar() {
        const hb = document.getElementById('hotbar');
        hb.innerHTML = '';
        hotbar.forEach((b, i) => {
            const slot = document.createElement('div');
            slot.className = 'slot' + (i === selectedSlot ? ' active' : '');
            const num = document.createElement('span');
            num.className = 'slot-num';
            num.textContent = i + 1;
            const name = document.createElement('span');
            name.className = 'slot-name';
            name.textContent = BNAME[b];
            const canvas = createTexture(b, b === B.GRASS ? 'side' : 'side');
            slot.appendChild(canvas);
            slot.appendChild(num);
            slot.appendChild(name);
            hb.appendChild(slot);
        });
    }

    function updateHotbar() {
        document.querySelectorAll('.slot').forEach((s, i) => {
            s.classList.toggle('active', i === selectedSlot);
        });
    }

    function updateSky() {
        const t = (gameTime % 1);
        const sunAngle = t * Math.PI * 2 - Math.PI / 2;
        const daylight = Math.max(0, Math.sin(sunAngle));
        const ambIntensity = 0.15 + daylight * 0.55;
        const sunIntensity = daylight * 0.85;
        scene.children.forEach(c => {
            if (c.isAmbientLight) c.intensity = ambIntensity;
            if (c.isDirectionalLight) {
                c.intensity = sunIntensity;
                c.position.set(Math.cos(sunAngle) * 100, Math.sin(sunAngle) * 100, 30);
            }
        });
        const r = 20 + daylight * 115, g = 20 + daylight * 160, b = 40 + daylight * 165;
        scene.background.setRGB(r / 255, g / 255, b / 255);
        scene.fog.color.setRGB(r / 255, g / 255, b / 255);
    }

    function createHighlight() {
        const geo = new THREE.BoxGeometry(1.005, 1.005, 1.005);
        const edges = new THREE.EdgesGeometry(geo);
        highlightMesh = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0x000000, linewidth: 2}));
        highlightMesh.renderOrder = 999;
        scene.add(highlightMesh);
    }

    function newWorld() {
        seed = Date.now();
        initNoise();
        for (const k in world) {
            if (world[k].mesh) {
                scene.remove(world[k].mesh);
                world[k].mesh.geometry?.dispose()
            }
            delete world[k];
        }
        for (const k in texCache) {
            texCache[k].dispose?.();
            delete texCache[k]
        }
        for (const k in matCache) {
            matCache[k].dispose?.();
            delete matCache[k]
        }
        player.pos.set(CHUNK / 2, 50, CHUNK / 2);
        player.vel.set(0, 0, 0);
        player.yaw = 0;
        player.pitch = 0;
        flyMode = false;
        updateChunks();
        for (const k in world) world[k].build();
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, RDIST * CHUNK * 0.9);
        camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 500);
        renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('game'),
            antialias: false,
            powerPreference: 'high-performance'
        });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffee, 0.8);
        sun.position.set(50, 100, 30);
        scene.add(sun);
        player = new Player();
        createHighlight();
        updateChunks();
        setTimeout(() => {
            for (const k in world) if (world[k].dirty) world[k].build()
        }, 50);
        buildHotbar();
        const menu = document.getElementById('menu');
        document.getElementById('play-btn').onclick = () => {
            menu.classList.add('hidden');
            renderer.domElement.requestPointerLock();
        };
        document.getElementById('new-btn').onclick = () => {
            newWorld();
            menu.classList.add('hidden');
            renderer.domElement.requestPointerLock();
        };
        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === renderer.domElement;
            if (!isLocked) menu.classList.remove('hidden');
        });
        document.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'a' || k === 's' || k === 'd') keys[k] = true;
            if (e.code === 'Space') {
                keys.space = true;
                e.preventDefault()
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
            if (k >= '1' && k <= '9') {
                selectedSlot = parseInt(k) - 1;
                updateHotbar()
            }
            if (k === 'f' && isLocked) {
                flyMode = !flyMode;
                player.vel.set(0, 0, 0)
            }
            if (k === 't' && isLocked) gameTime += 0.125;
            if (k === 'escape' && isLocked) document.exitPointerLock();
        });
        document.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'a' || k === 's' || k === 'd') keys[k] = false;
            if (e.code === 'Space') keys.space = false;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
        });
        document.addEventListener('mousemove', e => {
            if (!isLocked) return;
            player.yaw += e.movementX * 0.002;
            player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch + e.movementY * 0.002));
        });
        let breaking = false;
        document.addEventListener('mousedown', e => {
            if (!isLocked) return;
            if (e.button === 0) {
                breaking = true
            } else if (e.button === 2) {
                const r = raycast();
                if (r.hit) {
                    const px = r.prev.x, py = r.prev.y, pz = r.prev.z;
                    if (getBlock(px, py, pz) === B.AIR || getBlock(px, py, pz) === B.WATER) {
                        const playerBox = {
                            minX: player.pos.x - player.width, maxX: player.pos.x + player.width,
                            minY: player.pos.y, maxY: player.pos.y + player.height,
                            minZ: player.pos.z - player.width, maxZ: player.pos.z + player.width
                        };
                        const blockBox = {minX: px, maxX: px + 1, minY: py, maxY: py + 1, minZ: pz, maxZ: pz + 1};
                        const overlap = playerBox.maxX > blockBox.minX && playerBox.minX < blockBox.maxX &&
                            playerBox.maxY > blockBox.minY && playerBox.minY < blockBox.maxY &&
                            playerBox.maxZ > blockBox.minZ && playerBox.minZ < blockBox.maxZ;
                        if (!overlap) {
                            setBlock(px, py, pz, hotbar[selectedSlot]);
                            playSound('place')
                        }
                    }
                }
            }
        });
        document.addEventListener('mouseup', e => {
            if (e.button === 0) {
                breaking = false;
                breakProgress = 0;
                breakTarget = null
            }
        });
        document.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
        let lastTime = performance.now(), frames = 0, fps = 0, fpsTime = 0, stepTimer = 0;

        function animate(now) {
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            frames++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                fps = frames;
                frames = 0;
                fpsTime = 0
            }
            if (isLocked) {
                player.update(dt);
                updateChunks();
                gameTime += dt / 600;
                updateSky();
                if (player.onGround && (keys.w || keys.a || keys.s || keys.d)) {
                    stepTimer += dt;
                    if (stepTimer > 0.4) {
                        stepTimer = 0;
                        playSound('step')
                    }
                } else {
                    stepTimer = 0.3
                }
                const r = raycast();
                const bh = document.getElementById('block-highlight');
                if (r.hit) {
                    highlightMesh.visible = true;
                    highlightMesh.position.set(r.x + 0.5, r.y + 0.5, r.z + 0.5);
                    bh.textContent = BNAME[r.block];
                    bh.classList.add('visible');
                    if (breaking) {
                        if (!breakTarget || breakTarget.x !== r.x || breakTarget.y !== r.y || breakTarget.z !== r.z) {
                            breakTarget = {x: r.x, y: r.y, z: r.z};
                            breakProgress = 0;
                        }
                        const hardness = HARD[r.block] || 1;
                        breakProgress += dt / hardness;
                        if (breakProgress >= 1) {
                            setBlock(r.x, r.y, r.z, B.AIR);
                            playSound('break');
                            breakProgress = 0;
                            breakTarget = null;
                        }
                    }
                } else {
                    highlightMesh.visible = false;
                    bh.classList.remove('visible');
                    breakTarget = null;
                    breakProgress = 0;
                }
                const bp = document.getElementById('break-progress');
                const bpb = document.getElementById('break-progress-bar');
                bp.classList.toggle('active', breakProgress > 0 && breakProgress < 1);
                bpb.style.width = `${Math.min(breakProgress * 100, 100)}%`;
            }
            let chunksBuilt = 0;
            for (const k in world) {
                if (world[k].dirty && chunksBuilt < 2) {
                    world[k].build();
                    chunksBuilt++
                }
            }
            renderer.render(scene, camera);
            const hr = Math.floor((gameTime % 1) * 24);
            const mn = Math.floor(((gameTime % 1) * 24 % 1) * 60);
            const timeStr = `${hr.toString().padStart(2, '0')}:${mn.toString().padStart(2, '0')}`;
            const px = player.pos.x.toFixed(1), py = player.pos.y.toFixed(1), pz = player.pos.z.toFixed(1);
            document.getElementById('debug').innerHTML =
                `FPS: ${fps}<br>XYZ: ${px} / ${py} / ${pz}<br>Chunks: ${Object.keys(world).length}<br>Time: ${timeStr}`;
            document.getElementById('status').innerHTML =
                `${flyMode ? '✈️ Flying' : '🚶 Walking'}<br>${BNAME[hotbar[selectedSlot]]}`;
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    }

    init();
</script>
</body>
</html>