<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Play classic Klondike Solitaire online for free. Drag and drop cards, auto-move features, hints, and beautiful design. No download required - play instantly in your browser.">
    <meta name="keywords" content="solitaire, klondike solitaire, card game, online solitaire, free solitaire, patience, card games, browser game, web game">
    <meta name="author" content="Claude Sonnet 4 prompted by Tobias MÃ¼ller">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    <link rel="canonical" href="https://www.gptgames.dev/games/solitaire.html">
    <meta property="og:title" content="Free Online Solitaire - Classic Klondike Card Game">
    <meta property="og:description" content="Play classic Klondike Solitaire online for free. Drag and drop cards, auto-move features, hints, and beautiful design. No download required - play instantly in your browser.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/solitaire.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_197.webp">
    <meta property="og:image:alt" content="Solitaire card game screenshot">
    <meta property="og:site_name" content="GPT Games">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Free Online Solitaire - Classic Klondike Card Game">
    <meta name="twitter:description" content="Play classic Klondike Solitaire online for free. Drag and drop cards, auto-move features, hints, and beautiful design. No download required - play instantly in your browser.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_197.webp">
    <meta name="twitter:image:alt" content="Solitaire card game screenshot">
    <meta name="theme-color" content="#0f5132">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Solitaire">
    <title>Solitaire</title>
    <style>* {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #0f5132, #198754);
        min-height: 100vh;
        color: #fff;
        overflow-x: auto
    }

    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px
    }

    .header {
        text-align: center;
        margin-bottom: 30px
    }

    .header h1 {
        font-size: 2.8rem;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-weight: 300
    }

    .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 30px
    }

    .btn {
        background: #fff;
        color: #0f5132;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-weight: 600;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2)
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        background: #f8f9fa
    }

    .btn:active {
        transform: translateY(0)
    }

    .game-area {
        display: grid;
        grid-template-rows:auto 1fr;
        gap: 30px
    }

    .top-section {
        display: grid;
        grid-template-columns:1fr 1fr 1fr 1fr;
        gap: 20px;
        align-items: start
    }

    .stock-waste {
        display: flex;
        gap: 15px
    }

    .foundations {
        display: flex;
        gap: 15px;
        justify-content: flex-end
    }

    .tableau {
        display: grid;
        grid-template-columns:repeat(7, 1fr);
        gap: 15px
    }

    .card-space {
        width: 100px;
        height: 140px;
        border: 2px dashed rgba(255, 255, 255, 0.4);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.1);
        position: relative;
        transition: all 0.3s ease;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
        font-size: 24px;
        color: rgba(255, 255, 255, 0.6)
    }

    .card-space.highlight {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.2);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3)
    }

    .card {
        width: 100px;
        height: 140px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        position: relative;
        cursor: pointer;
        transition: all 0.3s ease;
        user-select: none;
        overflow: hidden
    }

    .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4)
    }

    .card.dragging {
        opacity: 0.7;
        transform: rotate(3deg) scale(1.05);
        z-index: 1000
    }

    .card img {
        width: 100%;
        height: 100%;
        border-radius: 8px
    }

    .card-back {
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: #fff;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        border-radius: 8px
    }

    .card-back::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        bottom: 8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px
    }

    .column {
        position: relative;
        min-height: 140px
    }

    .column .card {
        position: absolute;
        top: 0;
        left: 0
    }

    .stock-pile {
        position: relative
    }

    .stock-pile .card {
        position: absolute;
        top: 0;
        left: 0
    }

    .win-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000
    }

    .win-content {
        background: #fff;
        color: #0f5132;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        max-width: 400px;
        width: 90%
    }

    .win-content h2 {
        font-size: 2.5rem;
        margin-bottom: 20px;
        color: #198754
    }

    .win-content p {
        font-size: 1.2rem;
        margin-bottom: 30px;
        color: #666
    }

    .stats {
        display: grid;
        grid-template-columns:1fr 1fr;
        gap: 20px;
        margin: 20px 0;
        text-align: center
    }

    .stat {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 10px
    }

    .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #198754
    }

    .stat-label {
        font-size: 0.9rem;
        color: #666;
        margin-top: 5px
    }

    @media (max-width: 1200px) {
        .container {
            padding: 15px
        }

        .top-section {
            grid-template-columns:1fr 1fr;
            gap: 15px
        }

        .tableau {
            gap: 10px
        }
    }

    @media (max-width: 768px) {
        .card, .card-space {
            width: 80px;
            height: 110px
        }

        .header h1 {
            font-size: 2rem
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px
        }
    }

    @media (max-width: 600px) {
        .tableau {
            grid-template-columns:repeat(7, 1fr);
            gap: 5px
        }

        .card, .card-space {
            width: 70px;
            height: 95px
        }

        .top-section {
            grid-template-columns:1fr;
            gap: 10px
        }

        .foundations, .stock-waste {
            justify-content: center
        }
    }</style>
</head>
<body>
<div class="container">
    <header class="header"><h1>â™  Solitaire â™£</h1>
        <div class="controls">
            <button class="btn" onclick="game.newGame()">New Game</button>
            <button class="btn" onclick="game.showHint()">Hint</button>
        </div>
    </header>
    <div class="game-area">
        <div class="top-section">
            <div class="stock-waste">
                <div class="card-space" id="stock-space"></div>
                <div class="card-space" id="waste-space"></div>
            </div>
            <div></div>
            <div></div>
            <div class="foundations">
                <div class="card-space foundation" data-suit="hearts">â™¥</div>
                <div class="card-space foundation" data-suit="diamonds">â™¦</div>
                <div class="card-space foundation" data-suit="clubs">â™£</div>
                <div class="card-space foundation" data-suit="spades">â™ </div>
            </div>
        </div>
        <div class="tableau">
            <div class="card-space">
                <div class="column" data-column="0"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="1"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="2"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="3"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="4"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="5"></div>
            </div>
            <div class="card-space">
                <div class="column" data-column="6"></div>
            </div>
        </div>
    </div>
</div>
<script>class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.faceUp = false;
        this.id = `${suit}_${rank}`
    }

    get color() {
        return ['hearts', 'diamonds'].includes(this.suit) ? 'red' : 'black'
    }

    get value() {
        if (this.rank === 'ace') return 1;
        if (this.rank === 'jack') return 11;
        if (this.rank === 'queen') return 12;
        if (this.rank === 'king') return 13;
        return parseInt(this.rank)
    }

    createElement() {
        const card = document.createElement('div');
        card.className = 'card';
        card.draggable = this.faceUp;
        card.dataset.suit = this.suit;
        card.dataset.rank = this.rank;
        card.dataset.id = this.id;
        if (this.faceUp) {
            card.innerHTML = `<img src="img/cards/${this.rank}_of_${this.suit}.png" alt="${this.rank}of ${this.suit}">`
        } else {
            card.innerHTML = '<div class="card-back">SOLITAIRE</div>';
            card.draggable = false
        }
        this.setupEvents(card);
        return card
    }

    setupEvents(element) {
        element.addEventListener('dragstart', e => {
            if (!this.faceUp) return;
            const sourceInfo = this.getSourceInfo();
            e.dataTransfer.setData('text/plain', JSON.stringify({id: this.id, source: sourceInfo}));
            element.classList.add('dragging')
        });
        element.addEventListener('dragend', () => {
            element.classList.remove('dragging')
        });
        element.addEventListener('dblclick', () => {
            if (this.faceUp) game.tryAutoMove(this)
        });
        element.addEventListener('click', () => {
            if (!this.faceUp && this.isTopCard()) {
                this.faceUp = true;
                game.render()
            }
        })
    }

    getSourceInfo() {
        if (game.waste.length > 0 && game.waste[game.waste.length - 1] === this) return {type: 'waste'};
        for (let suit in game.foundations) {
            if (game.foundations[suit].length > 0 && game.foundations[suit][game.foundations[suit].length - 1] === this) return {
                type: 'foundation',
                suit
            }
        }
        for (let i = 0; i < game.tableau.length; i++) {
            const colIndex = game.tableau[i].indexOf(this);
            if (colIndex !== -1) return {type: 'tableau', column: i, index: colIndex}
        }
        return null
    }

    isTopCard() {
        const source = this.getSourceInfo();
        if (!source) return false;
        if (source.type === 'waste') return true;
        if (source.type === 'foundation') return true;
        if (source.type === 'tableau') {
            return source.index === game.tableau[source.column].length - 1
        }
        return false
    }
}

class SolitaireGame {
    constructor() {
        this.deck = [];
        this.stock = [];
        this.waste = [];
        this.foundations = {hearts: [], diamonds: [], clubs: [], spades: []};
        this.tableau = Array(7).fill().map(() => []);
        this.moveCount = 0;
        this.startTime = Date.now();
        this.init()
    }

    init() {
        this.createDeck();
        this.shuffle();
        this.deal();
        this.render();
        this.setupDropZones()
    }

    createDeck() {
        const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
        const ranks = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king'];
        this.deck = suits.flatMap(suit => ranks.map(rank => new Card(suit, rank)))
    }

    shuffle() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]]
        }
    }

    deal() {
        let deckIndex = 0;
        for (let col = 0; col < 7; col++) {
            for (let row = 0; row <= col; row++) {
                const card = this.deck[deckIndex++];
                if (row === col) card.faceUp = true;
                this.tableau[col].push(card)
            }
        }
        this.stock = this.deck.slice(deckIndex)
    }

    findCard(id) {
        for (let pile of Object.values(this.foundations)) {
            const card = pile.find(c => c.id === id);
            if (card) return card
        }
        for (let column of this.tableau) {
            const card = column.find(c => c.id === id);
            if (card) return card
        }
        return this.waste.find(c => c.id === id) || this.stock.find(c => c.id === id)
    }

    render() {
        this.renderStock();
        this.renderWaste();
        this.renderFoundations();
        this.renderTableau()
    }

    renderStock() {
        const stockSpace = document.getElementById('stock-space');
        stockSpace.innerHTML = '';
        if (this.stock.length > 0) {
            stockSpace.innerHTML = '<div class="card"><div class="card-back">STOCK</div></div>';
            stockSpace.onclick = () => this.drawCard()
        } else {
            stockSpace.innerHTML = 'â†»';
            stockSpace.style.fontSize = '32px';
            stockSpace.style.cursor = 'pointer';
            stockSpace.onclick = () => this.resetStock()
        }
    }

    renderWaste() {
        const wasteSpace = document.getElementById('waste-space');
        wasteSpace.innerHTML = '';
        if (this.waste.length > 0) {
            const topCard = this.waste[this.waste.length - 1];
            wasteSpace.appendChild(topCard.createElement())
        }
    }

    renderFoundations() {
        Object.entries(this.foundations).forEach(([suit, pile]) => {
            const foundation = document.querySelector(`div.foundation[data-suit="${suit}"]`);
            const symbols = {hearts: 'â™¥', diamonds: 'â™¦', clubs: 'â™£', spades: 'â™ '};
            if (pile.length > 0) {
                foundation.innerHTML = '';
                foundation.appendChild(pile[pile.length - 1].createElement())
            } else {
                foundation.innerHTML = symbols[suit]
            }
        })
    }

    renderTableau() {
        this.tableau.forEach((column, colIndex) => {
            const columnElement = document.querySelector(`[data-column="${colIndex}"]`);
            columnElement.innerHTML = '';
            column.forEach((card, cardIndex) => {
                const cardElement = card.createElement();
                const offset = window.innerWidth <= 768 ? 18 : 25;
                cardElement.style.top = `${cardIndex * offset}px`;
                cardElement.style.zIndex = cardIndex + 1;
                columnElement.appendChild(cardElement)
            });
            if (column.length > 0) {
                const offset = window.innerWidth <= 768 ? 18 : 25;
                columnElement.parentElement.style.height = `${140 + (column.length - 1) * offset}px`
            } else {
                columnElement.parentElement.style.height = '140px'
            }
        })
    }

    drawCard() {
        if (this.stock.length > 0) {
            const card = this.stock.pop();
            card.faceUp = true;
            this.waste.push(card);
            this.moveCount++;
            this.render()
        }
    }

    resetStock() {
        if (this.waste.length > 0) {
            this.stock = [...this.waste.reverse()];
            this.stock.forEach(card => card.faceUp = false);
            this.waste = [];
            this.moveCount++;
            this.render()
        }
    }

    setupDropZones() {
        document.querySelectorAll('.column,.foundation,.card-space:not(.foundation)').forEach(zone => {
            zone.addEventListener('dragover', e => {
                e.preventDefault();
                zone.closest('.card-space').classList.add('highlight')
            });
            zone.addEventListener('dragleave', e => {
                if (!zone.contains(e.relatedTarget)) {
                    zone.closest('.card-space').classList.remove('highlight')
                }
            });
            zone.addEventListener('drop', e => {
                e.preventDefault();
                zone.closest('.card-space').classList.remove('highlight');
                try {
                    const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                    this.handleDrop(data, zone)
                } catch (err) {
                    console.error('Drop failed:', err)
                }
            })
        })
    }

    handleDrop(dragData, dropZone) {
        const card = this.findCard(dragData.id);
        if (!card || !card.faceUp) return;
        if (dropZone.classList.contains('foundation')) {
            this.moveToFoundation(card, dropZone.dataset.suit)
        } else if (dropZone.dataset.column !== undefined) {
            this.moveToTableau(card, parseInt(dropZone.dataset.column))
        } else if (dropZone.classList.contains('card-space') && !dropZone.classList.contains('foundation')) {
            const column = dropZone.querySelector('.column');
            if (column && column.dataset.column !== undefined) {
                this.moveToTableau(card, parseInt(column.dataset.column))
            }
        }
    }

    moveToFoundation(card, targetSuit) {
        if (card.suit !== targetSuit) return false;
        const foundation = this.foundations[targetSuit];
        if (foundation.length === 0 && card.rank !== 'ace') return false;
        if (foundation.length > 0 && card.value !== foundation[foundation.length - 1].value + 1) return false;
        if (!this.isCardMoveable(card)) return false;
        this.removeCardFromSource(card);
        foundation.push(card);
        this.moveCount++;
        this.render();
        this.checkWin();
        return true
    }

    moveToTableau(card, targetColumn) {
        const column = this.tableau[targetColumn];
        const sequence = this.getMovableSequence(card);
        if (!sequence || !this.canPlaceSequenceOnColumn(sequence, column)) return false;
        this.removeCardFromSource(card);
        column.push(...sequence);
        this.moveCount++;
        this.flipTopCards();
        this.render();
        return true
    }

    getMovableSequence(card) {
        const source = card.getSourceInfo();
        if (!source || source.type !== 'tableau') return [card];
        const column = this.tableau[source.column];
        const startIndex = source.index;
        const sequence = column.slice(startIndex);
        for (let i = 1; i < sequence.length; i++) {
            const prev = sequence[i - 1];
            const curr = sequence[i];
            if (!curr.faceUp || curr.value !== prev.value - 1 || curr.color === prev.color) {
                return sequence.slice(0, i)
            }
        }
        return sequence
    }

    canPlaceSequenceOnColumn(sequence, column) {
        if (!sequence || sequence.length === 0) return false;
        const firstCard = sequence[0];
        if (column.length === 0) return firstCard.rank === 'king';
        const topCard = column[column.length - 1];
        return topCard.faceUp && topCard.value === firstCard.value + 1 && topCard.color !== firstCard.color
    }

    isCardMoveable(card) {
        const source = card.getSourceInfo();
        if (!source) return false;
        if (source.type === 'waste') return this.waste[this.waste.length - 1] === card;
        if (source.type === 'foundation') return this.foundations[source.suit][this.foundations[source.suit].length - 1] === card;
        if (source.type === 'tableau') return this.tableau[source.column][source.index] === card;
        return false
    }

    removeCardFromSource(card) {
        const source = card.getSourceInfo();
        if (!source) return;
        if (source.type === 'waste') {
            this.waste.pop()
        } else if (source.type === 'foundation') {
            this.foundations[source.suit].pop()
        } else if (source.type === 'tableau') {
            const column = this.tableau[source.column];
            const sequence = this.getMovableSequence(card);
            column.splice(source.index, sequence.length)
        }
    }

    flipTopCards() {
        this.tableau.forEach(column => {
            if (column.length > 0 && !column[column.length - 1].faceUp) {
                column[column.length - 1].faceUp = true
            }
        })
    }

    tryAutoMove(card) {
        for (let suit of Object.keys(this.foundations)) {
            if (this.moveToFoundation(card, suit)) return true
        }
        return false
    }

    showHint() {
        const moves = this.findPossibleMoves();
        if (moves.length > 0) {
            const hint = moves[0];
            alert(`Hint:Move ${hint.card.rank}of ${hint.card.suit}to ${hint.destination}`)
        } else {
            alert('No obvious moves available. Try drawing from the stock pile or look for face-down cards to flip.')
        }
    }

    findPossibleMoves() {
        const moves = [];
        this.tableau.forEach((column, colIndex) => {
            if (column.length > 0) {
                const topCard = column[column.length - 1];
                if (topCard.faceUp) {
                    Object.keys(this.foundations).forEach(suit => {
                        if (this.canMoveToFoundation(topCard, suit)) {
                            moves.push({card: topCard, destination: `${suit}foundation`})
                        }
                    });
                    this.tableau.forEach((targetCol, targetIndex) => {
                        if (targetIndex !== colIndex && this.canPlaceSequenceOnColumn([topCard], targetCol)) {
                            moves.push({card: topCard, destination: `column ${targetIndex + 1}`})
                        }
                    })
                }
            }
        });
        if (this.waste.length > 0) {
            const wasteCard = this.waste[this.waste.length - 1];
            Object.keys(this.foundations).forEach(suit => {
                if (this.canMoveToFoundation(wasteCard, suit)) {
                    moves.push({card: wasteCard, destination: `${suit}foundation`})
                }
            });
            this.tableau.forEach((column, colIndex) => {
                if (this.canPlaceSequenceOnColumn([wasteCard], column)) {
                    moves.push({card: wasteCard, destination: `column ${colIndex + 1}`})
                }
            })
        }
        return moves
    }

    canMoveToFoundation(card, suit) {
        if (card.suit !== suit) return false;
        const foundation = this.foundations[suit];
        return foundation.length === 0 ? card.rank === 'ace' : card.value === foundation[foundation.length - 1].value + 1
    }

    checkWin() {
        const total = Object.values(this.foundations).reduce((sum, pile) => sum + pile.length, 0);
        if (total === 52) {
            setTimeout(() => this.showWinModal(), 500)
        }
    }

    showWinModal() {
        const playTime = Math.floor((Date.now() - this.startTime) / 1000);
        const modal = document.createElement('div');
        modal.className = 'win-modal';
        modal.innerHTML = `<div class="win-content"><h2>ðŸŽ‰ Congratulations!</h2><p>You solved the game!</p><div class="stats"><div class="stat"><div class="stat-value">${this.moveCount}</div><div class="stat-label">Moves</div></div><div class="stat"><div class="stat-value">${Math.floor(playTime / 60)}:${(playTime % 60).toString().padStart(2, '0')}</div><div class="stat-label">Time</div></div></div><button class="btn" onclick="this.closest('.win-modal').remove();game.newGame()">New Game</button></div>`;
        document.body.appendChild(modal)
    }

    newGame() {
        document.querySelector('.win-modal')?.remove();
        this.deck = [];
        this.stock = [];
        this.waste = [];
        this.foundations = {hearts: [], diamonds: [], clubs: [], spades: []};
        this.tableau = Array(7).fill().map(() => []);
        this.moveCount = 0;
        this.startTime = Date.now();
        this.init()
    }
}

const game = new SolitaireGame();</script>
<script src="../logo.js"></script>
</body>
</html>