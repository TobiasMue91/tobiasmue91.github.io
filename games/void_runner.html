<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
    <meta name="description" content="VOID RUNNER - An endless sidescroller where you jump, double jump and slide through an ever-accelerating void. Collect orbs, chain combos and survive as long as you can.">
    <meta name="author" content="Claude Opus 4.6 prompted by Tobias Müller">
    <meta name="keywords" content="void runner, endless runner, browser game, sidescroller, HTML5 game, free online game">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/void_runner.html">
    <meta property="og:title" content="VOID RUNNER - Endless Sidescroller">
    <meta property="og:description" content="Jump, slide and survive through an ever-accelerating void. Collect orbs, chain combos and chase your high score.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/void_runner.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_244.webp">
    <meta property="og:site_name" content="GPT Games">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="VOID RUNNER - Endless Sidescroller">
    <meta name="twitter:description" content="Jump, slide and survive through an ever-accelerating void. Collect orbs, chain combos and chase your high score.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_244.webp">
    <title>VOID RUNNER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            background: #08080c;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            touch-action: none;
            user-select: none
        }

        canvas {
            display: block
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: none;
            padding: 16px 22px;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 2
        }

        .hud-block {
            display: flex;
            flex-direction: column;
            gap: 1px
        }

        .hud-label {
            font-size: 9px;
            color: #ffffff28;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 600
        }

        .hud-val {
            color: #fff;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            font-variant-numeric: tabular-nums
        }

        .hud-right {
            text-align: right
        }

        #hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px
        }

        #phaseDisp {
            font-size: 9px;
            color: #00e5ff50;
            letter-spacing: 4px;
            font-weight: 700;
            transition: color .5s
        }

        #combo {
            color: #00e5ff;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity .15s;
            text-transform: uppercase
        }

        #milestone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 28px;
            font-weight: 800;
            letter-spacing: 6px;
            opacity: 0;
            pointer-events: none
        }

        #mute-btn {
            position: absolute;
            top: 16px;
            right: 22px;
            pointer-events: auto;
            background: none;
            border: 1px solid #ffffff15;
            color: #ffffff50;
            width: 32px;
            height: 32px;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3
        }

        #mute-btn:hover {
            border-color: #ffffff30;
            color: #ffffff80
        }

        #pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #08080cdd;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            pointer-events: auto
        }

        #pause-overlay h2 {
            color: #fff;
            font-size: clamp(22px, 5vw, 36px);
            font-weight: 800;
            letter-spacing: 8px
        }

        #menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            pointer-events: auto
        }

        #menu h1 {
            font-size: clamp(30px, 8vw, 64px);
            color: #fff;
            font-weight: 800;
            letter-spacing: 8px
        }

        .accent {
            color: #00e5ff
        }

        #menu .sub {
            color: #ffffff30;
            font-size: 11px;
            letter-spacing: 5px;
            font-weight: 500;
            margin-top: -4px
        }

        .btn-main {
            margin-top: 16px;
            padding: 14px 52px;
            background: #fff;
            color: #08080c;
            border: none;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 4px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform .1s
        }

        .btn-main:hover {
            transform: scale(1.03)
        }

        .btn-main:active {
            transform: scale(0.97)
        }

        #menu .controls {
            margin-top: 10px;
            color: #ffffff18;
            font-size: 10px;
            letter-spacing: 2px;
            text-align: center;
            line-height: 2.4
        }

        #death {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto
        }

        #death h2 {
            font-size: clamp(22px, 5vw, 40px);
            color: #ff3d71;
            font-weight: 800;
            letter-spacing: 6px
        }

        .final-score {
            font-size: 48px;
            color: #fff;
            font-weight: 800;
            letter-spacing: 2px;
            font-variant-numeric: tabular-nums
        }

        .stat-row {
            display: flex;
            gap: 36px;
            margin: 6px 0
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px
        }

        .stat-label {
            font-size: 9px;
            color: #ffffff25;
            letter-spacing: 2px;
            text-transform: uppercase
        }

        .stat-val {
            font-size: 17px;
            color: #ffffff80;
            font-weight: 700;
            font-variant-numeric: tabular-nums
        }

        .best-tag {
            color: #ffffff25;
            font-size: 11px;
            letter-spacing: 3px;
            font-variant-numeric: tabular-nums
        }

        .new-best {
            color: #00e5ff;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 3px;
            display: none
        }

        #flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity .4s
        }
    </style>
</head>
<body>
<canvas id="gc"></canvas>
<div id="flash"></div>
<div id="ui">
    <div id="hud">
        <div class="hud-block"><span class="hud-label">Score</span><span class="hud-val" id="scoreDisp">0</span></div>
        <div id="hud-center"><span id="phaseDisp">DRIFT</span><span id="combo"></span></div>
        <div class="hud-block hud-right"><span class="hud-label">Best</span><span class="hud-val" id="bestDisp">0</span>
        </div>
    </div>
    <button id="mute-btn">♪</button>
    <div id="milestone"></div>
    <div id="pause-overlay"><h2>PAUSED</h2>
        <button class="btn-main" id="resumeBtn">RESUME</button>
    </div>
    <div id="menu">
        <h1>VOID<span class="accent">RUNNER</span></h1>
        <div class="sub">ENDLESS SIDESCROLLER</div>
        <button class="btn-main" id="startBtn">START</button>
        <div class="controls">SPACE / TAP — JUMP · DOUBLE JUMP<br>DOWN / SWIPE — SLIDE · P — PAUSE</div>
    </div>
    <div id="death">
        <h2>VOID CLAIMED</h2>
        <div class="new-best" id="newBest">★ NEW BEST ★</div>
        <div class="final-score" id="finalScore">0</div>
        <div class="stat-row">
            <div class="stat"><span class="stat-label">Distance</span><span class="stat-val" id="deathDist">0m</span>
            </div>
            <div class="stat"><span class="stat-label">Orbs</span><span class="stat-val" id="deathOrbs">0</span></div>
            <div class="stat"><span class="stat-label">Near Misses</span><span class="stat-val" id="deathNear">0</span>
            </div>
        </div>
        <div class="best-tag" id="deathBest">BEST: 0</div>
        <button class="btn-main" id="restartBtn">TRY AGAIN</button>
    </div>
</div>
<script>
    const C = document.getElementById('gc'), X = C.getContext('2d');
    const hud = document.getElementById('hud'), menuEl = document.getElementById('menu'),
        deathEl = document.getElementById('death');
    const pauseEl = document.getElementById('pause-overlay'), flashEl = document.getElementById('flash');
    const scoreDisp = document.getElementById('scoreDisp'), bestDisp = document.getElementById('bestDisp');
    const comboEl = document.getElementById('combo'), milestoneEl = document.getElementById('milestone');
    const finalScoreEl = document.getElementById('finalScore'), deathBestEl = document.getElementById('deathBest');
    const newBestEl = document.getElementById('newBest'), deathDistEl = document.getElementById('deathDist');
    const deathOrbsEl = document.getElementById('deathOrbs'), deathNearEl = document.getElementById('deathNear');
    const phaseDisp = document.getElementById('phaseDisp'), muteBtn = document.getElementById('mute-btn');
    let W, H, state = 'menu', score = 0, displayScore = 0, best = parseInt(localStorage.getItem('vr_best')) || 0;
    let gameSpeed, distTraveled, shakeTimer = 0, shakeIntensity = 0, slowMo = 1, slowMoTimer = 0;
    let orbsCollected = 0, nearMisses = 0, comboCount = 0, comboTimer = 0, nextMilestone = 100, paused = false;
    let muted = localStorage.getItem('vr_mute') === '1';
    let graceTimer = 0;
    bestDisp.textContent = best;
    muteBtn.textContent = muted ? '✕' : '♪';

    function resize() {
        W = C.width = window.innerWidth;
        H = C.height = window.innerHeight
    }

    window.addEventListener('resize', resize);
    resize();
    const AC = new (window.AudioContext || window.webkitAudioContext)();

    function snd(freq, type, dur, vol = 0.12, slide = 0) {
        if (muted) return;
        const o = AC.createOscillator(), g = AC.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, AC.currentTime);
        if (slide) o.frequency.linearRampToValueAtTime(freq + slide, AC.currentTime + dur);
        g.gain.setValueAtTime(vol, AC.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime + dur);
        o.connect(g);
        g.connect(AC.destination);
        o.start();
        o.stop(AC.currentTime + dur)
    }

    function sfxJump() {
        snd(320, 'square', .12, .06, 200)
    }

    function sfxDblJump() {
        snd(480, 'square', .1, .05, 300)
    }

    function sfxOrb() {
        snd(800, 'sine', .15, .08, 200)
    }

    function sfxDeath() {
        snd(120, 'sawtooth', .4, .18, -80);
        setTimeout(() => snd(80, 'square', .3, .12, -40), 100)
    }

    function sfxSlide() {
        snd(150, 'triangle', .08, .04, 50)
    }

    function sfxLand() {
        snd(80, 'triangle', .06, .04, 10)
    }

    function sfxMilestone() {
        snd(600, 'sine', .15, .1, 200);
        setTimeout(() => snd(900, 'sine', .12, .08, 100), 80)
    }

    function sfxCombo() {
        snd(1000, 'sine', .1, .06, 300)
    }

    function sfxNear() {
        snd(500, 'sine', .08, .05, 150)
    }

    let stars = [];

    function initStars() {
        stars = [];
        for (let i = 0; i < 70; i++) stars.push({
            x: Math.random() * W,
            y: Math.random() * H,
            sz: .4 + Math.random() * 1.5,
            sp: .1 + Math.random() * .5,
            br: .1 + Math.random() * .35
        })
    }

    let floats = [];

    function addFloat(x, y, txt, col) {
        floats.push({x, y, txt, col, life: 1})
    }

    let particles = [];

    class Particle {
        constructor(x, y, vx, vy, sz, col, life) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.sz = sz;
            this.col = col;
            this.life = life;
            this.ml = life;
            this.active = true
        }

        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.life -= dt;
            if (this.life <= 0) this.active = false
        }

        draw() {
            const a = this.life / this.ml;
            X.globalAlpha = a;
            X.fillStyle = this.col;
            X.fillRect(this.x - this.sz / 2, this.y - this.sz / 2, this.sz, this.sz);
            X.globalAlpha = 1
        }
    }

    function emit(x, y, n, col, spd = 100, sz = 3, life = .5) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2, s = Math.random() * spd;
            particles.push(new Particle(x, y, Math.cos(a) * s, Math.sin(a) * s, sz * (.5 + Math.random()), col, life * (.5 + Math.random())))
        }
    }

    const P = {
        x: 0,
        y: 0,
        w: 22,
        h: 34,
        vy: 0,
        onGround: false,
        jumps: 0,
        maxJumps: 2,
        sliding: false,
        slideTimer: 0,
        slideDur: .45,
        dead: false,
        baseH: 34,
        slideH: 15,
        trail: [],
        runFrame: 0,
        runTimer: 0,
        landSquash: 0,
        wasInAir: false
    };
    let platforms = [], obstacles = [], orbs = [];
    const GRAVITY = 1900, JUMP_VEL = -640, PH = 14, GAP_MIN = 100;
    let nextPlatX = 0, diffMul = 0, lastPlatY = 0;
    const PHASES = [{n: 'DRIFT', t: 0, c: '#00e5ff'}, {n: 'SURGE', t: 1.5, c: '#7b61ff'}, {
        n: 'ABYSS',
        t: 3.5,
        c: '#ff6b35'
    }, {n: 'CORE', t: 6, c: '#ff3d71'}, {n: 'VOID', t: 10, c: '#ff1a47'}];

    function getPhase() {
        for (let i = PHASES.length - 1; i >= 0; i--) if (diffMul >= PHASES[i].t) return PHASES[i];
        return PHASES[0]
    }

    function genPlat(absx) {
        const sx = absx - distTraveled;
        const w = 130 + Math.random() * 240;
        const yBase = lastPlatY || H * .62;
        const yOff = (Math.random() - .5) * 80;
        const y = Math.max(H * .35, Math.min(H * .78, yBase + yOff));
        lastPlatY = y;
        const crumble = Math.random() < Math.min(.08 + diffMul * .04, .2);
        const moving = !crumble && Math.random() < Math.min(diffMul * .06, .15);
        const moveAmp = moving ? 20 + Math.random() * 25 : 0;
        const moveSp = moving ? 1.5 + Math.random() * 1.5 : 0;
        platforms.push({
            x: sx,
            y,
            w,
            h: PH,
            crumble,
            crumbleTimer: 0,
            crumbling: false,
            fallen: false,
            vy: 0,
            moving,
            moveAmp,
            moveSp,
            movePhase: Math.random() * Math.PI * 2,
            baseY: y
        });
        const baseGap = 100 + Math.random() * 80;
        const diffGap = baseGap + diffMul * 25;
        const gap = Math.min(diffGap, gameSpeed * 0.62);
        if (Math.random() < Math.min(.25 + diffMul * .12, .65) && w > 160) {
            const ox = sx + 50 + Math.random() * (w - 100);
            const r = Math.random();
            if (r < .3) obstacles.push({x: ox, y: y - 18, w: 18, h: 18, type: 'spike', passed: false});
            else if (r < .5) obstacles.push({x: ox, y: y - 42, w: 14, h: 42, type: 'wall', passed: false});
            else if (r < .7) obstacles.push({
                x: ox - 10,
                y: y - 38,
                w: Math.min(50 + diffMul * 10, 90),
                h: 14,
                type: 'beam',
                passed: false
            });
            else if (r < .85 && diffMul > .5) obstacles.push({
                x: ox,
                y: y - 10,
                w: 28,
                h: 10,
                type: 'hurdle',
                passed: false
            });
            else if (diffMul > 1) obstacles.push({x: ox, y: y - 60, w: 12, h: 60, type: 'pylon', passed: false})
        }
        if (Math.random() < .5) {
            const n = 2 + Math.floor(Math.random() * 4);
            const startX = sx + 30, arcW = Math.min(n * 30, w - 60);
            for (let i = 0; i < n; i++) {
                const t = n > 1 ? i / (n - 1) : .5;
                orbs.push({
                    x: startX + t * arcW,
                    y: y - 40 - Math.sin(t * Math.PI) * (30 + Math.random() * 30),
                    sz: 7,
                    collected: false,
                    bob: Math.random() * Math.PI * 2
                })
            }
        }
        nextPlatX = absx + w + gap
    }

    function initGame() {
        score = 0;
        displayScore = 0;
        distTraveled = 0;
        gameSpeed = 280;
        diffMul = 0;
        shakeTimer = 0;
        slowMo = 1;
        slowMoTimer = 0;
        orbsCollected = 0;
        nearMisses = 0;
        comboCount = 0;
        comboTimer = 0;
        nextMilestone = 100;
        paused = false;
        graceTimer = 1.2;
        lastPlatY = H * .62;
        P.x = W * .2;
        P.y = H * .5;
        P.vy = 0;
        P.onGround = false;
        P.jumps = 0;
        P.sliding = false;
        P.slideTimer = 0;
        P.h = P.baseH;
        P.dead = false;
        P.trail = [];
        P.runFrame = 0;
        P.runTimer = 0;
        P.landSquash = 0;
        P.wasInAir = false;
        platforms = [];
        obstacles = [];
        orbs = [];
        particles = [];
        floats = [];
        nextPlatX = 0;
        platforms.push({
            x: -50,
            y: H * .62,
            w: W * .45,
            h: PH,
            crumble: false,
            crumbleTimer: 0,
            crumbling: false,
            fallen: false,
            vy: 0,
            moving: false,
            moveAmp: 0,
            moveSp: 0,
            movePhase: 0,
            baseY: H * .62
        });
        nextPlatX = W * .45 - 50;
        for (let i = 0; i < 14; i++) genPlat(nextPlatX);
        initStars()
    }

    function doJump() {
        if (P.dead) return;
        if (P.jumps < P.maxJumps) {
            P.vy = JUMP_VEL * (P.jumps === 1 ? .85 : 1);
            P.jumps++;
            P.onGround = false;
            if (P.sliding) {
                P.sliding = false;
                P.h = P.baseH;
                P.y -= (P.baseH - P.slideH)
            }
            P.jumps === 1 ? sfxJump() : sfxDblJump();
            emit(P.x + P.w / 2, P.y + P.h, 6, '#ffffff60', 70, 2.5, .25)
        }
    }

    function doSlide() {
        if (P.dead || P.sliding || !P.onGround) return;
        P.sliding = true;
        P.slideTimer = P.slideDur;
        P.y += (P.baseH - P.slideH);
        P.h = P.slideH;
        sfxSlide()
    }

    function togglePause() {
        if (state !== 'playing' || P.dead) return;
        paused = !paused;
        pauseEl.style.display = paused ? 'flex' : 'none'
    }

    function toggleMute() {
        muted = !muted;
        localStorage.setItem('vr_mute', muted ? '1' : '0');
        muteBtn.textContent = muted ? '✕' : '♪'
    }

    document.addEventListener('keydown', e => {
        if (e.repeat) return;
        if (e.code === 'KeyP' || e.code === 'Escape') {
            e.preventDefault();
            togglePause();
            return
        }
        if (paused) return;
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
            e.preventDefault();
            if (state === 'playing') doJump(); else if (state === 'menu') startGame(); else if (state === 'dead') restartGame()
        }
        if ((e.code === 'ArrowDown' || e.code === 'KeyS') && state === 'playing') {
            e.preventDefault();
            doSlide()
        }
    });
    let touchStartY = 0, touchActive = false;
    C.addEventListener('touchstart', e => {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        touchActive = true;
        if (paused) {
            togglePause();
            return
        }
        if (state === 'playing') doJump(); else if (state === 'menu') startGame(); else if (state === 'dead') restartGame()
    }, {passive: false});
    C.addEventListener('touchmove', e => {
        e.preventDefault();
        if (touchActive && state === 'playing' && !paused) {
            if (e.touches[0].clientY - touchStartY > 30) {
                doSlide();
                touchActive = false
            }
        }
    }, {passive: false});
    C.addEventListener('touchend', () => {
        touchActive = false
    });
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    document.getElementById('resumeBtn').addEventListener('click', togglePause);
    muteBtn.addEventListener('click', e => {
        e.stopPropagation();
        toggleMute()
    });

    function startGame() {
        if (AC.state === 'suspended') AC.resume();
        state = 'playing';
        menuEl.style.display = 'none';
        deathEl.style.display = 'none';
        hud.style.display = 'flex';
        muteBtn.style.display = 'flex';
        initGame()
    }

    function restartGame() {
        state = 'playing';
        deathEl.style.display = 'none';
        hud.style.display = 'flex';
        muteBtn.style.display = 'flex';
        initGame()
    }

    function showMilestone(txt) {
        milestoneEl.textContent = txt;
        milestoneEl.style.opacity = '1';
        milestoneEl.style.transition = 'none';
        milestoneEl.style.transform = 'translate(-50%,-50%) scale(1.1)';
        setTimeout(() => {
            milestoneEl.style.transition = 'opacity .6s,transform .6s';
            milestoneEl.style.opacity = '0';
            milestoneEl.style.transform = 'translate(-50%,-50%) scale(0.95)'
        }, 200)
    }

    function die() {
        if (P.dead) return;
        P.dead = true;
        sfxDeath();
        emit(P.x + P.w / 2, P.y + P.h / 2, 30, '#ff3d71', 220, 4, .8);
        emit(P.x + P.w / 2, P.y + P.h / 2, 20, '#ffffff', 180, 3, .6);
        shakeTimer = .5;
        shakeIntensity = 14;
        slowMo = .15;
        slowMoTimer = .5;
        flashEl.style.transition = 'none';
        flashEl.style.opacity = '.2';
        setTimeout(() => {
            flashEl.style.transition = 'opacity .4s';
            flashEl.style.opacity = '0'
        }, 30);
        const s = Math.floor(score), isNew = s > best;
        if (isNew) {
            best = s;
            localStorage.setItem('vr_best', best)
        }
        setTimeout(() => {
            state = 'dead';
            hud.style.display = 'none';
            deathEl.style.display = 'flex';
            finalScoreEl.textContent = s;
            deathBestEl.textContent = 'BEST: ' + best;
            bestDisp.textContent = best;
            deathDistEl.textContent = Math.floor(distTraveled / 50) + 'm';
            deathOrbsEl.textContent = orbsCollected;
            deathNearEl.textContent = nearMisses;
            newBestEl.style.display = isNew ? 'block' : 'none'
        }, 700)
    }

    function aabb(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y
    }

    function lerpCol(a, b, t) {
        t = Math.max(0, Math.min(1, t));
        const p = parseInt;
        const r1 = p(a.slice(1, 3), 16), g1 = p(a.slice(3, 5), 16), b1 = p(a.slice(5, 7), 16);
        const r2 = p(b.slice(1, 3), 16), g2 = p(b.slice(3, 5), 16), b2 = p(b.slice(5, 7), 16);
        return '#' + ((Math.round(r1 + (r2 - r1) * t) << 16) | (Math.round(g1 + (g2 - g1) * t) << 8) | Math.round(b1 + (b2 - b1) * t)).toString(16).padStart(6, '0')
    }

    function checkNearMiss(o) {
        if (o.passed || graceTimer > 0) return;
        const px = P.x + P.w / 2, ox = o.x + o.w / 2;
        if (px > ox) {
            o.passed = true;
            const m = 14;
            const ex = {x: o.x - m, y: o.y - m, w: o.w + m * 2, h: o.h + m * 2};
            if (aabb(P, ex)) {
                nearMisses++;
                score += 15;
                sfxNear();
                addFloat(P.x + P.w / 2, P.y - 10, 'CLOSE! +15', '#00e5ff');
                emit(P.x + P.w / 2, P.y + P.h / 2, 5, '#00e5ff40', 50, 2, .2)
            }
        }
    }

    let lastTime = 0;

    function update(dt) {
        if (paused) return;
        if (slowMoTimer > 0) {
            slowMoTimer -= dt;
            if (slowMoTimer <= 0) slowMo = 1
        }
        const rdt = dt * slowMo;
        floats.forEach(f => {
            f.life -= dt;
            f.y -= 40 * dt
        });
        floats = floats.filter(f => f.life > 0);
        particles.forEach(p => p.update(rdt));
        for (let i = particles.length - 1; i >= 0; i--) if (!particles[i].active) particles.splice(i, 1);
        if (state !== 'playing' || P.dead) return;
        if (graceTimer > 0) graceTimer -= rdt;
        diffMul = distTraveled / 3000;
        const phase = getPhase();
        phaseDisp.textContent = phase.n;
        phaseDisp.style.color = phase.c + '80';
        const speedTarget = 280 + diffMul * 140;
        gameSpeed += (speedTarget - gameSpeed) * dt * 2;
        const scroll = gameSpeed * rdt;
        distTraveled += scroll;
        score += rdt * (10 + diffMul * 5);
        displayScore += (score - displayScore) * Math.min(dt * 12, 1);
        scoreDisp.textContent = Math.floor(displayScore);
        if (score >= nextMilestone) {
            sfxMilestone();
            showMilestone(Math.floor(nextMilestone));
            nextMilestone = nextMilestone < 500 ? nextMilestone + 100 : nextMilestone + 250
        }
        const dist = Math.floor(distTraveled / 50);
        if (dist > 0 && dist % 500 === 0 && Math.floor((distTraveled - scroll) / 50) % 500 !== 0) {
            addFloat(P.x + P.w, P.y - 30, dist + 'm', '#ffffff60')
        }
        if (comboTimer > 0) {
            comboTimer -= rdt;
            if (comboTimer <= 0) {
                comboCount = 0;
                comboEl.style.opacity = '0'
            }
        }
        if (P.sliding) {
            P.slideTimer -= rdt;
            if (P.slideTimer <= 0) {
                P.sliding = false;
                P.y -= (P.baseH - P.slideH);
                P.h = P.baseH
            }
        }
        P.vy += GRAVITY * rdt;
        P.y += P.vy * rdt;
        P.onGround = false;
        if (P.landSquash > 0) P.landSquash -= dt * 6;
        if (P.onGround && !P.sliding) {
            P.runTimer += rdt * gameSpeed * .015;
            if (P.runTimer > 1) {
                P.runTimer = 0;
                P.runFrame = (P.runFrame + 1) % 4
            }
        }
        stars.forEach(s => {
            s.x -= scroll * s.sp * .08;
            if (s.x < -5) {
                s.x = W + 5;
                s.y = Math.random() * H
            }
        });
        for (const p of platforms) {
            if (p.fallen) {
                p.vy += 600 * rdt;
                p.y += p.vy * rdt;
                p.x -= scroll;
                continue
            }
            p.x -= scroll;
            if (p.moving && !p.crumbling) {
                p.movePhase += rdt * p.moveSp;
                p.y = p.baseY + Math.sin(p.movePhase) * p.moveAmp
            }
            if (p.crumbling) {
                p.crumbleTimer -= rdt;
                if (p.crumbleTimer <= 0) {
                    p.fallen = true;
                    p.vy = 0;
                    continue
                }
                p.x += Math.sin(performance.now() * .05) * 1.5
            }
            if (P.vy >= 0 && P.x + P.w > p.x + 4 && P.x < p.x + p.w - 4 && P.y + P.h >= p.y && P.y + P.h <= p.y + p.h + P.vy * rdt + 4) {
                P.y = p.y - P.h;
                P.vy = 0;
                P.onGround = true;
                P.jumps = 0;
                if (P.wasInAir) {
                    P.landSquash = 1;
                    sfxLand();
                    emit(P.x + P.w / 2, P.y + P.h, 4, '#ffffff30', 40, 2, .2)
                }
                if (p.crumble && !p.crumbling) {
                    p.crumbling = true;
                    p.crumbleTimer = .45
                }
            }
        }
        P.wasInAir = !P.onGround;
        for (const o of obstacles) {
            o.x -= scroll;
            const skip = ((o.type === 'beam' || o.type === 'wall') && P.sliding) || (o.type === 'hurdle' && P.sliding);
            if (!skip && graceTimer <= 0 && aabb(P, o)) {
                die();
                return
            }
            if (skip || !aabb(P, o)) checkNearMiss(o)
        }
        for (const o of orbs) {
            o.x -= scroll;
            o.bob += rdt * 3;
            if (!o.collected) {
                const by = o.y + Math.sin(o.bob) * 5;
                if (aabb({x: P.x - 3, y: P.y - 3, w: P.w + 6, h: P.h + 6}, {
                    x: o.x - o.sz,
                    y: by - o.sz,
                    w: o.sz * 2,
                    h: o.sz * 2
                })) {
                    o.collected = true;
                    orbsCollected++;
                    const orbVal = 25 + Math.floor(diffMul * 10);
                    score += orbVal;
                    sfxOrb();
                    emit(o.x, by, 8, '#00e5ff', 100, 2.5, .35);
                    comboCount++;
                    comboTimer = 1.5;
                    if (comboCount >= 3) {
                        sfxCombo();
                        const bonus = comboCount * 5;
                        score += bonus;
                        comboEl.textContent = 'COMBO x' + comboCount + ' +' + bonus;
                        comboEl.style.opacity = '1';
                        addFloat(o.x, by - 15, 'x' + comboCount, '#00e5ff')
                    } else addFloat(o.x, by - 10, '+' + orbVal, '#00e5ff')
                }
            }
        }
        if (P.y > H + 120) {
            die();
            return
        }
        while (nextPlatX < distTraveled + W * 1.5) genPlat(nextPlatX);
        platforms = platforms.filter(p => p.x + p.w > -100 && p.y < H + 200);
        obstacles = obstacles.filter(o => o.x + o.w > -100);
        orbs = orbs.filter(o => o.x > -100);
        P.trail.unshift({x: P.x + P.w / 2, y: P.y + P.h / 2, a: 1});
        if (P.trail.length > 12) P.trail.pop();
        P.trail.forEach(t => t.a *= .8);
        if (P.onGround && !P.sliding && Math.random() < .25) particles.push(new Particle(P.x + P.w / 2, P.y + P.h, -20 - Math.random() * 30, -5 - Math.random() * 20, 1.5 + Math.random() * 1.5, '#ffffff20', .25 + Math.random() * .15));
        if (diffMul > .5 && Math.random() < Math.min(diffMul * .12, .35)) {
            const sy = Math.random() * H;
            particles.push(new Particle(W + 10, sy, -gameSpeed * 2 - Math.random() * 200, 0, 1, '#ffffff08', .15 + Math.random() * .1))
        }
        if (shakeTimer > 0) shakeTimer -= dt
    }

    // Draw
    function draw() {
        X.save();
        if (shakeTimer > 0) {
            const s = shakeIntensity * (shakeTimer / .5);
            X.translate((Math.random() - .5) * s, (Math.random() - .5) * s)
        }
        const bgCol = lerpCol('#08080c', '#0c0814', Math.min(diffMul / 2, 1));
        X.fillStyle = bgCol;
        X.fillRect(0, 0, W, H);
// Stars
        for (const s of stars) {
            X.globalAlpha = s.br;
            X.fillStyle = '#fff';
            X.fillRect(s.x, s.y, s.sz, s.sz);
            X.globalAlpha = 1
        }
// Horizon glow
        const glowY = H * .6, glowA = .04 + Math.min(diffMul * .02, .06);
        const grd = X.createRadialGradient(W / 2, glowY, 0, W / 2, glowY, W * .6);
        const ac = getPhase().c;
        grd.addColorStop(0, ac + '0a');
        grd.addColorStop(1, 'transparent');
        X.fillStyle = grd;
        X.fillRect(0, 0, W, H);
// Platforms
        const platCol = lerpCol('#14142a', '#1a1028', Math.min(diffMul / 3, 1));
        const platEdge = lerpCol('#22224a', '#2e2048', Math.min(diffMul / 3, 1));
        for (const p of platforms) {
            if (p.fallen && p.y > H + 50) continue;
            let alpha = 1;
            if (p.crumbling && !p.fallen) alpha = .4 + Math.sin(performance.now() * .03) * .3;
            X.globalAlpha = alpha;
            if (p.moving && !p.crumbling) {
                X.fillStyle = '#1a1a3a';
                X.fillRect(p.x, p.y, p.w, p.h);
                X.fillStyle = '#2a2a5a';
                X.fillRect(p.x, p.y, p.w, 2)
            } else {
                X.fillStyle = platCol;
                X.fillRect(p.x, p.y, p.w, p.h);
                X.fillStyle = platEdge;
                X.fillRect(p.x, p.y, p.w, 2)
            }
            X.fillStyle = 'rgba(0,0,0,.3)';
            X.fillRect(p.x + 2, p.y + p.h, p.w - 2, 4);
            X.globalAlpha = 1
        }
// Obstacles
        for (const o of obstacles) {
            if (o.type === 'spike') {
                X.fillStyle = '#ff3d71';
                X.beginPath();
                X.moveTo(o.x, o.y + o.h);
                X.lineTo(o.x + o.w / 2, o.y);
                X.lineTo(o.x + o.w, o.y + o.h);
                X.fill();
                X.fillStyle = '#ff3d7118';
                X.fillRect(o.x - 3, o.y + o.h - 3, o.w + 6, 6)
            } else if (o.type === 'wall') {
                X.fillStyle = '#ff3d71';
                X.fillRect(o.x, o.y, o.w, o.h);
                X.fillStyle = '#ff3d7120';
                X.fillRect(o.x - 2, o.y - 2, o.w + 4, o.h + 4)
            } else if (o.type === 'beam') {
                X.fillStyle = '#ff3d71';
                X.fillRect(o.x, o.y, o.w, o.h);
                X.fillStyle = '#ff3d7120';
                X.fillRect(o.x - 2, o.y - 2, o.w + 4, o.h + 4);
                X.fillStyle = '#ff3d7140';
                for (let i = 0; i < o.w; i += 12) X.fillRect(o.x + i, o.y, 6, o.h)
            } else if (o.type === 'hurdle') {
                X.fillStyle = '#ff8c42';
                X.fillRect(o.x, o.y, o.w, o.h);
                X.fillStyle = '#ff8c4230';
                X.fillRect(o.x - 2, o.y - 2, o.w + 4, o.h + 4)
            } else if (o.type === 'pylon') {
                X.fillStyle = '#ff3d71';
                X.fillRect(o.x, o.y, o.w, o.h);
                X.fillStyle = '#ff3d7130';
                for (let i = 0; i < o.h; i += 10) X.fillRect(o.x - 1, o.y + i, o.w + 2, 5)
            }
        }
// Orbs
        for (const o of orbs) {
            if (o.collected) continue;
            const by = o.y + Math.sin(o.bob) * 5;
            X.fillStyle = '#00e5ff10';
            X.beginPath();
            X.arc(o.x, by, o.sz * 2.5, 0, Math.PI * 2);
            X.fill();
            X.fillStyle = '#00e5ff';
            X.save();
            X.translate(o.x, by);
            X.rotate(Math.PI / 4);
            X.fillRect(-o.sz / 2, -o.sz / 2, o.sz, o.sz);
            X.restore()
        }
// Player trail
        for (let i = P.trail.length - 1; i >= 0; i--) {
            const t = P.trail[i];
            X.globalAlpha = t.a * .1;
            X.fillStyle = '#fff';
            const s = P.w * (.4 + t.a * .4);
            X.fillRect(t.x - s / 2, t.y - s / 2, s, s)
        }
        X.globalAlpha = 1;
// Player
        if (!P.dead) {
            const sqX = P.landSquash > .0 ? 1 + P.landSquash * .15 : 1,
                sqY = P.landSquash > .0 ? 1 - P.landSquash * .1 : 1;
            X.save();
            X.translate(P.x + P.w / 2, P.y + P.h);
            X.scale(sqX, sqY);
            X.translate(-P.w / 2, -P.h);
            if (P.sliding) {
                X.fillStyle = '#ddd';
                X.fillRect(0, 0, P.w, P.h);
                X.fillStyle = '#ffffff20';
                for (let i = 0; i < 3; i++) X.fillRect(-8 - i * 10, P.h / 2 - 1 + i * 2, 6, 1.5);
                X.fillStyle = '#08080c';
                X.fillRect(P.w - 7, P.h * .3, 4, 3)
            } else {
                X.fillStyle = '#fff';
                X.fillRect(0, 0, P.w, P.h);
                X.fillStyle = '#08080c';
                X.fillRect(P.w - 7, P.h * .25, 4, 4);
                if (P.onGround) {
                    const f = P.runFrame;
                    X.fillStyle = '#08080c';
                    if (f === 0 || f === 2) {
                        X.fillRect(3, P.h - 3, 5, 3);
                        X.fillRect(P.w - 8, P.h - 1, 5, 1)
                    } else {
                        X.fillRect(3, P.h - 1, 5, 1);
                        X.fillRect(P.w - 8, P.h - 3, 5, 3)
                    }
                }
                if (!P.onGround && P.vy < 0) {
                    X.fillStyle = '#ffffff40';
                    X.fillRect(P.w / 2 - 6, P.h + 1, 12, 2)
                }
            }
            X.restore()
        }
// Particles
        particles.forEach(p => p.draw());
// Floating texts
        for (const f of floats) {
            const a = Math.max(0, f.life);
            X.globalAlpha = a;
            X.fillStyle = f.col;
            X.font = 'bold 13px system-ui';
            X.textAlign = 'center';
            X.fillText(f.txt, f.x, f.y);
            X.globalAlpha = 1
        }
// Vignette
        const vig = X.createRadialGradient(W / 2, H / 2, W * .25, W / 2, H / 2, W * .85);
        vig.addColorStop(0, 'transparent');
        vig.addColorStop(1, 'rgba(0,0,0,.4)');
        X.fillStyle = vig;
        X.fillRect(0, 0, W, H);
// Grace indicator
        if (graceTimer > 0) {
            X.globalAlpha = graceTimer / 1.2 * .4;
            X.strokeStyle = '#00e5ff';
            X.lineWidth = 2;
            X.strokeRect(P.x - 3, P.y - 3, P.w + 6, P.h + 6);
            X.globalAlpha = 1
        }
        X.restore()
    }

    function loop(time) {
        const rawDt = Math.min((time - lastTime) / 1000, .05);
        lastTime = time;
        update(rawDt);
        draw();
        requestAnimationFrame(loop)
    }

    requestAnimationFrame(t => {
        lastTime = t;
        loop(t)
    });
</script>
<script src="../logo.js"></script>
</body>
</html>