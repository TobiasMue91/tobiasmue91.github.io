<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connect Four Online - Free Classic Board Game | GPT Games</title>
  <meta name="description" content="Play the classic Connect Four game online for free! Challenge the AI or play with a friend in this strategic board game. No download required.">
  <meta name="keywords" content="connect four, online game, board game, strategy game, free game, two player game, AI game">
  <meta name="author" content="ChatGPT 3.5 and Claude 3.7 Sonnet prompted by Tobias Müller">
  <link rel="canonical" href="https://www.gptgames.dev/games/connect_four.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>4️⃣</text></svg>">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://www.gptgames.dev/games/connect_four.html">
  <meta property="og:title" content="Connect Four Online - Free Classic Board Game">
  <meta property="og:description" content="Challenge the AI or play with a friend in this strategic board game. Drop your pieces to connect four in a row!">
  <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_5.png">
  <meta property="og:site_name" content="GPT Games">
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://www.gptgames.dev/games/connect_four.html">
  <meta property="twitter:title" content="Connect Four Online - Free Classic Board Game">
  <meta property="twitter:description" content="Challenge the AI or play with a friend in this strategic board game. Drop your pieces to connect four in a row!">
  <meta property="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_5.png">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  <meta name="revisit-after" content="7 days">
  <meta name="theme-color" content="#2563eb">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
    :root{--primary:#2563eb;--primary-dark:#1d4ed8;--red:#ef4444;--yellow:#facc15;--bg:#f8fafc;--board:#1e3a8a;--text:#1e293b;--shadow-sm:0 1px 3px rgba(0,0,0,0.12);--shadow-md:0 4px 6px rgba(0,0,0,0.1);--shadow-lg:0 10px 15px -3px rgba(0,0,0,0.1);--radius-sm:0.375rem;--radius-md:0.5rem;--radius-lg:0.75rem;--transition:150ms cubic-bezier(0.4,0,0.2,1)}
    *{box-sizing:border-box;margin:0;padding:0;}
    body{font-family:'Poppins',sans-serif;background-color:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;align-items:center;}
    .container{width:100%;max-width:960px;margin:0 auto;padding:1.5rem;display:flex;flex-direction:column;gap:1.5rem;}
    header{text-align:center;margin-bottom:1rem;}
    h1{font-size:2.5rem;color:var(--primary);font-weight:700;line-height:1.2;}
    p{margin-bottom:1rem;line-height:1.6;}
    .game-area{display:grid;grid-template-columns:1fr 1.5fr;gap:1.5rem;}
    @media (max-width:768px){.game-area{grid-template-columns:1fr;}}
    .controls{display:flex;flex-direction:column;gap:1rem;background-color:white;padding:1.5rem;border-radius:var(--radius-lg);box-shadow:var(--shadow-md);}
    .player-info{display:flex;justify-content:space-between;gap:1rem;margin-bottom:1rem;}
    .player{flex:1;padding:1rem;border-radius:var(--radius-md);background-color:#f1f5f9;text-align:center;transition:transform var(--transition),box-shadow var(--transition);}
    .player.active{transform:translateY(-3px);box-shadow:var(--shadow-md);}
    .player-red.active{background-color:var(--red);color:white;}
    .player-yellow.active{background-color:var(--yellow);}
    .player-name{font-weight:600;font-size:0.875rem;}
    .player-score{font-size:1.5rem;font-weight:700;margin-top:0.5rem;}
    .status{text-align:center;padding:0.75rem;background-color:#f1f5f9;border-radius:var(--radius-md);font-weight:500;margin-bottom:1rem;}
    .control-group{display:flex;flex-direction:column;gap:0.5rem;margin-bottom:1rem;}
    label{font-weight:500;font-size:0.875rem;color:#64748b;}
    select, button{padding:0.75rem 1rem;border-radius:var(--radius-md);border:1px solid #e2e8f0;background-color:white;font-family:inherit;font-size:1rem;cursor:pointer;transition:all var(--transition);}
    select:hover, button:hover{border-color:var(--primary);}
    select:focus, button:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 2px rgba(37,99,235,0.2);}
    button{font-weight:500;}
    button:not(:last-child){margin-bottom:0.5rem;}
    button.primary{background-color:var(--primary);color:white;border-color:var(--primary);}
    button.primary:hover{background-color:var(--primary-dark);border-color:var(--primary-dark);}
    button:disabled{opacity:0.5;cursor:not-allowed;}
    .board-container{position:relative;background-color:var(--board);border-radius:var(--radius-lg);padding:1rem;box-shadow:var(--shadow-lg);}
    .board{display:grid;grid-template-columns:repeat(7,1fr);gap:0.5rem;position:relative;}
    .column{display:flex;flex-direction:column;gap:0.5rem;}
    .column:hover{background-color:rgba(255,255,255,0.05);border-radius:var(--radius-md);}
    .cell{aspect-ratio:1;background-color:var(--board);border-radius:50%;position:relative;display:flex;align-items:center;justify-content:center;cursor:pointer;overflow:hidden;}
    .cell:focus{outline:none;box-shadow:0 0 0 2px rgba(255,255,255,0.5);}
    .cell::after{content:'';position:absolute;width:85%;height:85%;background-color:white;border-radius:50%;transition:background-color 0.1s;}
    .red::after{background-color:var(--red);}
    .yellow::after{background-color:var(--yellow);}
    .red.dropped::after, .yellow.dropped::after{animation:drop 0.4s cubic-bezier(0.6,0.1,0.15,1);}
    .win::after{animation:pulse 1.5s infinite;}
    @keyframes drop{0%{transform:translateY(-500%)} 70%{transform:translateY(10%)} 85%{transform:translateY(-5%)} 100%{transform:translateY(0)}}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,255,255,0.5)} 70%{box-shadow:0 0 0 10px rgba(255,255,255,0)} 100%{box-shadow:0 0 0 0 rgba(255,255,255,0)}}
    .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);z-index:100;align-items:center;justify-content:center;}
    .modal.active{display:flex;}
    .modal-content{background-color:white;border-radius:var(--radius-lg);padding:2rem;width:90%;max-width:400px;text-align:center;animation:modal-in 0.3s;}
    @keyframes modal-in{from{opacity:0;transform:scale(0.9)} to{opacity:1;transform:scale(1)}}
    .modal h2{color:var(--primary);margin-bottom:1rem;}
    .modal p{margin-bottom:1.5rem;}
    .modal-buttons{display:flex;gap:0.75rem;justify-content:center;}
    footer{margin-top:2rem;text-align:center;color:#64748b;font-size:0.875rem;}
  </style>
</head>
<body>
<div class="container">
  <header>
    <h1>Connect Four</h1>
    <p>Connect four pieces horizontally, vertically, or diagonally to win!</p>
  </header>

  <div class="game-area">
    <div class="controls">
      <div class="player-info">
        <div id="player1" class="player player-red active">
          <div class="player-name">Red</div>
          <div class="player-score">0</div>
        </div>
        <div id="player2" class="player player-yellow">
          <div class="player-name">Yellow</div>
          <div class="player-score">0</div>
        </div>
      </div>

      <div id="game-status" class="status">Red's turn</div>

      <div class="control-group">
        <label for="opponent">Opponent</label>
        <select id="opponent">
          <option value="ai" selected>Computer</option>
          <option value="human">Human</option>
        </select>
      </div>

      <div id="difficulty-container" class="control-group">
        <label for="difficulty">Difficulty</label>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>

      <button id="undo" disabled>Undo Move</button>
      <button id="reset" class="primary">New Game</button>
    </div>

    <div class="board-container">
      <div id="board" class="board" role="grid" aria-label="Connect Four game board"></div>
    </div>
  </div>

  <footer>
    <p>© 2025 Connect Four Online - The classic strategy game</p>
  </footer>
</div>

<div id="win-modal" class="modal">
  <div class="modal-content">
    <h2 id="win-message">Player Wins!</h2>
    <p id="win-description">Congratulations!</p>
    <div class="modal-buttons">
      <button id="new-game" class="primary">New Game</button>
      <button id="close-modal">Continue</button>
    </div>
  </div>
</div>

<script>
  // Game state
  const game = {
    board: Array(6).fill().map(() => Array(7).fill(null)),
    currentPlayer: 'red',
    gameOver: false,
    winner: null,
    moveHistory: [],
    scores: { red: 0, yellow: 0 },
    winningCells: [],
    aiThinking: false
  };

  // DOM elements
  const elements = {
    board: document.getElementById('board'),
    status: document.getElementById('game-status'),
    player1: document.getElementById('player1'),
    player2: document.getElementById('player2'),
    player1Score: document.querySelector('#player1 .player-score'),
    player2Score: document.querySelector('#player2 .player-score'),
    opponent: document.getElementById('opponent'),
    difficulty: document.getElementById('difficulty'),
    difficultyContainer: document.getElementById('difficulty-container'),
    undoBtn: document.getElementById('undo'),
    resetBtn: document.getElementById('reset'),
    winModal: document.getElementById('win-modal'),
    winMessage: document.getElementById('win-message'),
    winDescription: document.getElementById('win-description'),
    newGameBtn: document.getElementById('new-game'),
    closeModalBtn: document.getElementById('close-modal')
  };

  // Initialize game
  function initGame() {
    createBoard();
    attachEventListeners();
    updateUI();
  }

  // Create game board
  function createBoard() {
    elements.board.innerHTML = '';
    for (let col = 0; col < 7; col++) {
      const column = document.createElement('div');
      column.className = 'column';
      column.dataset.col = col;
      column.setAttribute('role', 'columnheader');
      column.setAttribute('aria-label', `Column ${col + 1}`);
      for (let row = 0; row < 6; row++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = 5 - row; // Invert for visual representation
        cell.dataset.col = col;
        cell.setAttribute('tabindex', '0');
        cell.setAttribute('role', 'gridcell');
        cell.setAttribute('aria-label', `Row ${5 - row + 1}, Column ${col + 1}`);
        column.appendChild(cell);
      }
      elements.board.appendChild(column);
    }
  }

  // Add event listeners
  function attachEventListeners() {
    elements.board.addEventListener('click', handleColumnClick);
    elements.board.addEventListener('keydown', handleKeyboardNavigation);
    elements.resetBtn.addEventListener('click', resetGame);
    elements.undoBtn.addEventListener('click', undoMove);
    elements.opponent.addEventListener('change', handleOpponentChange);
    elements.difficulty.addEventListener('change', () => updateUI());
    elements.newGameBtn.addEventListener('click', () => {
      resetGame();
      elements.winModal.classList.remove('active');
    });
    elements.closeModalBtn.addEventListener('click', () => {
      elements.winModal.classList.remove('active');
    });
  }

  // Handle column click
  function handleColumnClick(e) {
    if (game.gameOver || game.aiThinking) return;

    const column = e.target.closest('.column');
    if (!column) return;

    const colIndex = parseInt(column.dataset.col);
    makeMove(colIndex);
  }

  // Handle keyboard navigation
  function handleKeyboardNavigation(e) {
    if (game.gameOver || game.aiThinking) return;

    const cell = e.target.closest('.cell');
    if (!cell) return;

    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);

    switch(e.key) {
      case 'ArrowLeft':
        if (col > 0) {
          document.querySelector(`.cell[data-row="${row}"][data-col="${col-1}"]`).focus();
        }
        break;
      case 'ArrowRight':
        if (col < 6) {
          document.querySelector(`.cell[data-row="${row}"][data-col="${col+1}"]`).focus();
        }
        break;
      case 'ArrowUp':
        if (row < 5) {
          document.querySelector(`.cell[data-row="${row+1}"][data-col="${col}"]`).focus();
        }
        break;
      case 'ArrowDown':
        if (row > 0) {
          document.querySelector(`.cell[data-row="${row-1}"][data-col="${col}"]`).focus();
        }
        break;
      case 'Enter':
      case ' ':
        makeMove(col);
        break;
    }
  }

  // Handle opponent change
  function handleOpponentChange() {
    elements.difficultyContainer.style.display =
            elements.opponent.value === 'ai' ? 'block' : 'none';
    resetGame();
  }

  // Make a move
  function makeMove(col) {
    if (game.gameOver || game.aiThinking) return;

    const row = findAvailableRow(col);
    if (row === -1) return; // Column is full

    // Place piece and record move
    game.board[row][col] = game.currentPlayer;
    game.moveHistory.push({row, col, player: game.currentPlayer});

    // Update UI
    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    cell.classList.add(game.currentPlayer, 'dropped');

    // Check for win
    if (checkWin(row, col)) {
      game.gameOver = true;
      game.winner = game.currentPlayer;
      game.scores[game.currentPlayer]++;
      highlightWinningCells();
      setTimeout(showWinModal, 500);
      updateUI();
      return;
    }

    // Check for draw
    if (checkDraw()) {
      game.gameOver = true;
      setTimeout(showDrawModal, 500);
      updateUI();
      return;
    }

    // Switch player
    game.currentPlayer = game.currentPlayer === 'red' ? 'yellow' : 'red';
    updateUI();

    // AI move
    if (elements.opponent.value === 'ai' && game.currentPlayer === 'yellow' && !game.gameOver) {
      game.aiThinking = true;
      updateUI();

      setTimeout(() => {
        const aiCol = getAIMove();
        game.aiThinking = false;
        makeMove(aiCol);
      }, 600);
    }
  }

  // Find available row in column
  function findAvailableRow(col) {
    for (let row = 0; row < 6; row++) {
      if (game.board[row][col] === null) {
        return row;
      }
    }
    return -1; // Column is full
  }

  // Check for win
  function checkWin(row, col) {
    const directions = [
      [0, 1],  // horizontal
      [1, 0],  // vertical
      [1, 1],  // diagonal down-right
      [1, -1]  // diagonal down-left
    ];

    const player = game.board[row][col];

    for (const [dr, dc] of directions) {
      game.winningCells = [{row, col}];

      // Check in one direction
      let r = row + dr;
      let c = col + dc;
      while (isValidCell(r, c) && game.board[r][c] === player) {
        game.winningCells.push({row: r, col: c});
        r += dr;
        c += dc;
      }

      // Check in opposite direction
      r = row - dr;
      c = col - dc;
      while (isValidCell(r, c) && game.board[r][c] === player) {
        game.winningCells.push({row: r, col: c});
        r -= dr;
        c -= dc;
      }

      if (game.winningCells.length >= 4) {
        return true;
      }
    }

    game.winningCells = [];
    return false;
  }

  // Check if cell coordinates are valid
  function isValidCell(row, col) {
    return row >= 0 && row < 6 && col >= 0 && col < 7;
  }

  // Check for draw
  function checkDraw() {
    return game.board.every(row => row.every(cell => cell !== null));
  }

  // Highlight winning cells
  function highlightWinningCells() {
    game.winningCells.forEach(({row, col}) => {
      const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
      cell.classList.add('win');
    });
  }

  // Show win modal
  function showWinModal() {
    const winner = game.winner === 'red' ? 'Red' : 'Yellow';
    elements.winMessage.textContent = `${winner} Wins!`;
    elements.winDescription.textContent = `Congratulations! ${winner} has connected four pieces.`;
    elements.winModal.classList.add('active');
  }

  // Show draw modal
  function showDrawModal() {
    elements.winMessage.textContent = 'Game Draw!';
    elements.winDescription.textContent = 'The board is full with no winner.';
    elements.winModal.classList.add('active');
  }

  // AI move logic
  function getAIMove() {
    const difficulty = elements.difficulty.value;

    // Check for winning move
    const winningMove = findWinningMove('yellow');
    if (winningMove !== -1) return winningMove;

    // Check for blocking opponent's winning move
    const blockingMove = findWinningMove('red');
    if (blockingMove !== -1) return blockingMove;

    // Additional AI logic based on difficulty
    if (difficulty === 'hard') {
      // Try to create threats
      const threatMove = findBestMove();
      if (threatMove !== -1) return threatMove;
    }

    // Prefer center columns
    const availableColumns = [];
    const weightedColumns = [];

    for (let col = 0; col < 7; col++) {
      if (findAvailableRow(col) !== -1) {
        availableColumns.push(col);

        // Weight by column position (prefer center)
        const weight =
                col === 3 ? 5 :   // Center
                        col === 2 || col === 4 ? 3 :   // Near center
                                col === 1 || col === 5 ? 2 :   // Further out
                                        1;                // Edges

        // Add weighted entries for random selection
        for (let i = 0; i < weight; i++) {
          weightedColumns.push(col);
        }
      }
    }

    if (availableColumns.length === 0) return -1;

    if (difficulty === 'easy') {
      // Truly random for easy
      return availableColumns[Math.floor(Math.random() * availableColumns.length)];
    } else {
      // Weighted random for medium and hard
      return weightedColumns[Math.floor(Math.random() * weightedColumns.length)];
    }
  }

  // Find winning move for player
  function findWinningMove(player) {
    for (let col = 0; col < 7; col++) {
      const row = findAvailableRow(col);
      if (row === -1) continue;

      // Try this move
      game.board[row][col] = player;
      const isWin = checkWin(row, col);
      game.board[row][col] = null;

      if (isWin) return col;
    }
    return -1;
  }

  // Find best strategic move (for hard difficulty)
  function findBestMove() {
    let bestScore = -Infinity;
    let bestCol = 3; // Default to center

    for (let col = 0; col < 7; col++) {
      const row = findAvailableRow(col);
      if (row === -1) continue;

      game.board[row][col] = 'yellow';
      const score = evaluateBoard();
      game.board[row][col] = null;

      if (score > bestScore) {
        bestScore = score;
        bestCol = col;
      }
    }

    return bestCol;
  }

  // Evaluate board position for AI
  function evaluateBoard() {
    let score = 0;

    // Check horizontal windows
    for (let row = 0; row < 6; row++) {
      for (let col = 0; col < 4; col++) {
        score += evaluateWindow(row, col, 0, 1);
      }
    }

    // Check vertical windows
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 7; col++) {
        score += evaluateWindow(row, col, 1, 0);
      }
    }

    // Check diagonal windows
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 4; col++) {
        score += evaluateWindow(row, col, 1, 1);
      }
    }

    for (let row = 0; row < 3; row++) {
      for (let col = 3; col < 7; col++) {
        score += evaluateWindow(row, col, 1, -1);
      }
    }

    // Prefer center column
    for (let row = 0; row < 6; row++) {
      if (game.board[row][3] === 'yellow') score += 3;
    }

    return score;
  }

  // Evaluate a window of 4 cells
  function evaluateWindow(row, col, dr, dc) {
    const window = [];
    for (let i = 0; i < 4; i++) {
      window.push(game.board[row + i*dr][col + i*dc]);
    }

    const yellowCount = window.filter(cell => cell === 'yellow').length;
    const redCount = window.filter(cell => cell === 'red').length;
    const emptyCount = window.filter(cell => cell === null).length;

    // Score the window
    if (yellowCount === 4) return 100;
    if (yellowCount === 3 && emptyCount === 1) return 5;
    if (yellowCount === 2 && emptyCount === 2) return 2;
    if (redCount === 3 && emptyCount === 1) return -4;

    return 0;
  }

  // Undo move
  function undoMove() {
    if (game.moveHistory.length === 0 || game.gameOver) return;

    // If playing against AI, undo both AI and player moves
    if (elements.opponent.value === 'ai' && game.moveHistory.length > 1) {
      // Undo AI move
      const aiMove = game.moveHistory.pop();
      game.board[aiMove.row][aiMove.col] = null;
      const aiCell = document.querySelector(`.cell[data-row="${aiMove.row}"][data-col="${aiMove.col}"]`);
      aiCell.classList.remove('yellow', 'red', 'dropped');
    }

    // Undo player move
    const lastMove = game.moveHistory.pop();
    game.board[lastMove.row][lastMove.col] = null;
    const cell = document.querySelector(`.cell[data-row="${lastMove.row}"][data-col="${lastMove.col}"]`);
    cell.classList.remove('yellow', 'red', 'dropped', 'win');

    // Reset game state
    game.gameOver = false;
    game.winner = null;
    game.winningCells = [];
    game.currentPlayer = lastMove.player;

    // Remove win highlighting
    document.querySelectorAll('.cell.win').forEach(cell => {
      cell.classList.remove('win');
    });

    updateUI();
  }

  // Reset game
  function resetGame() {
    // Clear the board
    game.board = Array(6).fill().map(() => Array(7).fill(null));
    game.currentPlayer = 'red';
    game.gameOver = false;
    game.winner = null;
    game.moveHistory = [];
    game.winningCells = [];
    game.aiThinking = false;

    // Reset UI
    document.querySelectorAll('.cell').forEach(cell => {
      cell.classList.remove('red', 'yellow', 'dropped', 'win');
    });

    updateUI();
  }

  // Update UI
  function updateUI() {
    // Update player indicators
    elements.player1.classList.toggle('active', game.currentPlayer === 'red' && !game.gameOver);
    elements.player2.classList.toggle('active', game.currentPlayer === 'yellow' && !game.gameOver);

    // Update scores
    elements.player1Score.textContent = game.scores.red;
    elements.player2Score.textContent = game.scores.yellow;

    // Update status message
    if (game.gameOver) {
      if (game.winner) {
        const winner = game.winner === 'red' ? 'Red' : 'Yellow';
        elements.status.textContent = `${winner} wins!`;
      } else {
        elements.status.textContent = 'Game Draw!';
      }
    } else if (game.aiThinking) {
      elements.status.textContent = 'AI is thinking...';
    } else {
      const player = game.currentPlayer === 'red' ? 'Red' : 'Yellow';
      elements.status.textContent = `${player}'s turn`;
    }

    // Update button states
    elements.undoBtn.disabled =
            game.moveHistory.length === 0 ||
            game.aiThinking ||
            (game.currentPlayer === 'yellow' && elements.opponent.value === 'ai' && !game.gameOver);
  }

  // Initialize game when DOM is loaded
  document.addEventListener('DOMContentLoaded', initGame);
</script>
<script src="../logo.js"></script>
</body>
</html>