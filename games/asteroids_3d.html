<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Asteroids</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>☄️</text></svg>">
    <meta name="description" content="Experience thrilling first-person 3D Asteroids gameplay in this browser-based game. Navigate through space, shoot asteroids, and survive increasingly difficult levels.">
    <meta name="keywords" content="3D Asteroids, browser game, JavaScript game, first-person space shooter, ThreeJS">
    <meta name="author" content="Claude 3.7 Sonnet prompted by Tobias Müller">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/asteroids_3d.html">
    <meta property="og:title" content="3D Asteroids - First-Person Space Shooter">
    <meta property="og:description" content="Navigate through asteroid fields in this immersive 3D browser game. Destroy asteroids, earn points, and survive as long as possible!">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_171.png">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://www.gptgames.dev/games/asteroids_3d.html">
    <meta property="twitter:title" content="3D Asteroids - First-Person Space Shooter">
    <meta property="twitter:description" content="Navigate through asteroid fields in this immersive 3D browser game. Destroy asteroids, earn points, and survive as long as possible!">
    <meta property="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_171.png">
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "VideoGame",
            "name": "3D Asteroids",
            "description": "First-person 3D Asteroids game where players navigate through space, shooting asteroids and surviving increasingly difficult levels.",
            "image": "https://www.gptgames.dev/screenshots/screenshot_171.png",
            "url": "https://www.gptgames.dev/games/asteroids_3d.html",
            "genre": ["Arcade", "Space Shooter", "First-Person"],
            "author": {
                "@type": "Person",
                "name": "Claude 3.7 Sonnet prompted by Tobias Müller"
            },
            "offers": {
                "@type": "Offer",
                "price": "0",
                "priceCurrency": "USD",
                "availability": "https://schema.org/InStock"
            },
            "applicationCategory": "Game",
            "operatingSystem": "Any"
        }
    </script>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --text-color: #121212;
            --ui-bg: rgba(255, 255, 255, 0.8);
            --ui-border: rgba(0, 0, 0, 0.2);
            --ui-highlight: #3498db;
            --ui-secondary: #2ecc71;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #f0f0f0;
                --ui-bg: rgba(30, 30, 30, 0.85);
                --ui-border: rgba(255, 255, 255, 0.2);
                --ui-highlight: #2980b9;
                --ui-secondary: #27ae60;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .screen {
            background-color: var(--ui-bg);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            text-align: center;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2.5em;
            color: var(--ui-highlight);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        button {
            background-color: var(--ui-highlight);
            color: white;
            border: none;
            padding: 12px 30px;
            margin: 10px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background-color: var(--ui-secondary);
        }

        p {
            margin: 15px 0;
            line-height: 1.5;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
        }

        .instructions {
            background-color: var(--ui-bg);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            max-width: 400px;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
            display: none;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
            width: 2px;
            height: 20px;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #radar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            display: none;
            pointer-events: none;
            overflow: hidden;
        }

        #radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 50%;
            background-color: rgba(0, 255, 0, 0.4);
            transform-origin: bottom center;
            animation: radarSweep 3s linear infinite;
        }

        #shield-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
        }

        .hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.2);
            z-index: 4;
            pointer-events: none;
            display: none;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 5;
        }

        @keyframes radarSweep {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
<div id="game-container">
    <div id="menu-screen" class="overlay">
        <div class="screen">
            <h1>3D ASTEROIDS</h1>
            <p>Navigate through asteroid fields in first-person view</p>
            <button id="start-button">START GAME</button>
            <div class="instructions">
                <p><strong>Controls:</strong><br>
                    WASD or Arrow Keys - Movement<br>
                    Mouse - Look around<br>
                    Left Click or Space - Shoot<br>
                    Shift - Boost Speed<br>
                    ESC - Pause</p>
            </div>
        </div>
    </div>
    <div id="hud" style="display: none;">
        Score: <span id="score">0</span><br>
        Lives: <span id="lives">3</span><br>
        Level: <span id="level">1</span><br>
        Shield: <span id="shield">100</span>%
    </div>
    <div id="pause-screen" class="overlay" style="display: none;">
        <div class="screen">
            <h1>PAUSED</h1>
            <button id="resume-button">RESUME</button>
            <button id="menu-button" class="secondary">MAIN MENU</button>
        </div>
    </div>
    <div id="game-over-screen" class="overlay" style="display: none;">
        <div class="screen">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="restart-button">PLAY AGAIN</button>
            <button id="menu-button-end" class="secondary">MAIN MENU</button>
        </div>
    </div>
    <div class="crosshair" id="crosshair">
        <div class="crosshair-dot"></div>
    </div>
    <div id="radar">
        <div id="radar-center"></div>
        <div id="radar-sweep"></div>
    </div>
    <div class="hit-flash" id="hit-flash"></div>
    <div class="message" id="message"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
    class AsteroidsGame {
        constructor() {
            this.score = 0;
            this.lives = 3;
            this.level = 1;
            this.shield = 100;
            this.gameState = 'menu';
            this.isPaused = false;
            this.keys = {};
            this.asteroids = [];
            this.projectiles = [];
            this.lastTime = 0;
            this.lastShot = 0;
            this.shotCooldown = 200;
            this.pointerLocked = false;
            this.moveSpeed = 0.4;
            this.boostMultiplier = 1.8;
            this.shieldRegenRate = 0.05;
            this.pitch = 0;
            this.yaw = 0;
            this.setupThreeJS();
            this.setupEventListeners();
        }

        setupThreeJS() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.rotation.order = 'YXZ';
            this.renderer = new THREE.WebGLRenderer({antialias: true});
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x000011);
            document.getElementById('game-container').appendChild(this.renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x404040);
            this.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            this.scene.add(directionalLight);
            this.createStarfield();
            this.createCockpit();
            this.radarBlips = [];
        }

        createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 2000 - 1000;
                const z = Math.random() * 2000 - 1000;
                starsVertices.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starsMaterial1 = new THREE.PointsMaterial({color: 0xffffff, size: 0.1});
            const starsMaterial2 = new THREE.PointsMaterial({color: 0xccddff, size: 0.2});
            const starsMaterial3 = new THREE.PointsMaterial({color: 0xffccaa, size: 0.3});
            const stars1 = new THREE.Points(starsGeometry.clone(), starsMaterial1);
            const stars2 = new THREE.Points(starsGeometry.clone(), starsMaterial2);
            const stars3 = new THREE.Points(starsGeometry.clone(), starsMaterial3);
            const positions2 = stars2.geometry.attributes.position.array;
            for (let i = 0; i < positions2.length; i += 3) {
                if (Math.random() > 0.2) {
                    positions2[i] = 2000;
                    positions2[i + 1] = 2000;
                    positions2[i + 2] = 2000;
                }
            }
            const positions3 = stars3.geometry.attributes.position.array;
            for (let i = 0; i < positions3.length; i += 3) {
                if (Math.random() > 0.05) {
                    positions3[i] = 2000;
                    positions3[i + 1] = 2000;
                    positions3[i + 2] = 2000;
                }
            }
            this.scene.add(stars1);
            this.scene.add(stars2);
            this.scene.add(stars3);
        }

        createCockpit() {
            const cockpitGroup = new THREE.Group();
            const frameMaterial = new THREE.MeshStandardMaterial({color: 0x303030, metalness: 0.7, roughness: 0.3});
            const interiorMaterial = new THREE.MeshStandardMaterial({color: 0x202020, metalness: 0.1, roughness: 0.8});
            const bottomGeometry = new THREE.BufferGeometry();
            const bottomVertices = new Float32Array([-0.4, -0.25, -0.8, -0.25, -0.3, -0.8, -0.25, -0.3, -0.7, -0.4, -0.25, -0.7, -0.25, -0.3, -0.8, 0.25, -0.3, -0.8, 0.25, -0.3, -0.7, -0.25, -0.3, -0.7, 0.25, -0.3, -0.8, 0.4, -0.25, -0.8, 0.4, -0.25, -0.7, 0.25, -0.3, -0.7]);
            const bottomIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11];
            bottomGeometry.setAttribute('position', new THREE.BufferAttribute(bottomVertices, 3));
            bottomGeometry.setIndex(bottomIndices);
            bottomGeometry.computeVertexNormals();
            const bottomFrame = new THREE.Mesh(bottomGeometry, frameMaterial);
            cockpitGroup.add(bottomFrame);
            const leftGeometry = new THREE.BufferGeometry();
            const leftVertices = new Float32Array([-0.4, -0.25, -0.8, -0.4, 0.15, -0.8, -0.35, 0.25, -0.8, -0.35, 0.25, -0.7, -0.4, 0.15, -0.7, -0.4, -0.25, -0.7]);
            const leftIndices = [0, 1, 4, 0, 4, 5, 1, 2, 3, 1, 3, 4];
            leftGeometry.setAttribute('position', new THREE.BufferAttribute(leftVertices, 3));
            leftGeometry.setIndex(leftIndices);
            leftGeometry.computeVertexNormals();
            const leftFrame = new THREE.Mesh(leftGeometry, frameMaterial);
            cockpitGroup.add(leftFrame);
            const rightGeometry = new THREE.BufferGeometry();
            const rightVertices = new Float32Array([0.4, -0.25, -0.8, 0.4, 0.15, -0.8, 0.35, 0.25, -0.8, 0.35, 0.25, -0.7, 0.4, 0.15, -0.7, 0.4, -0.25, -0.7]);
            const rightIndices = [0, 4, 5, 0, 1, 4, 1, 3, 4, 1, 2, 3];
            rightGeometry.setAttribute('position', new THREE.BufferAttribute(rightVertices, 3));
            rightGeometry.setIndex(rightIndices);
            rightGeometry.computeVertexNormals();
            const rightFrame = new THREE.Mesh(rightGeometry, frameMaterial);
            cockpitGroup.add(rightFrame);
            const topGeometry = new THREE.BufferGeometry();
            const topVertices = new Float32Array([-0.35, 0.25, -0.8, 0.35, 0.25, -0.8, 0.35, 0.25, -0.7, -0.35, 0.25, -0.7]);
            const topIndices = [0, 1, 2, 0, 2, 3];
            topGeometry.setAttribute('position', new THREE.BufferAttribute(topVertices, 3));
            topGeometry.setIndex(topIndices);
            topGeometry.computeVertexNormals();
            const topFrame = new THREE.Mesh(topGeometry, frameMaterial);
            cockpitGroup.add(topFrame);
            const consoleGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.15);
            const consoleMesh = new THREE.Mesh(consoleGeometry, interiorMaterial);
            consoleMesh.position.set(0, -0.25, -0.75);
            consoleMesh.rotation.x = -Math.PI / 6;
            cockpitGroup.add(consoleMesh);
            const redLightMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
            const greenLightMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00});
            const blueLightMaterial = new THREE.MeshBasicMaterial({color: 0x0088ff});
            for (let i = 0; i < 5; i++) {
                const lightGeometry = new THREE.CircleGeometry(0.008, 8);
                const lightMaterial = i % 3 === 0 ? redLightMaterial : i % 3 === 1 ? greenLightMaterial : blueLightMaterial;
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.set(-0.2 + i * 0.1, -0.22, -0.68);
                light.rotation.x = -Math.PI / 6;
                cockpitGroup.add(light);
            }
            const gunMountGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.04, 8);
            const gunMountMaterial = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8, roughness: 0.2});
            const leftGunMount = new THREE.Mesh(gunMountGeometry, gunMountMaterial);
            leftGunMount.rotation.x = Math.PI / 2;
            leftGunMount.position.set(-0.2, -0.2, -0.82);
            cockpitGroup.add(leftGunMount);
            const rightGunMount = new THREE.Mesh(gunMountGeometry, gunMountMaterial);
            rightGunMount.rotation.x = Math.PI / 2;
            rightGunMount.position.set(0.2, -0.2, -0.82);
            cockpitGroup.add(rightGunMount);
            this.muzzlePositions = [new THREE.Vector3(-0.2, -0.2, -0.85), new THREE.Vector3(0.2, -0.2, -0.85)];
            this.activeMuzzle = 0;
            this.camera.add(cockpitGroup);
            this.scene.add(this.camera);
        }

        createAsteroids() {
            const count = 5 + this.level * 2;
            for (let i = 0; i < count; i++) {
                this.createAsteroid('large');
            }
        }

        createAsteroid(size, position = null) {
            let radius, detail, speed, points;
            switch (size) {
                case'large':
                    radius = 8;
                    detail = 1;
                    speed = 0.15;
                    points = 20;
                    break;
                case'medium':
                    radius = 4;
                    detail = 1;
                    speed = 0.25;
                    points = 50;
                    break;
                case'small':
                    radius = 2;
                    detail = 0;
                    speed = 0.35;
                    points = 100;
                    break;
            }
            let geometry;
            const asteroidType = Math.floor(Math.random() * 3);
            if (asteroidType === 0) {
                geometry = new THREE.IcosahedronGeometry(radius, detail);
            } else if (asteroidType === 1) {
                geometry = new THREE.OctahedronGeometry(radius, detail);
            } else {
                geometry = new THREE.TetrahedronGeometry(radius, detail + 1);
            }
            const positions = geometry.attributes.position;
            const distortionFactor = 0.2;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                positions.setX(i, x + (Math.random() - 0.5) * distortionFactor * radius);
                positions.setY(i, y + (Math.random() - 0.5) * distortionFactor * radius);
                positions.setZ(i, z + (Math.random() - 0.5) * distortionFactor * radius);
            }
            geometry.computeVertexNormals();
            const materialOptions = [new THREE.MeshStandardMaterial({
                color: 0x8a8a8a,
                roughness: 0.9,
                metalness: 0.1,
                flatShading: true
            }), new THREE.MeshStandardMaterial({
                color: 0x6e5b47,
                roughness: 0.85,
                metalness: 0.15,
                flatShading: true
            }), new THREE.MeshStandardMaterial({color: 0x576b65, roughness: 0.8, metalness: 0.2, flatShading: true})];
            const material = materialOptions[Math.floor(Math.random() * materialOptions.length)];
            const asteroid = new THREE.Mesh(geometry, material);
            if (position) {
                asteroid.position.copy(position);
            } else {
                do {
                    asteroid.position.set(Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100);
                } while (asteroid.position.length() < 40);
            }
            asteroid.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
            const direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
            const asteroidData = {
                mesh: asteroid,
                size: size,
                direction: direction,
                speed: speed * (0.8 + Math.random() * 0.4),
                rotationSpeed: {
                    x: Math.random() * 0.01 - 0.005,
                    y: Math.random() * 0.01 - 0.005,
                    z: Math.random() * 0.01 - 0.005
                },
                points: points,
                radius: radius
            };
            this.asteroids.push(asteroidData);
            this.scene.add(asteroid);
            this.createRadarBlip(asteroidData);
            return asteroidData;
        }

        createRadarBlip(asteroidData) {
            const blipElement = document.createElement('div');
            blipElement.style.position = 'absolute';
            blipElement.style.width = '4px';
            blipElement.style.height = '4px';
            blipElement.style.borderRadius = '50%';
            blipElement.style.backgroundColor = 'rgba(255,0,0,0.7)';
            document.getElementById('radar').appendChild(blipElement);
            this.radarBlips.push({element: blipElement, asteroid: asteroidData});
        }

        shoot() {
            const now = Date.now();
            if (now - this.lastShot < this.shotCooldown) return;
            this.lastShot = now;
            this.activeMuzzle = (this.activeMuzzle + 1) % 2;
            const muzzlePosition = this.muzzlePositions[this.activeMuzzle].clone();
            muzzlePosition.applyMatrix4(this.camera.matrixWorld);
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshBasicMaterial({color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1});
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(muzzlePosition);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.camera.quaternion);
            const projectileData = {mesh: projectile, direction: direction, speed: 2.0, lifeTime: 1500, created: now};
            this.projectiles.push(projectileData);
            this.scene.add(projectile);
            this.createMuzzleFlash(muzzlePosition);
        }

        createMuzzleFlash(position) {
            const light = new THREE.PointLight(0x00ff00, 2, 10);
            light.position.copy(position);
            this.scene.add(light);
            setTimeout(() => {
                this.scene.remove(light);
            }, 100);
        }

        updatePlayerMovement(deltaTime) {
            const moveSpeed = this.moveSpeed * deltaTime;
            const boostMultiplier = (this.keys['ShiftLeft'] || this.keys['ShiftRight']) ? this.boostMultiplier : 1.0;
            let moveVector = new THREE.Vector3(0, 0, 0);
            if (this.keys['KeyW'] || this.keys['ArrowUp']) {
                moveVector.z -= moveSpeed * boostMultiplier;
            }
            if (this.keys['KeyS'] || this.keys['ArrowDown']) {
                moveVector.z += moveSpeed * boostMultiplier;
            }
            if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
                moveVector.x -= moveSpeed * boostMultiplier;
            }
            if (this.keys['KeyD'] || this.keys['ArrowRight']) {
                moveVector.x += moveSpeed * boostMultiplier;
            }
            moveVector.applyQuaternion(this.camera.quaternion);
            this.camera.position.add(moveVector);
        }

        updateAsteroids(deltaTime) {
            for (const asteroid of this.asteroids) {
                asteroid.mesh.position.addScaledVector(asteroid.direction, asteroid.speed * deltaTime);
                asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * deltaTime;
                asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * deltaTime;
                asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * deltaTime;
                const limit = 150;
                if (Math.abs(asteroid.mesh.position.x) > limit) {
                    asteroid.mesh.position.x = -Math.sign(asteroid.mesh.position.x) * (limit - 5);
                }
                if (Math.abs(asteroid.mesh.position.y) > limit) {
                    asteroid.mesh.position.y = -Math.sign(asteroid.mesh.position.y) * (limit - 5);
                }
                if (Math.abs(asteroid.mesh.position.z) > limit) {
                    asteroid.mesh.position.z = -Math.sign(asteroid.mesh.position.z) * (limit - 5);
                }
            }
        }

        updateProjectiles(deltaTime) {
            const now = Date.now();
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const projectile = this.projectiles[i];
                projectile.mesh.position.addScaledVector(projectile.direction, projectile.speed * deltaTime);
                if (now - projectile.created > projectile.lifeTime) {
                    this.scene.remove(projectile.mesh);
                    this.projectiles.splice(i, 1);
                }
            }
        }

        updateRadar() {
            const radar = document.getElementById('radar');
            const radarRadius = 75;
            const maxDistance = 150;
            for (let i = 0; i < this.radarBlips.length; i++) {
                const blip = this.radarBlips[i];
                if (!this.asteroids.includes(blip.asteroid)) {
                    radar.removeChild(blip.element);
                    this.radarBlips.splice(i, 1);
                    i--;
                    continue;
                }
                const relativePos = blip.asteroid.mesh.position.clone().sub(this.camera.position);
                const distance = relativePos.length();
                const normalizedDistance = Math.min(distance / maxDistance, 1) * radarRadius;
                const angle = Math.atan2(relativePos.x, relativePos.z);
                const radarX = Math.sin(angle) * normalizedDistance;
                const radarY = Math.cos(angle) * normalizedDistance;
                blip.element.style.left = (radarRadius + radarX) + 'px';
                blip.element.style.top = (radarRadius + radarY) + 'px';
                let blipSize;
                if (blip.asteroid.size === 'large') blipSize = 6; else if (blip.asteroid.size === 'medium') blipSize = 4; else blipSize = 3;
                blip.element.style.width = blipSize + 'px';
                blip.element.style.height = blipSize + 'px';
                const opacity = 1 - (normalizedDistance / radarRadius) * 0.7;
                blip.element.style.opacity = opacity;
            }
        }

        checkCollisions() {
            for (let i = 0; i < this.asteroids.length; i++) {
                const asteroid = this.asteroids[i];
                const distance = this.camera.position.distanceTo(asteroid.mesh.position);
                let collisionThreshold;
                if (asteroid.size === 'large') collisionThreshold = 10; else if (asteroid.size === 'medium') collisionThreshold = 5; else collisionThreshold = 3;
                if (distance < collisionThreshold) {
                    this.playerHit();
                    break;
                }
            }
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const projectile = this.projectiles[i];
                for (let j = this.asteroids.length - 1; j >= 0; j--) {
                    const asteroid = this.asteroids[j];
                    const distance = projectile.mesh.position.distanceTo(asteroid.mesh.position);
                    let collisionThreshold;
                    if (asteroid.size === 'large') collisionThreshold = 8; else if (asteroid.size === 'medium') collisionThreshold = 4; else collisionThreshold = 2;
                    if (distance < collisionThreshold) {
                        this.scene.remove(projectile.mesh);
                        this.projectiles.splice(i, 1);
                        this.asteroidHit(asteroid, j);
                        break;
                    }
                }
            }
            if (this.asteroids.length === 0) {
                this.levelUp();
            }
        }

        asteroidHit(asteroid, index) {
            this.score += asteroid.points;
            this.updateHUD();
            this.createExplosion(asteroid.mesh.position, asteroid.size);
            if (asteroid.size !== 'small') {
                const newSize = asteroid.size === 'large' ? 'medium' : 'small';
                const fragmentCount = asteroid.size === 'large' ? 3 : 2;
                for (let i = 0; i < fragmentCount; i++) {
                    const newAsteroid = this.createAsteroid(newSize, asteroid.mesh.position.clone());
                    const spreadDirection = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
                    newAsteroid.direction.copy(spreadDirection);
                }
            }
            this.scene.remove(asteroid.mesh);
            this.asteroids.splice(index, 1);
        }

        createExplosion(position, size) {
            const particleCount = size === 'large' ? 40 : size === 'medium' ? 25 : 15;
            const particleSize = size === 'large' ? 0.5 : size === 'medium' ? 0.3 : 0.2;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                const radius = size === 'large' ? 4 : size === 'medium' ? 2 : 1;
                vertices.push(position.x, position.y, position.z);
                const direction = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
                const speed = 0.1 + Math.random() * 0.2;
                velocities.push(direction.x * speed, direction.y * speed, direction.z * speed);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            let color;
            if (size === 'large') color = 0xff5500; else if (size === 'medium') color = 0xff9900; else color = 0xffdd00;
            const material = new THREE.PointsMaterial({
                color: color,
                size: particleSize,
                transparent: true,
                opacity: 1
            });
            const particles = new THREE.Points(geometry, material);
            this.scene.add(particles);
            const light = new THREE.PointLight(color, 2, 20);
            light.position.copy(position);
            this.scene.add(light);
            const startTime = Date.now();
            const duration = 800;
            const animateExplosion = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                if (progress >= 1) {
                    this.scene.remove(particles);
                    this.scene.remove(light);
                    return;
                }
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0, j = 0; i < positions.length; i += 3, j += 3) {
                    positions[i] += velocities[j] * (1 - progress);
                    positions[i + 1] += velocities[j + 1] * (1 - progress);
                    positions[i + 2] += velocities[j + 2] * (1 - progress);
                }
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - progress;
                light.intensity = 2 * (1 - progress);
                requestAnimationFrame(animateExplosion);
            };
            animateExplosion();
        }

        playerHit() {
            this.shield -= 20 + 10 * this.level;
            this.shield = Math.max(0, this.shield);
            this.updateHUD();
            const hitFlash = document.getElementById('hit-flash');
            hitFlash.style.display = 'block';
            setTimeout(() => {
                hitFlash.style.display = 'none';
            }, 100);
            const shakeDuration = 300;
            const startTime = Date.now();
            const shakeCamera = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < shakeDuration) {
                    const intensity = 0.2 * (1 - elapsed / shakeDuration);
                    const shakeOffset = new THREE.Vector3((Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity);
                    this.camera.position.add(shakeOffset);
                    requestAnimationFrame(shakeCamera);
                }
            };
            shakeCamera();
            if (this.shield <= 0) {
                this.lives--;
                this.updateHUD();
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.shield = 100;
                    this.updateHUD();
                    this.showMessage("SHIELD FAILURE!");
                }
            }
        }

        showMessage(text) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.style.display = 'block';
            setTimeout(() => {
                message.style.display = 'none';
            }, 2000);
        }

        levelUp() {
            this.level++;
            this.updateHUD();
            this.shield = Math.min(100, this.shield + 20);
            this.updateHUD();
            this.showMessage(`LEVEL ${this.level}`);
            setTimeout(() => {
                this.createAsteroids();
            }, 1500);
        }

        regenShield(deltaTime) {
            if (this.shield < 100) {
                this.shield = Math.min(100, this.shield + this.shieldRegenRate * deltaTime);
                this.updateHUD();
            }
        }

        updateHUD() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('lives').textContent = this.lives;
            document.getElementById('level').textContent = this.level;
            document.getElementById('shield').textContent = Math.floor(this.shield);
        }

        update(time) {
            if (this.gameState !== 'playing' || this.isPaused) return;
            const deltaTime = Math.min(60, time - this.lastTime) / 16;
            this.lastTime = time;
            this.updatePlayerMovement(deltaTime);
            this.updateAsteroids(deltaTime);
            this.updateProjectiles(deltaTime);
            this.updateRadar();
            this.checkCollisions();
            this.regenShield(deltaTime);
        }

        render(time) {
            this.update(time);
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame((t) => this.render(t));
        }

        startGame() {
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            this.gameState = 'playing';
            this.score = 0;
            this.lives = 3;
            this.level = 1;
            this.shield = 100;
            this.updateHUD();
            this.camera.position.set(0, 0, 0);
            this.pitch = 0;
            this.yaw = 0;
            this.camera.rotation.order = 'YXZ';
            this.camera.rotation.set(0, 0, 0);
            for (const asteroid of this.asteroids) {
                this.scene.remove(asteroid.mesh);
            }
            this.asteroids = [];
            for (const projectile of this.projectiles) {
                this.scene.remove(projectile.mesh);
            }
            this.projectiles = [];
            const radar = document.getElementById('radar');
            while (radar.childElementCount > 2) {
                radar.removeChild(radar.lastChild);
            }
            this.radarBlips = [];
            this.createAsteroids();
            document.body.requestPointerLock();
            this.showMessage("START GAME!");
        }

        pauseGame() {
            if (this.gameState !== 'playing') return;
            this.isPaused = true;
            document.getElementById('pause-screen').style.display = 'flex';
            document.exitPointerLock();
        }

        resumeGame() {
            this.isPaused = false;
            document.getElementById('pause-screen').style.display = 'none';
            document.body.requestPointerLock();
        }

        gameOver() {
            this.gameState = 'gameOver';
            document.getElementById('final-score').textContent = this.score;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('radar').style.display = 'none';
            document.exitPointerLock();
        }

        setupEventListeners() {
            document.addEventListener('mousemove', (event) => {
                if (this.gameState !== 'playing' || this.isPaused || !this.pointerLocked) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.yaw -= movementX * 0.002;
                this.pitch -= movementY * 0.002;
                this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                this.camera.rotation.set(this.pitch, this.yaw, 0);
            });
            document.addEventListener('pointerlockchange', () => {
                this.pointerLocked = document.pointerLockElement !== null;
                if (!this.pointerLocked && this.gameState === 'playing' && !this.isPaused) {
                    this.pauseGame();
                }
            });
            document.addEventListener('keydown', (event) => {
                this.keys[event.code] = true;
                if (event.code === 'Space' && this.gameState === 'playing' && !this.isPaused) {
                    this.shoot();
                }
                if (event.code === 'Escape' && this.gameState === 'playing') {
                    if (this.isPaused) {
                        this.resumeGame();
                    } else {
                        this.pauseGame();
                    }
                }
            });
            document.addEventListener('keyup', (event) => {
                this.keys[event.code] = false;
            });
            document.addEventListener('click', () => {
                if (this.gameState === 'playing' && !this.isPaused && this.pointerLocked) {
                    this.shoot();
                }
            });
            document.getElementById('start-button').addEventListener('click', () => {
                this.startGame();
            });
            document.getElementById('resume-button').addEventListener('click', () => {
                this.resumeGame();
            });
            document.getElementById('menu-button').addEventListener('click', () => {
                this.isPaused = false;
                this.gameState = 'menu';
                document.getElementById('pause-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('radar').style.display = 'none';
                document.getElementById('menu-screen').style.display = 'flex';
            });
            document.getElementById('restart-button').addEventListener('click', () => {
                document.getElementById('game-over-screen').style.display = 'none';
                this.startGame();
            });
            document.getElementById('menu-button-end').addEventListener('click', () => {
                this.gameState = 'menu';
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('menu-screen').style.display = 'flex';
            });
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    }

    const game = new AsteroidsGame();
    game.render(0);
</script>
</body>
</html>