<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>3D Asteroids</title>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚òÑÔ∏è</text></svg>">
    <meta name="description"
          content="Experience thrilling first-person 3D Asteroids gameplay in this browser-based game. Navigate through space, shoot asteroids, and survive increasingly difficult levels.">
    <meta name="keywords" content="3D Asteroids, browser game, JavaScript game, first-person space shooter, ThreeJS">
    <meta name="author" content="Claude Sonnet 4.5">
    <style>
        :root {
            --bg: #0a0a0f;
            --text: #e0e0e0;
            --primary: #00d9ff;
            --secondary: #ff006e;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff0055;
            --ui-bg: rgba(10, 10, 20, 0.92);
            --ui-border: rgba(0, 217, 255, 0.3);
            --glow: 0 0 20px rgba(0, 217, 255, 0.5)
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg: #f5f5f5;
                --text: #1a1a1a;
                --ui-bg: rgba(240, 240, 245, 0.95)
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden
        }

        body.playing {
            cursor: none
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh
        }

        .overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
            cursor: default
        }

        .screen {
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 20px;
            padding: 40px;
            box-shadow: var(--glow), 0 10px 40px rgba(0, 0, 0, 0.6);
            max-width: 600px;
            text-align: center;
            animation: slideIn 0.3s ease-out
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px)
            }
            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        h1 {
            margin-bottom: 25px;
            font-size: 3.5em;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
            letter-spacing: 2px;
            font-weight: 900
        }

        h2 {
            color: var(--primary);
            font-size: 2em;
            margin-bottom: 20px
        }

        button {
            background: linear-gradient(135deg, var(--primary), #0099cc);
            color: #fff;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 217, 255, 0.4);
            position: relative;
            overflow: hidden
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 217, 255, 0.6)
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 217, 255, 0.4)
        }

        button.secondary {
            background: linear-gradient(135deg, #666, #444)
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s
        }

        button:active::before {
            width: 300px;
            height: 300px
        }

        p {
            margin: 15px 0;
            line-height: 1.6;
            font-size: 1.1em
        }

        .instructions {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
            border: 1px solid var(--ui-border)
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1em;
            z-index: 5;
            pointer-events: none;
            user-select: none
        }

        .hud-panel {
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 10px;
            box-shadow: var(--glow);
            min-width: 250px
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0
        }

        .hud-label {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px
        }

        .hud-value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--text)
        }

        .shield-container {
            margin-top: 12px
        }

        .shield-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--ui-border)
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width 0.3s, background 0.3s;
            border-radius: 5px;
            box-shadow: 0 0 10px var(--success)
        }

        .shield-fill.low {
            background: linear-gradient(90deg, var(--warning), var(--danger));
            box-shadow: 0 0 10px var(--danger)
        }

        .lives-display {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .life-icon {
            font-size: 1.5em;
            transition: transform 0.2s
        }

        .life-icon.lost {
            opacity: 0.2;
            transform: scale(0.7)
        }

        .combo-display {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.2), rgba(0, 217, 255, 0.2));
            border: 2px solid var(--secondary);
            animation: pulse 2s ease-in-out infinite
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 110, 0.5)
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 0, 110, 0.8)
            }
        }

        .combo-value {
            font-size: 2em;
            color: var(--secondary);
            text-shadow: 0 0 10px var(--secondary)
        }

        .multiplier {
            font-size: 0.9em;
            color: var(--warning);
            margin-top: 5px
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
            display: none
        }

        .crosshair-line {
            position: absolute;
            background: rgba(0, 217, 255, 0.8);
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.8)
        }

        .crosshair-line.h {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%)
        }

        .crosshair-line.v {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%)
        }

        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(0, 217, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 217, 255, 1)
        }

        .crosshair-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 217, 255, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: crosshairPulse 2s ease-in-out infinite
        }

        @keyframes crosshairPulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.8
            }
        }

        #radar {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 180px;
            height: 180px;
            background: radial-gradient(circle, rgba(0, 217, 255, 0.1), rgba(0, 0, 0, 0.6));
            border: 3px solid var(--ui-border);
            border-radius: 50%;
            display: none;
            pointer-events: none;
            overflow: hidden;
            box-shadow: var(--glow), inset 0 0 30px rgba(0, 217, 255, 0.2)
        }

        #radar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(0, 217, 255, 0.2)
        }

        #radar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            background: rgba(0, 217, 255, 0.2)
        }

        .radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px var(--success);
            z-index: 2
        }

        .radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 50%;
            background: linear-gradient(to bottom, rgba(0, 217, 255, 0.8), transparent);
            transform-origin: bottom center;
            animation: radarSweep 4s linear infinite;
            z-index: 1
        }

        @keyframes radarSweep {
            from {
                transform: rotate(0deg)
            }
            to {
                transform: rotate(360deg)
            }
        }

        .radar-blip {
            position: absolute;
            border-radius: 50%;
            background: var(--danger);
            box-shadow: 0 0 8px var(--danger);
            transition: all 0.2s
        }

        .hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 85, 0.4), transparent);
            z-index: 4;
            pointer-events: none;
            display: none
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 3em;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.8);
            display: none;
            z-index: 6;
            animation: messageAppear 0.5s ease-out
        }

        @keyframes messageAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5)
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1)
            }
        }

        .damage-number {
            position: absolute;
            font-size: 2em;
            font-weight: 900;
            color: var(--warning);
            text-shadow: 0 0 10px var(--warning);
            pointer-events: none;
            z-index: 5;
            animation: damageFloat 1s ease-out forwards
        }

        @keyframes damageFloat {
            from {
                opacity: 1;
                transform: translateY(0)
            }
            to {
                opacity: 0;
                transform: translateY(-50px)
            }
        }

        .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 15;
            font-size: 1.5em;
            box-shadow: var(--glow);
            pointer-events: all
        }

        .settings-btn:hover {
            transform: rotate(90deg);
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.8)
        }

        .settings-panel {
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 15px;
            padding: 25px;
            box-shadow: var(--glow);
            min-width: 300px
        }

        .slider-container {
            margin: 20px 0
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--primary)
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary)
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary);
            border: none
        }

        .high-score {
            font-size: 1.5em;
            color: var(--warning);
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 170, 0, 0.1);
            border-radius: 10px;
            border: 2px solid var(--warning)
        }

        .weapon-heat {
            margin-top: 8px
        }

        .heat-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden
        }

        .heat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--warning), var(--danger));
            transition: width 0.1s;
            border-radius: 3px
        }

        .heat-fill.critical {
            animation: heatPulse 0.5s ease-in-out infinite
        }

        @keyframes heatPulse {
            0%, 100% {
                opacity: 1
            }
            50% {
                opacity: 0.6
            }
        }

        .powerup-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--ui-bg);
            border: 2px solid var(--success);
            border-radius: 12px;
            padding: 10px 20px;
            display: none;
            animation: slideDown 0.3s ease-out;
            z-index: 5;
            box-shadow: var(--glow)
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px)
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0)
            }
        }

        .powerup-text {
            font-weight: 700;
            color: var(--success);
            font-size: 1.2em
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5em
            }

            .screen {
                padding: 25px;
                max-width: 90%
            }

            button {
                padding: 12px 30px;
                font-size: 1.1em
            }

            #hud {
                font-size: 0.9em
            }

            .hud-panel {
                min-width: 200px;
                padding: 12px 15px
            }

            #radar {
                width: 140px;
                height: 140px
            }
        }
    </style>
</head>
<body>
<div id="game-container">
    <div id="menu-screen" class="overlay">
        <div class="screen">
            <h1>3D ASTEROIDS</h1>
            <p>Navigate through asteroid fields in first-person view</p>
            <div class="high-score" id="high-score-display" style="display:none">üèÜ High Score: <span
                    id="high-score">0</span></div>
            <button id="start-button">START GAME</button>
            <div class="instructions">
                <p><strong>Controls:</strong><br>WASD / Arrow Keys - Movement<br>Mouse - Look Around<br>Left Click /
                    Space - Shoot<br>Shift - Boost Speed<br>ESC - Pause</p>
                <p style="margin-top:15px;font-size:0.95em;opacity:0.8">üéØ Build combos ‚Ä¢ üíé Collect power-ups ‚Ä¢ üõ°Ô∏è Manage
                    your shield</p>
            </div>
        </div>
    </div>
    <div id="hud" style="display:none">
        <div class="hud-panel">
            <div class="hud-row"><span class="hud-label">Score</span><span class="hud-value" id="score">0</span></div>
            <div class="hud-row"><span class="hud-label">Level</span><span class="hud-value" id="level">1</span></div>
            <div class="hud-row"><span class="hud-label">Lives</span>
                <div class="lives-display" id="lives-display"></div>
            </div>
            <div class="shield-container">
                <div class="hud-label" style="margin-bottom:6px">Shield</div>
                <div class="shield-bar">
                    <div class="shield-fill" id="shield-fill"></div>
                </div>
            </div>
            <div class="weapon-heat">
                <div class="hud-label" style="margin-bottom:6px">Weapon Heat</div>
                <div class="heat-bar">
                    <div class="heat-fill" id="heat-fill"></div>
                </div>
            </div>
        </div>
        <div class="hud-panel combo-display" id="combo-display" style="display:none">
            <div class="hud-label">Combo</div>
            <div class="combo-value" id="combo-value">0</div>
            <div class="multiplier" id="multiplier">√ó1.0</div>
        </div>
    </div>
    <div id="pause-screen" class="overlay" style="display:none">
        <div class="screen">
            <h2>PAUSED</h2>
            <p style="font-size:1.1em;margin:20px 0;opacity:0.8">Click to resume</p>
            <button id="resume-button">RESUME</button>
            <button id="menu-button" class="secondary">MAIN MENU</button>
        </div>
    </div>
    <div id="game-over-screen" class="overlay" style="display:none">
        <div class="screen">
            <h2>GAME OVER</h2>
            <p style="font-size:1.8em;margin:20px 0">Final Score: <span id="final-score"
                                                                        style="color:var(--warning)">0</span></p>
            <p id="new-high-score" style="display:none;color:var(--success);font-size:1.3em;margin:15px 0">üèÜ NEW HIGH
                SCORE! üèÜ</p>
            <button id="restart-button">PLAY AGAIN</button>
            <button id="menu-button-end" class="secondary">MAIN MENU</button>
        </div>
    </div>
    <div class="settings-btn" id="settings-btn">‚öôÔ∏è</div>
    <div id="settings-screen" class="overlay" style="display:none">
        <div class="screen settings-panel">
            <h2>Settings</h2>
            <div class="slider-container">
                <div class="slider-label"><span>Master Volume</span><span id="volume-value">70%</span></div>
                <input type="range" min="0" max="100" value="70" class="slider" id="volume-slider">
            </div>
            <div class="slider-container">
                <div class="slider-label"><span>Mouse Sensitivity</span><span id="sensitivity-value">50%</span></div>
                <input type="range" min="10" max="100" value="50" class="slider" id="sensitivity-slider">
            </div>
            <button id="close-settings">CLOSE</button>
        </div>
    </div>
    <div class="crosshair" id="crosshair">
        <div class="crosshair-line h"></div>
        <div class="crosshair-line v"></div>
        <div class="crosshair-dot"></div>
        <div class="crosshair-ring"></div>
    </div>
    <div id="radar">
        <div class="radar-center"></div>
        <div class="radar-sweep"></div>
    </div>
    <div class="hit-flash" id="hit-flash"></div>
    <div class="message" id="message"></div>
    <div class="powerup-indicator" id="powerup-indicator">
        <div class="powerup-text" id="powerup-text"></div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
    class AudioSystem {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.volume = 0.7;
            this.enabled = false;
        }

        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = this.volume;
                this.enabled = true;
            } catch (e) {
                console.warn('Audio not available');
            }
        }

        setVolume(v) {
            this.volume = v;
            if (this.masterGain) this.masterGain.gain.value = v;
        }

        playShoot() {
            if (!this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
            filter.type = 'lowpass';
            filter.frequency.value = 1200;
            gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
        }

        playExplosion(size) {
            if (!this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const noise = this.ctx.createBufferSource();
            const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = noiseBuffer;
            let freq = size === 'large' ? 120 : size === 'medium' ? 200 : 300;
            let dur = size === 'large' ? 0.4 : size === 'medium' ? 0.25 : 0.15;
            let vol = size === 'large' ? 0.25 : size === 'medium' ? 0.18 : 0.12;
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + dur);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, this.ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + dur);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
            osc.connect(filter);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            noise.start();
            osc.stop(this.ctx.currentTime + dur);
            noise.stop(this.ctx.currentTime + dur);
        }

        playHit() {
            if (!this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }

        playLevelUp() {
            if (!this.enabled) return;
            const playTone = (freq, delay, dur) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.12, this.ctx.currentTime + delay);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + dur);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(this.ctx.currentTime + delay);
                osc.stop(this.ctx.currentTime + delay + dur);
            };
            playTone(523.25, 0, 0.15);
            playTone(659.25, 0.15, 0.15);
            playTone(783.99, 0.3, 0.3);
        }

        playPowerUp() {
            if (!this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }

        playClick() {
            if (!this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 800;
            gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.05);
        }
    }

    class AsteroidsGame {
        constructor() {
            this.audio = new AudioSystem();
            this.score = 0;
            this.lives = 3;
            this.level = 1;
            this.shield = 100;
            this.gameState = 'menu';
            this.isPaused = false;
            this.keys = {};
            this.asteroids = [];
            this.projectiles = [];
            this.powerups = [];
            this.lastTime = 0;
            this.lastShotTime = 0;
            this.fireRate = 120;
            this.weaponHeat = 0;
            this.heatCooldown = 0.15;
            this.heatPerShot = 15;
            this.maxHeat = 100;
            this.pointerLocked = false;
            this.moveSpeed = 0.4;
            this.boostMultiplier = 1.8;
            this.shieldRegenRate = 0.05;
            this.pitch = 0;
            this.yaw = 0;
            this.combo = 0;
            this.comboTimer = 0;
            this.comboTimeout = 3000;
            this.scoreMultiplier = 1;
            this.highScore = parseInt(localStorage.getItem('asteroidsHighScore') || '0');
            this.sensitivity = 0.5;
            this.justResumed = false;
            this.setupThreeJS();
            this.setupEventListeners();
            this.loadSettings();
            if (this.highScore > 0) {
                document.getElementById('high-score-display').style.display = 'block';
                document.getElementById('high-score').textContent = this.highScore;
            }
        }

        setupThreeJS() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.rotation.order = 'YXZ';
            this.renderer = new THREE.WebGLRenderer({antialias: true});
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x000011);
            document.getElementById('game-container').appendChild(this.renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x404040);
            this.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            this.scene.add(directionalLight);
            this.createStarfield();
            this.scene.add(this.camera);
            this.radarBlips = [];
        }

        createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            for (let i = 0; i < 5000; i++) {
                starsVertices.push(
                    Math.random() * 2000 - 1000,
                    Math.random() * 2000 - 1000,
                    Math.random() * 2000 - 1000
                );
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starsMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.15});
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            this.scene.add(stars);
            const nebulaMaterial = new THREE.PointsMaterial({
                color: 0x4466ff,
                size: 2,
                transparent: true,
                opacity: 0.3
            });
            const nebulaGeometry = new THREE.BufferGeometry();
            const nebulaVertices = [];
            for (let i = 0; i < 200; i++) {
                nebulaVertices.push(
                    Math.random() * 1500 - 750,
                    Math.random() * 1500 - 750,
                    Math.random() * 1500 - 750
                );
            }
            nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
            const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
            this.scene.add(nebula);
        }

        createAsteroids() {
            const count = 5 + this.level * 2;
            for (let i = 0; i < count; i++) {
                this.createAsteroid('large');
            }
        }

        createAsteroid(size, position = null) {
            let radius, detail, speed, points;
            switch (size) {
                case 'large':
                    radius = 8;
                    detail = 1;
                    speed = 0.15;
                    points = 20;
                    break;
                case 'medium':
                    radius = 4;
                    detail = 1;
                    speed = 0.25;
                    points = 50;
                    break;
                case 'small':
                    radius = 2;
                    detail = 0;
                    speed = 0.35;
                    points = 100;
                    break;
            }
            const geometryTypes = [
                () => new THREE.IcosahedronGeometry(radius, detail),
                () => new THREE.OctahedronGeometry(radius, detail),
                () => new THREE.TetrahedronGeometry(radius, detail + 1)
            ];
            const geometry = geometryTypes[Math.floor(Math.random() * 3)]();
            const materialOptions = [
                new THREE.MeshStandardMaterial({color: 0x8a8a8a, roughness: 0.9, metalness: 0.1, flatShading: true}),
                new THREE.MeshStandardMaterial({color: 0x6e5b47, roughness: 0.85, metalness: 0.15, flatShading: true}),
                new THREE.MeshStandardMaterial({color: 0x576b65, roughness: 0.8, metalness: 0.2, flatShading: true})
            ];
            const material = materialOptions[Math.floor(Math.random() * materialOptions.length)];
            const asteroid = new THREE.Mesh(geometry, material);
            if (position) {
                asteroid.position.copy(position);
            } else {
                do {
                    asteroid.position.set(
                        Math.random() * 200 - 100,
                        Math.random() * 200 - 100,
                        Math.random() * 200 - 100
                    );
                } while (asteroid.position.length() < 40);
            }
            asteroid.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );
            const direction = new THREE.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();
            const asteroidData = {
                mesh: asteroid,
                size: size,
                direction: direction,
                speed: speed * (0.8 + Math.random() * 0.4),
                rotationSpeed: {
                    x: Math.random() * 0.01 - 0.005,
                    y: Math.random() * 0.01 - 0.005,
                    z: Math.random() * 0.01 - 0.005
                },
                points: points,
                radius: radius
            };
            this.asteroids.push(asteroidData);
            this.scene.add(asteroid);
            this.createRadarBlip(asteroidData);
            return asteroidData;
        }

        createRadarBlip(asteroidData) {
            const blipElement = document.createElement('div');
            blipElement.className = 'radar-blip';
            blipElement.style.width = '4px';
            blipElement.style.height = '4px';
            document.getElementById('radar').appendChild(blipElement);
            this.radarBlips.push({element: blipElement, asteroid: asteroidData});
        }

        shoot() {
            const now = Date.now();
            if (this.weaponHeat >= this.maxHeat || now - this.lastShotTime < this.fireRate) return;
            this.lastShotTime = now;
            this.weaponHeat = Math.min(this.maxHeat, this.weaponHeat + this.heatPerShot);
            this.updateHeatBar();
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshBasicMaterial({color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 2});
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(this.camera.position);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(this.camera.quaternion);
            const trailGeometry = new THREE.CylinderGeometry(0.05, 0.15, 1, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({color: 0x00ff88, transparent: true, opacity: 0.6});
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            projectile.add(trail);
            const targetPoint = projectile.position.clone().add(direction.multiplyScalar(10));
            projectile.lookAt(targetPoint);
            const projectileData = {
                mesh: projectile,
                direction: direction.normalize(),
                speed: 2.0,
                lifeTime: 1500,
                created: Date.now()
            };
            this.projectiles.push(projectileData);
            this.scene.add(projectile);
            const light = new THREE.PointLight(0x00ff88, 3, 15);
            light.position.copy(this.camera.position);
            this.scene.add(light);
            setTimeout(() => this.scene.remove(light), 100);
            this.audio.playShoot();
        }

        updatePlayerMovement(deltaTime) {
            const moveSpeed = this.moveSpeed * deltaTime;
            const boostMultiplier = (this.keys['ShiftLeft'] || this.keys['ShiftRight']) ? this.boostMultiplier : 1.0;
            let moveVector = new THREE.Vector3(0, 0, 0);
            if (this.keys['KeyW'] || this.keys['ArrowUp']) moveVector.z -= moveSpeed * boostMultiplier;
            if (this.keys['KeyS'] || this.keys['ArrowDown']) moveVector.z += moveSpeed * boostMultiplier;
            if (this.keys['KeyA'] || this.keys['ArrowLeft']) moveVector.x -= moveSpeed * boostMultiplier;
            if (this.keys['KeyD'] || this.keys['ArrowRight']) moveVector.x += moveSpeed * boostMultiplier;
            moveVector.applyQuaternion(this.camera.quaternion);
            this.camera.position.add(moveVector);
        }

        updateAsteroids(deltaTime) {
            for (const asteroid of this.asteroids) {
                asteroid.mesh.position.addScaledVector(asteroid.direction, asteroid.speed * deltaTime);
                asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * deltaTime;
                asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * deltaTime;
                asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * deltaTime;
                const limit = 150;
                if (Math.abs(asteroid.mesh.position.x) > limit)
                    asteroid.mesh.position.x = -Math.sign(asteroid.mesh.position.x) * (limit - 5);
                if (Math.abs(asteroid.mesh.position.y) > limit)
                    asteroid.mesh.position.y = -Math.sign(asteroid.mesh.position.y) * (limit - 5);
                if (Math.abs(asteroid.mesh.position.z) > limit)
                    asteroid.mesh.position.z = -Math.sign(asteroid.mesh.position.z) * (limit - 5);
            }
        }

        updateProjectiles(deltaTime) {
            const now = Date.now();
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const projectile = this.projectiles[i];
                projectile.mesh.position.addScaledVector(projectile.direction, projectile.speed * deltaTime);
                if (projectile.mesh.children[0]) {
                    projectile.mesh.children[0].material.opacity = Math.max(0, 1 - (now - projectile.created) / projectile.lifeTime);
                }
                if (now - projectile.created > projectile.lifeTime) {
                    this.scene.remove(projectile.mesh);
                    this.projectiles.splice(i, 1);
                }
            }
        }

        updatePowerups(deltaTime) {
            const now = Date.now();
            for (let i = this.powerups.length - 1; i >= 0; i--) {
                const powerup = this.powerups[i];
                powerup.mesh.rotation.y += 0.02 * deltaTime;
                powerup.mesh.position.y += Math.sin(now / 300 + i) * 0.01 * deltaTime;
                if (this.camera.position.distanceTo(powerup.mesh.position) < 5) {
                    this.collectPowerup(powerup);
                    this.scene.remove(powerup.mesh);
                    this.powerups.splice(i, 1);
                } else if (now - powerup.created > 15000) {
                    this.scene.remove(powerup.mesh);
                    this.powerups.splice(i, 1);
                }
            }
        }

        updateRadar() {
            const radarRadius = 90;
            const maxDistance = 150;
            for (let i = 0; i < this.radarBlips.length; i++) {
                const blip = this.radarBlips[i];
                if (!this.asteroids.includes(blip.asteroid)) {
                    document.getElementById('radar').removeChild(blip.element);
                    this.radarBlips.splice(i, 1);
                    i--;
                    continue;
                }
                const relativePos = blip.asteroid.mesh.position.clone().sub(this.camera.position);
                const distance = relativePos.length();
                const normalizedDistance = Math.min(distance / maxDistance, 1) * radarRadius;
                const angle = Math.atan2(relativePos.x, relativePos.z);
                const radarX = Math.sin(angle) * normalizedDistance;
                const radarY = Math.cos(angle) * normalizedDistance;
                blip.element.style.left = (radarRadius + radarX) + 'px';
                blip.element.style.top = (radarRadius + radarY) + 'px';
                let blipSize = blip.asteroid.size === 'large' ? 6 : blip.asteroid.size === 'medium' ? 4 : 3;
                blip.element.style.width = blipSize + 'px';
                blip.element.style.height = blipSize + 'px';
                blip.element.style.opacity = 1 - (normalizedDistance / radarRadius) * 0.7;
            }
        }

        checkCollisions() {
            for (let i = 0; i < this.asteroids.length; i++) {
                const asteroid = this.asteroids[i];
                const distance = this.camera.position.distanceTo(asteroid.mesh.position);
                let collisionThreshold = asteroid.size === 'large' ? 10 : asteroid.size === 'medium' ? 5 : 3;
                if (distance < collisionThreshold) {
                    this.playerHit();
                    break;
                }
            }
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const projectile = this.projectiles[i];
                for (let j = this.asteroids.length - 1; j >= 0; j--) {
                    const asteroid = this.asteroids[j];
                    const distance = projectile.mesh.position.distanceTo(asteroid.mesh.position);
                    let collisionThreshold = asteroid.size === 'large' ? 8 : asteroid.size === 'medium' ? 4 : 2;
                    if (distance < collisionThreshold) {
                        this.scene.remove(projectile.mesh);
                        this.projectiles.splice(i, 1);
                        this.asteroidHit(asteroid, j);
                        break;
                    }
                }
            }
            if (this.asteroids.length === 0) {
                this.levelUp();
            }
        }

        asteroidHit(asteroid, index) {
            this.combo++;
            this.comboTimer = Date.now();
            this.scoreMultiplier = 1 + Math.floor(this.combo / 5) * 0.5;
            const earnedPoints = Math.floor(asteroid.points * this.scoreMultiplier);
            this.score += earnedPoints;
            this.updateHUD();
            this.updateComboDisplay();
            this.showDamageNumber(asteroid.mesh.position, earnedPoints);
            this.createExplosion(asteroid.mesh.position, asteroid.size);
            this.audio.playExplosion(asteroid.size);
            if (asteroid.size !== 'small') {
                const newSize = asteroid.size === 'large' ? 'medium' : 'small';
                const fragmentCount = asteroid.size === 'large' ? 3 : 2;
                for (let i = 0; i < fragmentCount; i++) {
                    const newAsteroid = this.createAsteroid(newSize, asteroid.mesh.position.clone());
                    const spreadDirection = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    newAsteroid.direction.copy(spreadDirection);
                }
            } else if (Math.random() < 0.15) {
                this.spawnPowerup(asteroid.mesh.position);
            }
            this.scene.remove(asteroid.mesh);
            this.asteroids.splice(index, 1);
        }

        createExplosion(position, size) {
            const particleCount = size === 'large' ? 60 : size === 'medium' ? 40 : 25;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const velocities = [];
            const colors = [];
            for (let i = 0; i < particleCount; i++) {
                vertices.push(position.x, position.y, position.z);
                const direction = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                ).normalize();
                const speed = 0.15 + Math.random() * 0.25;
                velocities.push(direction.x * speed, direction.y * speed, direction.z * speed);
                const t = Math.random();
                colors.push(1, t * 0.5, 0);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: size === 'large' ? 0.8 : size === 'medium' ? 0.5 : 0.3,
                transparent: true,
                opacity: 1,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            this.scene.add(particles);
            const light = new THREE.PointLight(0xff5500, 3, 30);
            light.position.copy(position);
            this.scene.add(light);
            const startTime = Date.now();
            const duration = 1000;
            const animateExplosion = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                if (progress >= 1) {
                    this.scene.remove(particles);
                    this.scene.remove(light);
                    return;
                }
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0, j = 0; i < positions.length; i += 3, j += 3) {
                    positions[i] += velocities[j] * (1 - progress * 0.5);
                    positions[i + 1] += velocities[j + 1] * (1 - progress * 0.5);
                    positions[i + 2] += velocities[j + 2] * (1 - progress * 0.5);
                }
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - progress;
                light.intensity = 3 * (1 - progress);
                requestAnimationFrame(animateExplosion);
            };
            animateExplosion();
        }

        showDamageNumber(position, points) {
            const div = document.createElement('div');
            div.className = 'damage-number';
            div.textContent = '+' + points;
            const screenPos = position.clone().project(this.camera);
            div.style.left = (screenPos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            div.style.top = (-screenPos.y * 0.5 + 0.5) * window.innerHeight + 'px';
            document.getElementById('game-container').appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        spawnPowerup(position) {
            const types = ['shield', 'weapon', 'score'];
            const type = types[Math.floor(Math.random() * types.length)];
            const geometry = new THREE.OctahedronGeometry(1.5, 0);
            const colorMap = {shield: 0x00ff88, weapon: 0xff6600, score: 0xffaa00};
            const material = new THREE.MeshStandardMaterial({
                color: colorMap[type],
                emissive: colorMap[type],
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            const light = new THREE.PointLight(colorMap[type], 2, 20);
            light.position.copy(position);
            this.scene.add(light);
            mesh.add(light);
            this.scene.add(mesh);
            this.powerups.push({mesh: mesh, type: type, created: Date.now()});
        }

        collectPowerup(powerup) {
            this.audio.playPowerUp();
            const messages = {
                shield: 'SHIELD +50',
                weapon: 'WEAPON COOLED',
                score: 'SCORE MULTIPLIER +0.5'
            };
            this.showPowerupMessage(messages[powerup.type]);
            switch (powerup.type) {
                case 'shield':
                    this.shield = Math.min(100, this.shield + 50);
                    this.updateHUD();
                    break;
                case 'weapon':
                    this.weaponHeat = 0;
                    this.updateHeatBar();
                    break;
                case 'score':
                    this.scoreMultiplier += 0.5;
                    break;
            }
        }

        showPowerupMessage(text) {
            const indicator = document.getElementById('powerup-indicator');
            const textEl = document.getElementById('powerup-text');
            textEl.textContent = text;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }

        playerHit() {
            this.shield -= 20 + 10 * this.level;
            this.shield = Math.max(0, this.shield);
            this.updateHUD();
            this.combo = 0;
            this.comboTimer = 0;
            this.scoreMultiplier = 1;
            this.updateComboDisplay();
            const hitFlash = document.getElementById('hit-flash');
            hitFlash.style.display = 'block';
            setTimeout(() => hitFlash.style.display = 'none', 100);
            this.audio.playHit();
            const shakeDuration = 300;
            const startTime = Date.now();
            const shakeCamera = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed < shakeDuration) {
                    const intensity = 0.2 * (1 - elapsed / shakeDuration);
                    const shakeOffset = new THREE.Vector3(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity
                    );
                    this.camera.position.add(shakeOffset);
                    requestAnimationFrame(shakeCamera);
                }
            };
            shakeCamera();
            if (this.shield <= 0) {
                this.lives--;
                this.updateHUD();
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.shield = 100;
                    this.updateHUD();
                    this.showMessage("SHIELD FAILURE!");
                }
            }
        }

        showMessage(text) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.style.display = 'block';
            setTimeout(() => message.style.display = 'none', 2000);
        }

        levelUp() {
            this.level++;
            this.updateHUD();
            this.shield = Math.min(100, this.shield + 20);
            this.updateHUD();
            this.showMessage(`LEVEL ${this.level}`);
            this.audio.playLevelUp();
            setTimeout(() => this.createAsteroids(), 1500);
        }

        regenShield(deltaTime) {
            if (this.shield < 100) {
                this.shield = Math.min(100, this.shield + this.shieldRegenRate * deltaTime);
                this.updateHUD();
            }
        }

        coolWeapon(deltaTime) {
            if (this.weaponHeat > 0) {
                this.weaponHeat = Math.max(0, this.weaponHeat - this.heatCooldown * deltaTime);
                this.updateHeatBar();
            }
        }

        updateCombo(deltaTime) {
            if (this.combo > 0 && Date.now() - this.comboTimer > this.comboTimeout) {
                this.combo = 0;
                this.scoreMultiplier = 1;
                this.updateComboDisplay();
            }
        }

        updateComboDisplay() {
            const comboDisplay = document.getElementById('combo-display');
            if (this.combo > 2) {
                comboDisplay.style.display = 'block';
                document.getElementById('combo-value').textContent = this.combo;
                document.getElementById('multiplier').textContent = '√ó' + this.scoreMultiplier.toFixed(1);
            } else {
                comboDisplay.style.display = 'none';
            }
        }

        updateHUD() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('level').textContent = this.level;
            const livesDisplay = document.getElementById('lives-display');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const icon = document.createElement('span');
                icon.className = 'life-icon' + (i >= this.lives ? ' lost' : '');
                icon.textContent = '‚ù§Ô∏è';
                livesDisplay.appendChild(icon);
            }
            const shieldFill = document.getElementById('shield-fill');
            shieldFill.style.width = this.shield + '%';
            shieldFill.className = 'shield-fill' + (this.shield < 30 ? ' low' : '');
        }

        updateHeatBar() {
            const heatFill = document.getElementById('heat-fill');
            heatFill.style.width = this.weaponHeat + '%';
            heatFill.className = 'heat-fill' + (this.weaponHeat >= this.maxHeat ? ' critical' : '');
        }

        update(time) {
            if (this.gameState !== 'playing' || this.isPaused) return;
            const deltaTime = Math.min(60, time - this.lastTime) / 16;
            this.lastTime = time;
            this.updatePlayerMovement(deltaTime);
            this.updateAsteroids(deltaTime);
            this.updateProjectiles(deltaTime);
            this.updatePowerups(deltaTime);
            this.updateRadar();
            this.checkCollisions();
            this.regenShield(deltaTime);
            this.coolWeapon(deltaTime);
            this.updateCombo(deltaTime);
        }

        render(time) {
            this.update(time);
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(t => this.render(t));
        }

        startGame() {
            this.audio.init();
            document.body.classList.add('playing');
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            this.gameState = 'playing';
            this.score = 0;
            this.lives = 3;
            this.level = 1;
            this.shield = 100;
            this.weaponHeat = 0;
            this.combo = 0;
            this.comboTimer = 0;
            this.scoreMultiplier = 1;
            this.lastShotTime = 0;
            this.updateHUD();
            this.updateHeatBar();
            this.updateComboDisplay();
            this.camera.position.set(0, 0, 0);
            this.pitch = 0;
            this.yaw = 0;
            this.camera.rotation.set(0, 0, 0);
            for (const asteroid of this.asteroids) this.scene.remove(asteroid.mesh);
            this.asteroids = [];
            for (const projectile of this.projectiles) this.scene.remove(projectile.mesh);
            this.projectiles = [];
            for (const powerup of this.powerups) this.scene.remove(powerup.mesh);
            this.powerups = [];
            const radar = document.getElementById('radar');
            while (radar.childElementCount > 2) radar.removeChild(radar.lastChild);
            this.radarBlips = [];
            this.createAsteroids();
            document.body.requestPointerLock();
            this.showMessage("START GAME!");
        }

        pauseGame() {
            if (this.gameState !== 'playing') return;
            this.isPaused = true;
            document.body.classList.remove('playing');
            document.getElementById('pause-screen').style.display = 'flex';
            document.exitPointerLock();
        }

        resumeGame() {
            this.isPaused = false;
            this.justResumed = true;
            document.body.classList.add('playing');
            document.getElementById('pause-screen').style.display = 'none';
            document.body.requestPointerLock();
            setTimeout(() => {
                this.justResumed = false;
            }, 200);
        }

        gameOver() {
            this.gameState = 'gameOver';
            document.body.classList.remove('playing');
            document.getElementById('final-score').textContent = this.score;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('asteroidsHighScore', this.highScore);
                document.getElementById('new-high-score').style.display = 'block';
                document.getElementById('high-score').textContent = this.highScore;
            } else {
                document.getElementById('new-high-score').style.display = 'none';
            }
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('radar').style.display = 'none';
            document.exitPointerLock();
        }

        loadSettings() {
            const savedVolume = localStorage.getItem('asteroidsVolume');
            const savedSensitivity = localStorage.getItem('asteroidsSensitivity');
            if (savedVolume) {
                this.audio.volume = parseFloat(savedVolume);
                document.getElementById('volume-slider').value = this.audio.volume * 100;
                document.getElementById('volume-value').textContent = Math.round(this.audio.volume * 100) + '%';
            }
            if (savedSensitivity) {
                this.sensitivity = parseFloat(savedSensitivity);
                document.getElementById('sensitivity-slider').value = this.sensitivity * 100;
                document.getElementById('sensitivity-value').textContent = Math.round(this.sensitivity * 100) + '%';
            }
        }

        setupEventListeners() {
            document.addEventListener('mousemove', event => {
                if (this.gameState !== 'playing' || this.isPaused || !this.pointerLocked) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.yaw -= movementX * 0.002 * this.sensitivity;
                this.pitch -= movementY * 0.002 * this.sensitivity;
                this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                this.camera.rotation.set(this.pitch, this.yaw, 0);
            });

            document.addEventListener('pointerlockchange', () => {
                this.pointerLocked = document.pointerLockElement !== null;
                if (!this.pointerLocked && this.gameState === 'playing' && !this.isPaused && !this.justResumed) {
                    this.pauseGame();
                }
            });

            document.addEventListener('keydown', event => {
                this.keys[event.code] = true;
                if (event.code === 'Space' && this.gameState === 'playing' && !this.isPaused) {
                    event.preventDefault();
                    this.shoot();
                }
                if (event.code === 'Escape' && this.gameState === 'playing') {
                    event.preventDefault();
                    if (this.isPaused) {
                        this.resumeGame();
                    } else {
                        this.pauseGame();
                    }
                }
            });

            document.addEventListener('keyup', event => {
                this.keys[event.code] = false;
            });

            document.addEventListener('click', () => {
                if (this.gameState === 'playing' && !this.isPaused && this.pointerLocked) {
                    this.shoot();
                }
            });

            document.getElementById('start-button').addEventListener('click', () => {
                this.audio.playClick();
                this.startGame();
            });

            document.getElementById('resume-button').addEventListener('click', () => {
                this.audio.playClick();
                this.resumeGame();
            });

            document.getElementById('menu-button').addEventListener('click', () => {
                this.audio.playClick();
                this.isPaused = false;
                this.gameState = 'menu';
                document.body.classList.remove('playing');
                document.getElementById('pause-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('radar').style.display = 'none';
                document.getElementById('menu-screen').style.display = 'flex';
            });

            document.getElementById('restart-button').addEventListener('click', () => {
                this.audio.playClick();
                document.getElementById('game-over-screen').style.display = 'none';
                this.startGame();
            });

            document.getElementById('menu-button-end').addEventListener('click', () => {
                this.audio.playClick();
                this.gameState = 'menu';
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('menu-screen').style.display = 'flex';
            });

            document.getElementById('settings-btn').addEventListener('click', () => {
                this.audio.playClick();
                document.getElementById('settings-screen').style.display = 'flex';
            });

            document.getElementById('close-settings').addEventListener('click', () => {
                this.audio.playClick();
                document.getElementById('settings-screen').style.display = 'none';
            });

            document.getElementById('volume-slider').addEventListener('input', e => {
                const value = parseInt(e.target.value) / 100;
                this.audio.setVolume(value);
                document.getElementById('volume-value').textContent = e.target.value + '%';
                localStorage.setItem('asteroidsVolume', value);
            });

            document.getElementById('sensitivity-slider').addEventListener('input', e => {
                const value = parseInt(e.target.value) / 100;
                this.sensitivity = value;
                document.getElementById('sensitivity-value').textContent = e.target.value + '%';
                localStorage.setItem('asteroidsSensitivity', value);
            });

            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    }

    const game = new AsteroidsGame();
    game.render(0);
</script>
<script src="../logo.js"></script>
</body>
</html>