<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Play Tower of Hanoi 3D - An interactive puzzle game with stunning 3D graphics, drag-and-drop controls, and visual hints. Move all disks to win in the optimal number of moves!">
    <meta name="keywords" content="Tower of Hanoi, 3D puzzle game, brain teaser, logic game, interactive puzzle, drag and drop game, mathematical puzzle, Tower of Hanoi online">
    <meta name="author" content="Claude Sonnet 4.5 prompted by Tobias MÃ¼ller">
    <meta property="og:title" content="Tower of Hanoi 3D - Interactive Puzzle Game">
    <meta property="og:description" content="Play Tower of Hanoi 3D - An interactive puzzle game with stunning 3D graphics, drag-and-drop controls, and visual hints. Move all disks to win in the optimal number of moves!">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_230.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/tower_of_hanoi.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Tower of Hanoi 3D - Interactive Puzzle Game">
    <meta name="twitter:description" content="Play Tower of Hanoi 3D - An interactive puzzle game with stunning 3D graphics, drag-and-drop controls, and visual hints. Move all disks to win in the optimal number of moves!">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_230.webp">
    <link rel="canonical" href="https://www.gptgames.dev/games/tower_of_hanoi.html">
    <title>Tower of Hanoi 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            overflow: hidden
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh
        }

        #canvas-container {
            flex: 1;
            position: relative
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%
        }

        #ui {
            background: #161b22;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            box-shadow: 0 -4px 30px rgba(0, 0, 0, .5);
            border-top: 1px solid #30363d
        }

        #controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        .btn {
            background: #238636;
            color: #fff;
            border: none;
            padding: 11px 22px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all .2s;
            box-shadow: 0 2px 8px rgba(35, 134, 54, .3)
        }

        .btn:hover {
            background: #2ea043;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(35, 134, 54, .4)
        }

        .btn:active {
            transform: translateY(0)
        }

        .btn:disabled {
            background: #21262d;
            color: #6e7681;
            cursor: not-allowed;
            box-shadow: none
        }

        .btn.secondary {
            background: #21262d;
            box-shadow: 0 2px 8px rgba(0, 0, 0, .2)
        }

        .btn.secondary:hover {
            background: #30363d
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 8px
        }

        #difficulty {
            background: #21262d;
            color: #e6edf3;
            border: 1px solid #30363d;
            padding: 11px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all .2s
        }

        #difficulty:hover {
            border-color: #58a6ff;
            background: #30363d
        }

        #info {
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px
        }

        .stat-label {
            font-size: 11px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 4px
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #58a6ff
        }

        .stat-value.optimal {
            color: #7ee787
        }

        .stat-value.time {
            color: #f778ba
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #161b22;
            padding: 50px 70px;
            border-radius: 16px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 2px solid #30363d;
            box-shadow: 0 16px 70px rgba(0, 0, 0, .8)
        }

        #message.show {
            display: block;
            animation: slideIn .4s cubic-bezier(.34, 1.56, .64, 1)
        }

        #message h2 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #58a6ff, #7ee787);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text
        }

        #message p {
            font-size: 16px;
            margin-bottom: 12px;
            color: #8b949e
        }

        #message .stats-grid {
            display: grid;
            grid-template-columns:repeat(3, 1fr);
            gap: 20px;
            margin: 25px 0;
            padding: 20px;
            background: #0d1117;
            border-radius: 8px
        }

        #message .stat-item {
            display: flex;
            flex-direction: column
        }

        #message .stat-item span:first-child {
            font-size: 12px;
            color: #8b949e;
            margin-bottom: 5px
        }

        #message .stat-item span:last-child {
            font-size: 24px;
            font-weight: 700;
            color: #58a6ff
        }

        #rating {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 20px 0;
            font-size: 32px
        }

        .star {
            color: #30363d;
            transition: all .3s
        }

        .star.filled {
            color: #f1e05a
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -45%) scale(.9)
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1)
            }
        }

        #instructions {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(22, 27, 34, .95);
            padding: 20px;
            border-radius: 12px;
            max-width: 320px;
            font-size: 13px;
            line-height: 1.7;
            border: 1px solid #30363d;
            backdrop-filter: blur(10px);
            transition: all .3s
        }

        #instructions.minimized {
            max-width: 60px;
            max-height: 60px;
            padding: 15px;
            overflow: hidden
        }

        #instructions h3 {
            margin-bottom: 12px;
            color: #58a6ff;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between
        }

        #instructions .toggle {
            cursor: pointer;
            background: none;
            border: none;
            color: #8b949e;
            font-size: 20px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all .2s
        }

        #instructions .toggle:hover {
            color: #58a6ff
        }

        #instructions ul {
            margin-left: 18px;
            margin-top: 10px
        }

        #instructions li {
            margin-bottom: 6px
        }

        #toast {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #da3633;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            display: none;
            font-size: 14px;
            animation: fadeIn .3s;
            border: 1px solid #f85149
        }

        #toast.show {
            display: block
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px)
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0)
            }
        }

        .tooltip {
            position: relative
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #161b22;
            color: #e6edf3;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity .2s;
            margin-bottom: 8px;
            border: 1px solid #30363d
        }

        .tooltip:hover::after {
            opacity: 1
        }
    </style>
</head>
<body>
<div id="container">
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="instructions">
            <h3>How to Play
                <button class="toggle" onclick="game.toggleInstructions()">âˆ’</button>
            </h3>
            <div class="content">
                <ul>
                    <li><strong>Click or drag</strong> a disk to select it</li>
                    <li>Only the <strong>top disk</strong> of each tower can be moved</li>
                    <li><strong>Drop on a peg</strong> to place the disk</li>
                    <li>Larger disks <strong>cannot</strong> go on smaller ones</li>
                    <li>Move all disks to the <strong>right peg</strong> to win!</li>
                </ul>
                <p style="margin-top:12px;color:#8b949e;font-size:12px">ðŸ’¡ Green = valid move, Red = invalid</p>
            </div>
        </div>
        <div id="toast"></div>
        <div id="message">
            <h2>ðŸŽ‰ Puzzle Solved!</h2>
            <div id="rating"></div>
            <div class="stats-grid">
                <div class="stat-item"><span>MOVES</span><span id="finalMoves">0</span></div>
                <div class="stat-item"><span>TIME</span><span id="finalTime">0:00</span></div>
                <div class="stat-item"><span>RATING</span><span id="efficiency">0%</span></div>
            </div>
            <p id="ratingText" style="color:#7ee787;font-size:18px;margin:15px 0"></p>
            <button class="btn" onclick="game.reset()">Play Again</button>
        </div>
    </div>
    <div id="ui">
        <div id="controls">
            <select id="difficulty">
                <option value="3">Easy (3 disks)</option>
                <option value="4">Medium (4 disks)</option>
                <option value="5" selected>Normal (5 disks)</option>
                <option value="6">Hard (6 disks)</option>
                <option value="7">Expert (7 disks)</option>
                <option value="8">Master (8 disks)</option>
            </select>
            <button class="btn" onclick="game.reset()">New Game</button>
            <button class="btn secondary" onclick="game.undo()" id="undoBtn" disabled data-tooltip="Undo last move">â†¶
            </button>
            <button class="btn secondary btn-icon" onclick="game.toggleSound()" id="soundBtn"
                    data-tooltip="Toggle sound">ðŸ”Š
            </button>
        </div>
        <div id="info">
            <div class="stat"><span class="stat-label">Moves</span><span class="stat-value" id="moves">0</span></div>
            <div class="stat"><span class="stat-label">Optimal</span><span class="stat-value optimal"
                                                                           id="optimal">31</span></div>
            <div class="stat"><span class="stat-label">Time</span><span class="stat-value time" id="timer">0:00</span>
            </div>
        </div>
    </div>
</div>
<script type="importmap">
    {"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}
</script>
<script type="module">
    import *as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    class AudioManager {
        constructor() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true
        }

        play(freq, duration, type = 'sine') {
            if (!this.enabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(.08, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(.01, this.ctx.currentTime + duration);
            osc.start(this.ctx.currentTime);
            osc.stop(this.ctx.currentTime + duration)
        }

        pickup() {
            this.play(523, .08)
        }

        place() {
            this.play(659, .12)
        }

        invalid() {
            this.play(180, .25, 'square')
        }

        win() {
            [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => this.play(f, .25), i * 120))
        }

        undo() {
            this.play(392, .1)
        }
    }

    class TowerOfHanoi {
        constructor() {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x0d1117);
            this.scene.fog = new THREE.Fog(0x0d1117, 15, 30);
            this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 1000);
            this.camera.position.set(0, 10, 14);
            this.renderer = new THREE.WebGLRenderer({canvas: document.getElementById('gameCanvas'), antialias: true});
            this.renderer.setSize(window.innerWidth, window.innerHeight - 80);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = .08;
            this.controls.maxPolarAngle = Math.PI / 2.1;
            this.controls.minDistance = 10;
            this.controls.maxDistance = 25;
            this.controls.target.set(0, 2, 0);
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            this.audio = new AudioManager();
            this.numDisks = 5;
            this.towers = [{disks: [], pos: new THREE.Vector3(-5, 0, 0)}, {
                disks: [],
                pos: new THREE.Vector3(0, 0, 0)
            }, {disks: [], pos: new THREE.Vector3(5, 0, 0)}];
            this.selectedDisk = null;
            this.dragging = false;
            this.dragStartPos = null;
            this.dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -3.5);
            this.hoveredObject = null;
            this.hoveredPeg = null;
            this.movesCount = 0;
            this.moveHistory = [];
            this.startTime = null;
            this.elapsedTime = 0;
            this.timerInterval = null;
            this.pulseTime = 0;
            this.diskColors = [0x58a6ff, 0x7ee787, 0xf778ba, 0xffa657, 0xbc8cff, 0xff7b72, 0x79c0ff, 0xffd580];
            this.diskMeshes = [];
            this.pegMeshes = [];
            this.dropZones = [];
            this.animating = false;
            this.instructionsMinimized = false;
            this.setupLights();
            this.createEnvironment();
            this.createPegs();
            this.reset();
            this.animate();
            window.addEventListener('resize', () => this.onResize());
            this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
            this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
            this.renderer.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
            document.getElementById('difficulty').addEventListener('change', () => this.reset())
        }

        setupLights() {
            const ambient = new THREE.AmbientLight(0x404866, .7);
            this.scene.add(ambient);
            const main = new THREE.DirectionalLight(0xffffff, 1.2);
            main.position.set(8, 12, 6);
            main.castShadow = true;
            main.shadow.mapSize.width = 2048;
            main.shadow.mapSize.height = 2048;
            main.shadow.camera.left = -15;
            main.shadow.camera.right = 15;
            main.shadow.camera.top = 15;
            main.shadow.camera.bottom = -15;
            this.scene.add(main);
            const fill = new THREE.DirectionalLight(0x7ea6ff, .5);
            fill.position.set(-6, 8, -6);
            this.scene.add(fill);
            const rim = new THREE.DirectionalLight(0xffffff, .3);
            rim.position.set(0, 5, -10);
            this.scene.add(rim)
        }

        createEnvironment() {
            const baseGeo = new THREE.BoxGeometry(16, .4, 6);
            const baseMat = new THREE.MeshStandardMaterial({color: 0x1a1f2e, roughness: .7, metalness: .3});
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = -.2;
            base.receiveShadow = true;
            this.scene.add(base);
            const gridHelper = new THREE.GridHelper(20, .5, 0x30363d, 0x21262d);
            gridHelper.position.y = -.01;
            this.scene.add(gridHelper)
        }

        createPegs() {
            this.pegMeshes.forEach(p => {
                this.scene.remove(p);
                if (p.glow) this.scene.remove(p.glow)
            });
            this.dropZones.forEach(d => this.scene.remove(d));
            this.pegMeshes = [];
            this.dropZones = [];
            const pegGeo = new THREE.CylinderGeometry(.12, .18, 6.5, 20);
            const pegMat = new THREE.MeshStandardMaterial({color: 0x484f58, roughness: .4, metalness: .6});
            const dropZoneGeo = new THREE.CylinderGeometry(1.2, 1.2, 6.5, 20);
            const dropZoneMat = new THREE.MeshBasicMaterial({visible: false});
            this.towers.forEach(tower => {
                const peg = new THREE.Mesh(pegGeo, pegMat);
                peg.position.copy(tower.pos);
                peg.position.y = 3.25;
                peg.castShadow = true;
                peg.receiveShadow = true;
                peg.userData.tower = tower;
                peg.userData.isPeg = true;
                const dropZone = new THREE.Mesh(dropZoneGeo, dropZoneMat);
                dropZone.position.copy(peg.position);
                dropZone.userData.tower = tower;
                dropZone.userData.isDropZone = true;
                this.dropZones.push(dropZone);
                this.scene.add(dropZone);
                const glowGeo = new THREE.CylinderGeometry(1.2, 1.2, 6.5, 20);
                const glowMat = new THREE.MeshBasicMaterial({color: 0x7ee787, transparent: true, opacity: 0});
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.copy(peg.position);
                peg.glow = glow;
                peg.dropZone = dropZone;
                this.scene.add(glow);
                this.pegMeshes.push(peg);
                this.scene.add(peg)
            })
        }

        createDisks() {
            this.diskMeshes.forEach(d => {
                this.scene.remove(d);
                if (d.glow) this.scene.remove(d.glow)
            });
            this.diskMeshes = [];
            this.towers.forEach(t => t.disks = []);
            const maxRadius = 2;
            const minRadius = .6;
            for (let i = 0; i < this.numDisks; i++) {
                const size = this.numDisks - i;
                const radius = minRadius + (maxRadius - minRadius) * (size / this.numDisks);
                const geo = new THREE.CylinderGeometry(radius, radius, .45, 32);
                const mat = new THREE.MeshStandardMaterial({
                    color: this.diskColors[i % this.diskColors.length],
                    roughness: .3,
                    metalness: .4
                });
                const disk = new THREE.Mesh(geo, mat);
                disk.castShadow = true;
                disk.receiveShadow = true;
                disk.userData.size = size;
                disk.userData.diskIndex = i;
                disk.userData.tower = this.towers[0];
                disk.userData.isDisk = true;
                disk.userData.radius = radius;
                const glowGeo = new THREE.CylinderGeometry(radius + .08, radius + .08, .55, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: this.diskColors[i % this.diskColors.length],
                    transparent: true,
                    opacity: 0
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                disk.glow = glow;
                this.scene.add(glow);
                this.diskMeshes.push(disk);
                this.towers[0].disks.push(disk);
                this.scene.add(disk)
            }
            this.updateDiskPositions()
        }

        updateDiskPositions(skipDisk = null) {
            this.towers.forEach(tower => {
                tower.disks.forEach((disk, index) => {
                    if (disk !== skipDisk) {
                        disk.position.x = tower.pos.x;
                        disk.position.y = .225 + index * .45;
                        disk.position.z = tower.pos.z;
                        if (disk.glow) {
                            disk.glow.position.copy(disk.position)
                        }
                    }
                })
            })
        }

        canPlaceDiskOnTower(disk, tower) {
            if (tower.disks.length === 0) return true;
            const topDisk = tower.disks[tower.disks.length - 1];
            return disk.userData.size < topDisk.userData.size
        }

        highlightLegalMoves(disk) {
            this.clearHighlights();
            disk.glow.material.opacity = .7;
            disk.glow.material.color.setHex(0xffffff);
            this.pegMeshes.forEach(peg => {
                const tower = peg.userData.tower;
                if (tower === disk.userData.tower) return;
                const canPlace = this.canPlaceDiskOnTower(disk, tower);
                peg.glow.material.opacity = .4;
                peg.glow.material.color.setHex(canPlace ? 0x7ee787 : 0xff7b72);
                peg.userData.canPlace = canPlace
            })
        }

        clearHighlights() {
            this.pegMeshes.forEach(peg => {
                peg.glow.material.opacity = 0;
                peg.userData.canPlace = false
            });
            this.diskMeshes.forEach(disk => {
                disk.glow.material.opacity = 0
            });
            this.hoveredPeg = null
        }

        onMouseDown(event) {
            if (this.animating) return;
            const rect = this.renderer.domElement.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const diskIntersects = this.raycaster.intersectObjects(this.diskMeshes);
            if (diskIntersects.length > 0) {
                const disk = diskIntersects[0].object;
                const tower = disk.userData.tower;
                if (tower.disks[tower.disks.length - 1] === disk) {
                    this.selectedDisk = disk;
                    this.dragging = true;
                    this.dragStartPos = disk.position.clone();
                    this.controls.enabled = false;
                    this.highlightLegalMoves(disk);
                    this.audio.pickup();
                    if (!this.startTime) {
                        this.startTime = Date.now();
                        this.startTimer()
                    }
                    this.renderer.domElement.style.cursor = 'grabbing'
                }
            }
        }

        onMouseMove(event) {
            const rect = this.renderer.domElement.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            if (this.dragging && this.selectedDisk) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersectPoint = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(this.dragPlane, intersectPoint);
                if (intersectPoint) {
                    this.selectedDisk.position.x = intersectPoint.x;
                    this.selectedDisk.position.y = Math.max(5, Math.min(8, intersectPoint.y + 1.5));
                    this.selectedDisk.position.z = intersectPoint.z;
                    this.selectedDisk.glow.position.copy(this.selectedDisk.position)
                }
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const dropZoneIntersects = this.raycaster.intersectObjects(this.dropZones);
                const prevHoveredPeg = this.hoveredPeg;
                this.hoveredPeg = null;
                if (dropZoneIntersects.length > 0) {
                    const dropZone = dropZoneIntersects[0].object;
                    const tower = dropZone.userData.tower;
                    if (tower !== this.selectedDisk.userData.tower) {
                        const peg = this.pegMeshes.find(p => p.userData.tower === tower);
                        if (peg) {
                            this.hoveredPeg = peg;
                            const canPlace = this.canPlaceDiskOnTower(this.selectedDisk, tower);
                            peg.glow.material.opacity = .7;
                            peg.glow.material.color.setHex(canPlace ? 0x7ee787 : 0xff7b72)
                        }
                    }
                }
                if (prevHoveredPeg && prevHoveredPeg !== this.hoveredPeg) {
                    const canPlace = prevHoveredPeg.userData.canPlace;
                    prevHoveredPeg.glow.material.opacity = .4;
                    prevHoveredPeg.glow.material.color.setHex(canPlace ? 0x7ee787 : 0xff7b72)
                }
            } else if (!this.animating && !this.dragging) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const diskIntersects = this.raycaster.intersectObjects(this.diskMeshes);
                if (this.hoveredObject) {
                    if (this.hoveredObject.glow) {
                        this.hoveredObject.glow.material.opacity = 0
                    }
                    this.hoveredObject = null
                }
                if (diskIntersects.length > 0) {
                    const disk = diskIntersects[0].object;
                    const tower = disk.userData.tower;
                    if (tower.disks[tower.disks.length - 1] === disk) {
                        disk.glow.material.opacity = .3;
                        disk.glow.material.color.setHex(0xffffff);
                        this.hoveredObject = disk;
                        this.renderer.domElement.style.cursor = 'grab'
                    } else {
                        this.renderer.domElement.style.cursor = 'not-allowed'
                    }
                } else {
                    this.renderer.domElement.style.cursor = 'default'
                }
            }
        }

        onMouseUp(event) {
            if (!this.dragging || !this.selectedDisk) return;
            this.dragging = false;
            this.controls.enabled = true;
            this.renderer.domElement.style.cursor = 'default';
            const rect = this.renderer.domElement.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const dropZoneIntersects = this.raycaster.intersectObjects(this.dropZones);
            let placed = false;
            if (dropZoneIntersects.length > 0) {
                const targetTower = dropZoneIntersects[0].object.userData.tower;
                if (targetTower !== this.selectedDisk.userData.tower && this.canPlaceDiskOnTower(this.selectedDisk, targetTower)) {
                    this.moveDiskToTower(targetTower);
                    placed = true
                } else if (!this.canPlaceDiskOnTower(this.selectedDisk, targetTower)) {
                    this.audio.invalid()
                }
            }
            if (!placed) {
                this.clearHighlights();
                this.animateReturn()
            }
        }

        animateReturn() {
            const disk = this.selectedDisk;
            const startPos = disk.position.clone();
            const endPos = this.dragStartPos.clone();
            let progress = 0;
            const duration = 15;
            const animate = () => {
                progress++;
                const t = progress / duration;
                if (t <= 1) {
                    disk.position.lerpVectors(startPos, endPos, this.easeOutCubic(t));
                    disk.glow.position.copy(disk.position)
                }
                if (progress >= duration) {
                    disk.position.copy(endPos);
                    disk.glow.position.copy(endPos);
                    this.clearHighlights();
                    this.selectedDisk = null;
                    this.dragStartPos = null
                } else {
                    requestAnimationFrame(animate)
                }
            };
            animate()
        }

        moveDiskToTower(targetTower) {
            const disk = this.selectedDisk;
            const sourceTower = disk.userData.tower;
            this.animating = true;
            const moveData = {disk: disk, from: sourceTower, to: targetTower, fromIndex: sourceTower.disks.length - 1};
            this.moveHistory.push(moveData);
            sourceTower.disks.pop();
            targetTower.disks.push(disk);
            disk.userData.tower = targetTower;
            this.movesCount++;
            document.getElementById('moves').textContent = this.movesCount;
            this.updateUndoButton();
            const startPos = disk.position.clone();
            const arc = 7;
            const midPos = new THREE.Vector3((startPos.x + targetTower.pos.x) / 2, arc, (startPos.z + targetTower.pos.z) / 2);
            const endPos = new THREE.Vector3(targetTower.pos.x, .225 + (targetTower.disks.length - 1) * .45, targetTower.pos.z);
            let progress = 0;
            const duration = 30;
            const animate = () => {
                progress++;
                const t = progress / duration;
                const eased = this.easeInOutCubic(t);
                if (t <= 1) {
                    const t1 = eased * 2;
                    if (t1 <= 1) {
                        disk.position.x = startPos.x + (midPos.x - startPos.x) * t1;
                        disk.position.y = startPos.y + (midPos.y - startPos.y) * this.easeOutQuad(t1);
                        disk.position.z = startPos.z + (midPos.z - startPos.z) * t1
                    } else {
                        const t2 = t1 - 1;
                        disk.position.x = midPos.x + (endPos.x - midPos.x) * t2;
                        disk.position.y = midPos.y + (endPos.y - midPos.y) * this.easeInQuad(t2);
                        disk.position.z = midPos.z + (endPos.z - midPos.z) * t2
                    }
                    disk.glow.position.copy(disk.position);
                    disk.rotation.y += .04
                }
                if (progress >= duration) {
                    disk.position.copy(endPos);
                    disk.glow.position.copy(endPos);
                    this.clearHighlights();
                    this.selectedDisk = null;
                    this.dragStartPos = null;
                    this.animating = false;
                    this.audio.place();
                    this.updateDiskPositions();
                    this.checkWin()
                } else {
                    requestAnimationFrame(animate)
                }
            };
            animate()
        }

        undo() {
            if (this.moveHistory.length === 0 || this.animating) return;
            const lastMove = this.moveHistory.pop();
            const disk = lastMove.disk;
            lastMove.to.disks.pop();
            lastMove.from.disks.splice(lastMove.fromIndex, 0, disk);
            disk.userData.tower = lastMove.from;
            this.movesCount--;
            document.getElementById('moves').textContent = this.movesCount;
            this.updateDiskPositions();
            this.updateUndoButton();
            this.audio.undo()
        }

        updateUndoButton() {
            document.getElementById('undoBtn').disabled = this.moveHistory.length === 0
        }

        showToast(text) {
            const toast = document.getElementById('toast');
            toast.textContent = text;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500)
        }

        easeInOutCubic(t) {
            return t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        }

        easeOutQuad(t) {
            return 1 - (1 - t) * (1 - t)
        }

        easeInQuad(t) {
            return t * t
        }

        easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3)
        }

        checkWin() {
            if (this.towers[2].disks.length === this.numDisks) {
                this.stopTimer();
                setTimeout(() => {
                    const optimal = Math.pow(2, this.numDisks) - 1;
                    const efficiency = Math.round((optimal / this.movesCount) * 100);
                    const stars = efficiency >= 100 ? 3 : efficiency >= 80 ? 2 : 1;
                    document.getElementById('finalMoves').textContent = this.movesCount;
                    document.getElementById('finalTime').textContent = this.formatTime(this.elapsedTime);
                    document.getElementById('efficiency').textContent = efficiency + '%';
                    const rating = document.getElementById('rating');
                    rating.innerHTML = '';
                    for (let i = 0; i < 3; i++) {
                        const star = document.createElement('span');
                        star.className = 'star' + (i < stars ? ' filled' : '');
                        star.textContent = 'â˜…';
                        rating.appendChild(star)
                    }
                    const ratingText = stars === 3 ? 'Perfect! Optimal solution!' : stars === 2 ? 'Great job!' : 'Good effort!';
                    document.getElementById('ratingText').textContent = ratingText;
                    document.getElementById('message').classList.add('show');
                    this.audio.win()
                }, 500)
            }
        }

        startTimer() {
            this.timerInterval = setInterval(() => {
                this.elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('timer').textContent = this.formatTime(this.elapsedTime)
            }, 1000)
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null
            }
        }

        formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`
        }

        toggleSound() {
            this.audio.enabled = !this.audio.enabled;
            document.getElementById('soundBtn').textContent = this.audio.enabled ? 'ðŸ”Š' : 'ðŸ”‡'
        }

        toggleInstructions() {
            this.instructionsMinimized = !this.instructionsMinimized;
            const inst = document.getElementById('instructions');
            const btn = inst.querySelector('.toggle');
            inst.classList.toggle('minimized');
            btn.textContent = this.instructionsMinimized ? '+' : 'âˆ’'
        }

        reset() {
            this.numDisks = parseInt(document.getElementById('difficulty').value);
            this.movesCount = 0;
            this.moveHistory = [];
            this.selectedDisk = null;
            this.dragging = false;
            this.dragStartPos = null;
            this.hoveredPeg = null;
            this.animating = false;
            this.startTime = null;
            this.elapsedTime = 0;
            this.stopTimer();
            this.clearHighlights();
            this.controls.enabled = true;
            document.getElementById('moves').textContent = '0';
            document.getElementById('timer').textContent = '0:00';
            document.getElementById('optimal').textContent = Math.pow(2, this.numDisks) - 1;
            document.getElementById('message').classList.remove('show');
            this.updateUndoButton();
            this.createDisks()
        }

        onResize() {
            this.camera.aspect = window.innerWidth / (window.innerHeight - 80);
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight - 80)
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            this.pulseTime += .05;
            if (this.dragging && this.pegMeshes) {
                this.pegMeshes.forEach(peg => {
                    if (peg.glow.material.opacity > 0 && peg !== this.hoveredPeg) {
                        const basePulse = .4;
                        const pulse = basePulse + Math.sin(this.pulseTime) * 0.08;
                        peg.glow.material.opacity = pulse
                    }
                })
            }
            this.controls.update();
            this.renderer.render(this.scene, this.camera)
        }
    }

    const game = new TowerOfHanoi();
    window.game = game;
</script>
<script src="../logo.js"></script>
</body>
</html>