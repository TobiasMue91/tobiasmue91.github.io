<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Living RPS - Enhanced Ecosystem Simulation</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-rock: #ef4444;
            --accent-paper: #3b82f6;
            --accent-scissors: #22c55e;
            --border-color: #475569;
        }

        .light-theme {
            --bg-primary: #f1f5f9;
            --bg-secondary: #e2e8f0;
            --bg-tertiary: #cbd5e1;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --border-color: #94a3b8;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .arena-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .canvas-wrapper {
            position: relative;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            border-radius: 50%;
            cursor: crosshair;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }

        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: transform 0.3s, width 0.3s;
        }

        .sidebar.collapsed {
            width: 0;
            transform: translateX(100%);
        }

        .panel {
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .panel-header:hover {
            background: var(--border-color);
        }

        .panel-header h3 {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-content {
            padding: 16px;
            display: none;
        }

        .panel.open .panel-content {
            display: block;
        }

        .panel-toggle {
            transition: transform 0.2s;
        }

        .panel.open .panel-toggle {
            transform: rotate(180deg);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: var(--bg-primary);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card .emoji {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .stat-card .value {
            font-size: 20px;
            font-weight: 700;
        }

        .stat-card .label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .stat-card.rock { border-top: 3px solid var(--accent-rock); }
        .stat-card.paper { border-top: 3px solid var(--accent-paper); }
        .stat-card.scissors { border-top: 3px solid var(--accent-scissors); }

        .chart-container {
            height: 120px;
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
        }

        #populationChart {
            width: 100%;
            height: 100%;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .momentum-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .momentum-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .control-value {
            color: var(--text-secondary);
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-primary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .select-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .select-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .select-btn:hover {
            border-color: #3b82f6;
        }

        .select-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .entity-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .entity-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .entity-btn:hover {
            border-color: var(--text-secondary);
        }

        .entity-btn.active.rock { border-color: var(--accent-rock); background: rgba(239, 68, 68, 0.2); }
        .entity-btn.active.paper { border-color: var(--accent-paper); background: rgba(59, 130, 246, 0.2); }
        .entity-btn.active.scissors { border-color: var(--accent-scissors); background: rgba(34, 197, 94, 0.2); }

        .speed-controls {
            display: flex;
            gap: 4px;
        }

        .speed-btn {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .speed-btn:hover {
            border-color: #3b82f6;
        }

        .speed-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .keyboard-hints {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
        }

        .hint-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .hint-key {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        .round-info {
            background: var(--bg-primary);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .round-score {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 8px;
        }

        .score-item {
            text-align: center;
        }

        .score-value {
            font-size: 24px;
            font-weight: 700;
        }

        .victory-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            border-radius: 50%;
        }

        .victory-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .victory-emoji {
            font-size: 80px;
            animation: victoryBounce 0.5s ease-out;
        }

        .victory-text {
            font-size: 24px;
            font-weight: 700;
            margin-top: 10px;
            text-transform: uppercase;
        }

        @keyframes victoryBounce {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .toggle-sidebar-btn {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-group label {
            font-size: 13px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border-color);
                max-height: 50vh;
            }

            .sidebar.collapsed {
                transform: translateY(100%);
            }

            .arena-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>Living RPS Ecosystem</h1>
            <div class="header-controls">
                <button class="btn btn-icon btn-secondary" id="themeToggle" title="Toggle theme">üåô</button>
                <button class="btn btn-icon btn-secondary" id="fullscreenToggle" title="Fullscreen">‚õ∂</button>
                <button class="btn btn-icon btn-secondary" id="sidebarToggle" title="Toggle panel">‚ò∞</button>
            </div>
        </header>

        <main class="main-content">
            <div class="arena-container">
                <div class="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                    <div class="victory-overlay" id="victoryOverlay">
                        <div class="victory-emoji" id="victoryEmoji">üóø</div>
                        <div class="victory-text" id="victoryText">Rock Wins!</div>
                    </div>
                </div>

                <div class="game-controls">
                    <button class="btn btn-success" id="startBtn">‚ñ∂ Start</button>
                    <button class="btn btn-danger" id="stopBtn" disabled>‚è∏ Pause</button>
                    <button class="btn btn-primary" id="resetBtn">‚Ü∫ Reset</button>
                    <button class="btn btn-warning" id="extinctionBtn" title="Remove 50% of dominant type">‚ò† Extinction</button>
                </div>
            </div>

            <aside class="sidebar" id="sidebar">
                <div class="panel open" id="statsPanel">
                    <div class="panel-header">
                        <h3>Statistics</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="stats-grid">
                            <div class="stat-card rock">
                                <div class="emoji">üóø</div>
                                <div class="value" id="rockCount">0</div>
                                <div class="label">Rock</div>
                            </div>
                            <div class="stat-card paper">
                                <div class="emoji">üìÑ</div>
                                <div class="value" id="paperCount">0</div>
                                <div class="label">Paper</div>
                            </div>
                            <div class="stat-card scissors">
                                <div class="emoji">‚úÇÔ∏è</div>
                                <div class="value" id="scissorsCount">0</div>
                                <div class="label">Scissors</div>
                            </div>
                        </div>

                        <div class="chart-container">
                            <canvas id="populationChart"></canvas>
                        </div>

                        <div class="info-row">
                            <span class="info-label">Generation</span>
                            <span id="generationCount">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Transformations</span>
                            <span id="transformCount">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Momentum</span>
                            <div class="momentum-indicator">
                                <span class="momentum-dot" id="momentumDot"></span>
                                <span id="momentumType">-</span>
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Avg Victory Time</span>
                            <span id="avgVictoryTime">-</span>
                        </div>
                    </div>
                </div>

                <div class="panel open" id="controlsPanel">
                    <div class="panel-header">
                        <h3>Controls</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="control-group">
                            <div class="control-label">
                                <span>Speed</span>
                                <div class="speed-controls">
                                    <button class="speed-btn" data-speed="0.25">0.25x</button>
                                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                                    <button class="speed-btn active" data-speed="1">1x</button>
                                    <button class="speed-btn" data-speed="2">2x</button>
                                    <button class="speed-btn" data-speed="4">4x</button>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Entity Count</span>
                                <span class="control-value" id="entityCountValue">150</span>
                            </div>
                            <input type="range" id="entityCount" min="30" max="600" value="150">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Entity Speed</span>
                                <span class="control-value" id="entitySpeedValue">3</span>
                            </div>
                            <input type="range" id="entitySpeed" min="1" max="10" value="3">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Arena Size</span>
                                <span class="control-value" id="arenaSizeValue">500</span>
                            </div>
                            <input type="range" id="arenaSize" min="300" max="800" value="500">
                        </div>
                    </div>
                </div>

                <div class="panel" id="spawnPanel">
                    <div class="panel-header">
                        <h3>Click to Spawn</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="entity-selector">
                            <button class="entity-btn rock active" data-type="rock">üóø</button>
                            <button class="entity-btn paper" data-type="paper">üìÑ</button>
                            <button class="entity-btn scissors" data-type="scissors">‚úÇÔ∏è</button>
                        </div>
                        <p style="font-size: 12px; color: var(--text-secondary);">Click on the arena to spawn entities of the selected type</p>
                    </div>
                </div>

                <div class="panel" id="modesPanel">
                    <div class="panel-header">
                        <h3>Game Mode</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="select-group">
                            <button class="select-btn active" data-mode="classic">Classic</button>
                            <button class="select-btn" data-mode="battleRoyale">Battle Royale</button>
                            <button class="select-btn" data-mode="infection">Infection</button>
                            <button class="select-btn" data-mode="balanced">Balanced</button>
                            <button class="select-btn" data-mode="tournament">Tournament</button>
                        </div>

                        <div class="round-info" id="tournamentInfo" style="display: none; margin-top: 12px;">
                            <div>Tournament Mode</div>
                            <div class="round-score">
                                <div class="score-item">
                                    <div class="score-value" id="tournamentRound">1</div>
                                    <div class="label">Round</div>
                                </div>
                                <div class="score-item">
                                    <div class="score-value" id="tournamentWins">0</div>
                                    <div class="label">Wins</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="formationPanel">
                    <div class="panel-header">
                        <h3>Starting Formation</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="select-group">
                            <button class="select-btn active" data-formation="random">Random</button>
                            <button class="select-btn" data-formation="clustered">Clustered</button>
                            <button class="select-btn" data-formation="ring">Ring</button>
                            <button class="select-btn" data-formation="corners">Corners</button>
                        </div>
                    </div>
                </div>

                <div class="panel" id="behaviorPanel">
                    <div class="panel-header">
                        <h3>Behavior Settings</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="control-group">
                            <div class="control-label">
                                <span>Cohesion</span>
                                <span class="control-value" id="cohesionValue">0.5</span>
                            </div>
                            <input type="range" id="cohesion" min="0" max="100" value="50">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                <span>Separation</span>
                                <span class="control-value" id="separationValue">0.5</span>
                            </div>
                            <input type="range" id="separation" min="0" max="100" value="50">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                <span>Alignment</span>
                                <span class="control-value" id="alignmentValue">0.5</span>
                            </div>
                            <input type="range" id="alignment" min="0" max="100" value="50">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                <span>Fear Radius</span>
                                <span class="control-value" id="fearRadiusValue">80</span>
                            </div>
                            <input type="range" id="fearRadius" min="30" max="150" value="80">
                        </div>
                    </div>
                </div>

                <div class="panel" id="visualsPanel">
                    <div class="panel-header">
                        <h3>Visual Effects</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="checkbox-group">
                            <input type="checkbox" id="showTrails">
                            <label for="showTrails">Motion trails</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showParticles">
                            <label for="showParticles">Particle effects</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showGlow">
                            <label for="showGlow">Entity glow</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showGrid">
                            <label for="showGrid">Debug grid</label>
                        </div>
                    </div>
                </div>

                <div class="panel" id="shortcutsPanel">
                    <div class="panel-header">
                        <h3>Keyboard Shortcuts</h3>
                        <span class="panel-toggle">‚ñº</span>
                    </div>
                    <div class="panel-content">
                        <div class="keyboard-hints">
                            <div class="hint-row">
                                <span>Play/Pause</span>
                                <span class="hint-key">Space</span>
                            </div>
                            <div class="hint-row">
                                <span>Reset</span>
                                <span class="hint-key">R</span>
                            </div>
                            <div class="hint-row">
                                <span>Speed 0.25x</span>
                                <span class="hint-key">1</span>
                            </div>
                            <div class="hint-row">
                                <span>Speed 0.5x</span>
                                <span class="hint-key">2</span>
                            </div>
                            <div class="hint-row">
                                <span>Speed 1x</span>
                                <span class="hint-key">3</span>
                            </div>
                            <div class="hint-row">
                                <span>Speed 2x</span>
                                <span class="hint-key">4</span>
                            </div>
                            <div class="hint-row">
                                <span>Speed 4x</span>
                                <span class="hint-key">5</span>
                            </div>
                            <div class="hint-row">
                                <span>Extinction</span>
                                <span class="hint-key">E</span>
                            </div>
                            <div class="hint-row">
                                <span>Toggle Panel</span>
                                <span class="hint-key">Tab</span>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </main>
    </div>

<script>
/**
 * Living RPS - Enhanced Ecosystem Simulation
 * A high-performance Rock-Paper-Scissors ecosystem with Canvas rendering,
 * spatial partitioning, and advanced behavioral simulation.
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
    // Entity settings
    entityCount: 150,
    entitySize: 18,
    entitySpeed: 3,

    // Arena settings
    arenaSize: 500,

    // Physics settings
    fixedTimestep: 1000 / 60,
    maxDeltaTime: 100,

    // Behavior settings
    cohesionWeight: 0.5,
    separationWeight: 0.5,
    alignmentWeight: 0.5,
    huntStrength: 0.006,
    fleeStrength: 0.004,
    fearRadius: 80,
    flockRadius: 60,

    // Visual settings (disabled by default for performance)
    showTrails: false,
    showParticles: false,
    showGlow: false,
    showGrid: false,
    trailLength: 8,

    // Game settings
    gameMode: 'classic',
    formation: 'random',
    timeScale: 1,

    // Spatial grid
    cellSize: 50,

    // Colors
    colors: {
        rock: { main: '#ef4444', glow: 'rgba(239, 68, 68, 0.4)', trail: 'rgba(239, 68, 68, 0.3)' },
        paper: { main: '#3b82f6', glow: 'rgba(59, 130, 246, 0.4)', trail: 'rgba(59, 130, 246, 0.3)' },
        scissors: { main: '#22c55e', glow: 'rgba(34, 197, 94, 0.4)', trail: 'rgba(34, 197, 94, 0.3)' }
    },

    // Emojis
    emojis: {
        rock: 'üóø',
        paper: 'üìÑ',
        scissors: '‚úÇÔ∏è'
    }
};

// ============================================================================
// EVENT EMITTER
// ============================================================================

/**
 * Simple event emitter for game state changes
 */
class EventEmitter {
    constructor() {
        this.events = {};
    }

    /**
     * Subscribe to an event
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }

    /**
     * Unsubscribe from an event
     * @param {string} event - Event name
     * @param {Function} callback - Callback to remove
     */
    off(event, callback) {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter(cb => cb !== callback);
    }

    /**
     * Emit an event
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data) {
        if (!this.events[event]) return;
        this.events[event].forEach(callback => callback(data));
    }
}

// ============================================================================
// SPATIAL HASH GRID
// ============================================================================

/**
 * Spatial hash grid for efficient collision detection
 * Reduces collision checks from O(n¬≤) to approximately O(n)
 */
class SpatialHashGrid {
    /**
     * @param {number} cellSize - Size of each grid cell
     * @param {number} width - Grid width
     * @param {number} height - Grid height
     */
    constructor(cellSize, width, height) {
        this.cellSize = cellSize;
        this.width = width;
        this.height = height;
        this.cells = new Map();
    }

    /**
     * Get cell key for a position
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @returns {string} Cell key
     */
    getCellKey(x, y) {
        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);
        return `${cellX},${cellY}`;
    }

    /**
     * Clear the grid
     */
    clear() {
        this.cells.clear();
    }

    /**
     * Insert an entity into the grid
     * @param {Entity} entity - Entity to insert
     */
    insert(entity) {
        const key = this.getCellKey(entity.x, entity.y);
        if (!this.cells.has(key)) {
            this.cells.set(key, []);
        }
        this.cells.get(key).push(entity);
    }

    /**
     * Get all entities near a position
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} radius - Search radius
     * @returns {Entity[]} Nearby entities
     */
    getNearby(x, y, radius) {
        const nearby = [];
        const minCellX = Math.floor((x - radius) / this.cellSize);
        const maxCellX = Math.floor((x + radius) / this.cellSize);
        const minCellY = Math.floor((y - radius) / this.cellSize);
        const maxCellY = Math.floor((y + radius) / this.cellSize);

        for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
            for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                const key = `${cellX},${cellY}`;
                const cell = this.cells.get(key);
                if (cell) {
                    nearby.push(...cell);
                }
            }
        }

        return nearby;
    }

    /**
     * Update grid size
     * @param {number} width - New width
     * @param {number} height - New height
     */
    resize(width, height) {
        this.width = width;
        this.height = height;
    }
}

// ============================================================================
// PARTICLE SYSTEM
// ============================================================================

/**
 * Particle for visual effects
 */
class Particle {
    constructor(x, y, color, vx, vy) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.02;
        this.size = 3 + Math.random() * 4;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.life -= this.decay;
        return this.life > 0;
    }
}

/**
 * Particle system manager
 */
class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    /**
     * Create a burst of particles
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} color - Particle color
     * @param {number} count - Number of particles
     */
    burst(x, y, color, count = 12) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
            const speed = 2 + Math.random() * 3;
            this.particles.push(new Particle(
                x, y, color,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
            ));
        }
    }

    /**
     * Update all particles
     */
    update() {
        this.particles = this.particles.filter(p => p.update());
    }

    /**
     * Render particles
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     */
    render(ctx) {
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    /**
     * Clear all particles
     */
    clear() {
        this.particles = [];
    }
}

// ============================================================================
// ENTITY
// ============================================================================

/**
 * Entity in the RPS ecosystem
 */
class Entity {
    /**
     * @param {string} type - Entity type (rock, paper, scissors)
     * @param {number} x - Initial X position
     * @param {number} y - Initial Y position
     */
    constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * CONFIG.entitySpeed;
        this.vy = (Math.random() - 0.5) * CONFIG.entitySpeed;
        this.ax = 0;
        this.ay = 0;

        // Previous position for interpolation
        this.prevX = x;
        this.prevY = y;

        // Trail history
        this.trail = [];

        // Personality traits (adds variety to behavior)
        this.aggressiveness = 0.5 + Math.random() * 0.5;
        this.fearfulness = 0.5 + Math.random() * 0.5;
        this.stamina = 1;
        this.maxStamina = 1;
        this.staminaRecovery = 0.005;

        // Pulse animation
        this.pulsePhase = Math.random() * Math.PI * 2;

        // Transformation effect
        this.transformScale = 1;
        this.justTransformed = false;
    }

    /**
     * Get prey type for this entity
     * @returns {string} Prey type
     */
    getPrey() {
        const preyMap = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
        return preyMap[this.type];
    }

    /**
     * Get predator type for this entity
     * @returns {string} Predator type
     */
    getPredator() {
        const predatorMap = { rock: 'paper', paper: 'scissors', scissors: 'rock' };
        return predatorMap[this.type];
    }

    /**
     * Transform to a new type
     * @param {string} newType - New entity type
     */
    transform(newType) {
        this.type = newType;
        this.transformScale = 1.5;
        this.justTransformed = true;
        this.stamina = 0.3; // Stamina penalty after transformation
    }

    /**
     * Apply flocking behavior with nearby same-type entities
     * @param {Entity[]} nearby - Nearby entities
     */
    flock(nearby) {
        let avgVx = 0, avgVy = 0;
        let centerX = 0, centerY = 0;
        let separationX = 0, separationY = 0;
        let count = 0;

        for (const other of nearby) {
            if (other === this || other.type !== this.type) continue;

            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);

            if (dist < CONFIG.flockRadius && dist > 0) {
                // Alignment
                avgVx += other.vx;
                avgVy += other.vy;

                // Cohesion
                centerX += other.x;
                centerY += other.y;

                // Separation
                const separationDist = CONFIG.entitySize * 2;
                if (dist < separationDist) {
                    separationX -= dx / dist;
                    separationY -= dy / dist;
                }

                count++;
            }
        }

        if (count > 0) {
            // Alignment force
            this.ax += (avgVx / count - this.vx) * 0.05 * CONFIG.alignmentWeight;
            this.ay += (avgVy / count - this.vy) * 0.05 * CONFIG.alignmentWeight;

            // Cohesion force
            this.ax += (centerX / count - this.x) * 0.001 * CONFIG.cohesionWeight;
            this.ay += (centerY / count - this.y) * 0.001 * CONFIG.cohesionWeight;

            // Separation force
            this.ax += separationX * 0.08 * CONFIG.separationWeight;
            this.ay += separationY * 0.08 * CONFIG.separationWeight;
        }
    }

    /**
     * Hunt prey and flee from predators
     * @param {Entity[]} nearby - Nearby entities
     * @returns {Entity|null} Prey that was caught
     */
    interact(nearby) {
        const preyType = this.getPrey();
        const predatorType = this.getPredator();
        let nearestPrey = null;
        let nearestPredator = null;
        let minPreyDist = Infinity;
        let minPredatorDist = Infinity;
        let caughtPrey = null;

        for (const other of nearby) {
            if (other === this) continue;

            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);

            // Check for transformation (collision)
            if (dist < CONFIG.entitySize && other.type === preyType) {
                caughtPrey = other;
            }

            // Find nearest prey
            if (other.type === preyType && dist < CONFIG.fearRadius * 1.5) {
                if (dist < minPreyDist) {
                    minPreyDist = dist;
                    nearestPrey = other;
                }
            }

            // Find nearest predator
            if (other.type === predatorType && dist < CONFIG.fearRadius) {
                if (dist < minPredatorDist) {
                    minPredatorDist = dist;
                    nearestPredator = other;
                }
            }
        }

        // Hunt behavior - modified by aggressiveness and stamina
        if (nearestPrey && this.stamina > 0.2) {
            const huntForce = CONFIG.huntStrength * this.aggressiveness * this.stamina;
            this.ax += (nearestPrey.x - this.x) * huntForce;
            this.ay += (nearestPrey.y - this.y) * huntForce;
        }

        // Flee behavior - modified by fearfulness
        if (nearestPredator) {
            // Fear increases as predator gets closer
            const fearMultiplier = 1 + (CONFIG.fearRadius - minPredatorDist) / CONFIG.fearRadius;
            const fleeForce = CONFIG.fleeStrength * this.fearfulness * fearMultiplier;
            this.ax -= (nearestPredator.x - this.x) * fleeForce;
            this.ay -= (nearestPredator.y - this.y) * fleeForce;
        }

        return caughtPrey;
    }

    /**
     * Update entity physics
     * @param {number} dt - Delta time
     * @param {number} centerX - Arena center X
     * @param {number} centerY - Arena center Y
     * @param {number} radius - Arena radius
     */
    update(dt, centerX, centerY, radius) {
        // Store previous position for interpolation
        this.prevX = this.x;
        this.prevY = this.y;

        // Update trail
        if (CONFIG.showTrails) {
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > CONFIG.trailLength) {
                this.trail.shift();
            }
        }

        // Recover stamina
        this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRecovery);

        // Apply acceleration
        this.vx += this.ax;
        this.vy += this.ay;

        // Add random movement
        this.vx += (Math.random() - 0.5) * 0.15;
        this.vy += (Math.random() - 0.5) * 0.15;

        // Center attraction (keeps entities from clustering at edges)
        const dx = centerX - this.x;
        const dy = centerY - this.y;
        const distFromCenter = Math.sqrt(dx * dx + dy * dy);
        const centerForce = 0.00002 * distFromCenter;
        this.vx += dx * centerForce;
        this.vy += dy * centerForce;

        // Speed limit
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = CONFIG.entitySpeed * this.stamina;
        if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }

        // Apply velocity
        const timeScale = dt / 16.67; // Normalize to 60fps
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;

        // Circular boundary collision
        const boundaryRadius = radius - CONFIG.entitySize / 2;
        if (distFromCenter > boundaryRadius) {
            const angle = Math.atan2(this.y - centerY, this.x - centerX);
            this.x = centerX + boundaryRadius * Math.cos(angle);
            this.y = centerY + boundaryRadius * Math.sin(angle);

            // Reflect velocity
            const normalX = Math.cos(angle);
            const normalY = Math.sin(angle);
            const dot = this.vx * normalX + this.vy * normalY;
            this.vx -= 2 * dot * normalX;
            this.vy -= 2 * dot * normalY;

            // Add randomness to prevent orbiting
            this.vx += (Math.random() - 0.5) * 0.5;
            this.vy += (Math.random() - 0.5) * 0.5;
        }

        // Reset acceleration
        this.ax = 0;
        this.ay = 0;

        // Update transform scale (for animation)
        if (this.transformScale > 1) {
            this.transformScale = Math.max(1, this.transformScale - 0.05);
        }

        // Update pulse phase
        this.pulsePhase += 0.1;
    }

    /**
     * Get interpolated position for smooth rendering
     * @param {number} alpha - Interpolation factor (0-1)
     * @returns {{x: number, y: number}} Interpolated position
     */
    getInterpolatedPosition(alpha) {
        return {
            x: this.prevX + (this.x - this.prevX) * alpha,
            y: this.prevY + (this.y - this.prevY) * alpha
        };
    }
}

// ============================================================================
// RENDERER
// ============================================================================

/**
 * Canvas-based renderer with visual effects
 */
class Renderer {
    /**
     * @param {HTMLCanvasElement} canvas - Canvas element
     */
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particleSystem = new ParticleSystem();

        // Offscreen canvas for trails
        this.trailCanvas = document.createElement('canvas');
        this.trailCtx = this.trailCanvas.getContext('2d');
    }

    /**
     * Resize the canvas
     * @param {number} size - New size
     */
    resize(size) {
        this.canvas.width = size;
        this.canvas.height = size;
        this.trailCanvas.width = size;
        this.trailCanvas.height = size;
    }

    /**
     * Clear the canvas
     */
    clear() {
        this.ctx.fillStyle = '#0f172a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Draw the arena background
     * @param {number} radius - Arena radius
     * @param {number} shrinkFactor - Battle royale shrink factor (0-1)
     */
    drawArena(radius, shrinkFactor = 1) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const effectiveRadius = radius * shrinkFactor;

        // Arena background
        this.ctx.fillStyle = '#1e293b';
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, effectiveRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Arena border
        this.ctx.strokeStyle = '#475569';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        // Danger zone for battle royale
        if (shrinkFactor < 1) {
            this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 5]);
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
    }

    /**
     * Draw spatial grid for debugging
     * @param {SpatialHashGrid} grid - Spatial grid
     */
    drawGrid(grid) {
        if (!CONFIG.showGrid) return;

        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.lineWidth = 1;

        for (let x = 0; x < this.canvas.width; x += grid.cellSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }

        for (let y = 0; y < this.canvas.height; y += grid.cellSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }

    /**
     * Draw entity trails
     * @param {Entity[]} entities - Entities to draw trails for
     */
    drawTrails(entities) {
        if (!CONFIG.showTrails) return;

        for (const entity of entities) {
            if (entity.trail.length < 2) continue;

            const color = CONFIG.colors[entity.type].trail;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = CONFIG.entitySize * 0.6;
            this.ctx.lineCap = 'round';

            for (let i = 1; i < entity.trail.length; i++) {
                const alpha = i / entity.trail.length * 0.5;
                this.ctx.globalAlpha = alpha;
                this.ctx.beginPath();
                this.ctx.moveTo(entity.trail[i - 1].x, entity.trail[i - 1].y);
                this.ctx.lineTo(entity.trail[i].x, entity.trail[i].y);
                this.ctx.stroke();
            }
        }
        this.ctx.globalAlpha = 1;
    }

    /**
     * Draw entities
     * @param {Entity[]} entities - Entities to draw
     * @param {number} alpha - Interpolation alpha
     */
    drawEntities(entities, alpha) {
        for (const entity of entities) {
            const pos = entity.getInterpolatedPosition(alpha);
            const color = CONFIG.colors[entity.type];
            const size = CONFIG.entitySize * entity.transformScale;

            // Glow effect (optional)
            if (CONFIG.showGlow) {
                const pulse = Math.sin(entity.pulsePhase) * 0.3 + 0.7;
                const glowSize = size * 1.5 * pulse;

                const gradient = this.ctx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, glowSize
                );
                gradient.addColorStop(0, color.glow);
                gradient.addColorStop(1, 'transparent');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, glowSize, 0, Math.PI * 2);
                this.ctx.fill();
            }

            // Entity emoji only (no colored circle behind)
            this.ctx.font = `${size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(CONFIG.emojis[entity.type], pos.x, pos.y);
        }
    }

    /**
     * Draw particles
     */
    drawParticles() {
        if (!CONFIG.showParticles) return;
        this.particleSystem.render(this.ctx);
    }

    /**
     * Create transformation effect
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} type - New entity type
     */
    createTransformEffect(x, y, type) {
        if (!CONFIG.showParticles) return;
        this.particleSystem.burst(x, y, CONFIG.colors[type].main, 15);
    }

    /**
     * Update particle system
     */
    updateParticles() {
        this.particleSystem.update();
    }

    /**
     * Draw victory celebration
     * @param {string} winner - Winning type
     */
    drawVictoryCelebration(winner) {
        // Create continuous particle bursts
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const radius = this.canvas.width / 2 - 50;

        for (let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            this.particleSystem.burst(
                centerX + Math.cos(angle) * r,
                centerY + Math.sin(angle) * r,
                CONFIG.colors[winner].main,
                8
            );
        }
    }
}

// ============================================================================
// ANALYTICS
// ============================================================================

/**
 * Real-time analytics and statistics tracking
 */
class Analytics {
    constructor() {
        this.populationHistory = [];
        this.maxHistoryLength = 200;
        this.transformations = 0;
        this.generation = 0;
        this.roundStartTime = 0;
        this.victoryTimes = [];
        this.recentTransforms = { rock: 0, paper: 0, scissors: 0 };
        this.momentumWindow = [];
        this.momentumWindowSize = 30;

        // Chart setup
        this.chartCanvas = document.getElementById('populationChart');
        this.chartCtx = this.chartCanvas.getContext('2d');
    }

    /**
     * Start a new round
     */
    startRound() {
        this.roundStartTime = performance.now();
        this.transformations = 0;
        this.generation = 0;
        this.populationHistory = [];
        this.recentTransforms = { rock: 0, paper: 0, scissors: 0 };
        this.momentumWindow = [];
    }

    /**
     * Record a transformation
     * @param {string} loserType - Type that lost
     * @param {string} winnerType - Type that won
     */
    recordTransformation(loserType, winnerType) {
        this.transformations++;
        this.recentTransforms[winnerType]++;
        this.momentumWindow.push(winnerType);
        if (this.momentumWindow.length > this.momentumWindowSize) {
            this.momentumWindow.shift();
        }
    }

    /**
     * Record population snapshot
     * @param {Object} counts - Population counts by type
     */
    recordPopulation(counts) {
        this.populationHistory.push({ ...counts, time: performance.now() });
        if (this.populationHistory.length > this.maxHistoryLength) {
            this.populationHistory.shift();
        }
        this.generation++;
    }

    /**
     * Record victory
     */
    recordVictory() {
        const victoryTime = (performance.now() - this.roundStartTime) / 1000;
        this.victoryTimes.push(victoryTime);
    }

    /**
     * Get average victory time
     * @returns {string} Formatted average time
     */
    getAverageVictoryTime() {
        if (this.victoryTimes.length === 0) return '-';
        const avg = this.victoryTimes.reduce((a, b) => a + b, 0) / this.victoryTimes.length;
        return `${avg.toFixed(1)}s`;
    }

    /**
     * Get current momentum (which type is winning most encounters)
     * @returns {{type: string, strength: number}} Momentum info
     */
    getMomentum() {
        if (this.momentumWindow.length < 5) {
            return { type: null, strength: 0 };
        }

        const counts = { rock: 0, paper: 0, scissors: 0 };
        this.momentumWindow.forEach(type => counts[type]++);

        let maxType = 'rock';
        let maxCount = counts.rock;
        for (const type of ['paper', 'scissors']) {
            if (counts[type] > maxCount) {
                maxCount = counts[type];
                maxType = type;
            }
        }

        return {
            type: maxType,
            strength: maxCount / this.momentumWindow.length
        };
    }

    /**
     * Draw population chart
     */
    drawChart() {
        const ctx = this.chartCtx;
        const canvas = this.chartCanvas;
        const width = canvas.width = canvas.offsetWidth;
        const height = canvas.height = canvas.offsetHeight;

        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, width, height);

        if (this.populationHistory.length < 2) return;

        const history = this.populationHistory;
        const maxPop = Math.max(...history.map(h => Math.max(h.rock, h.paper, h.scissors)));

        const drawLine = (type, color) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < history.length; i++) {
                const x = (i / (history.length - 1)) * width;
                const y = height - (history[i][type] / maxPop) * height * 0.9 - 5;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        };

        drawLine('rock', CONFIG.colors.rock.main);
        drawLine('paper', CONFIG.colors.paper.main);
        drawLine('scissors', CONFIG.colors.scissors.main);
    }

    /**
     * Reset analytics
     */
    reset() {
        this.populationHistory = [];
        this.transformations = 0;
        this.generation = 0;
        this.recentTransforms = { rock: 0, paper: 0, scissors: 0 };
        this.momentumWindow = [];
    }
}

// ============================================================================
// GAME
// ============================================================================

/**
 * Main game controller
 */
class Game extends EventEmitter {
    constructor() {
        super();

        // Canvas setup
        this.canvas = document.getElementById('gameCanvas');
        this.renderer = new Renderer(this.canvas);
        this.analytics = new Analytics();

        // Game state
        this.entities = [];
        this.spatialGrid = new SpatialHashGrid(CONFIG.cellSize, CONFIG.arenaSize, CONFIG.arenaSize);
        this.running = false;
        this.gameOver = false;
        this.winner = null;

        // Fixed timestep
        this.accumulator = 0;
        this.lastTime = 0;
        this.interpolationAlpha = 0;

        // Battle royale
        this.shrinkFactor = 1;
        this.shrinkRate = 0.0001;

        // Tournament
        this.tournamentRound = 1;
        this.tournamentWins = { rock: 0, paper: 0, scissors: 0 };
        this.tournamentRounds = 5;

        // Selected spawn type
        this.selectedSpawnType = 'rock';

        // Initialize
        this.resize(CONFIG.arenaSize);
    }

    /**
     * Resize the game arena
     * @param {number} size - New size
     */
    resize(size) {
        CONFIG.arenaSize = size;
        this.renderer.resize(size);
        this.spatialGrid.resize(size, size);
    }

    /**
     * Initialize entities based on formation
     */
    initEntities() {
        this.entities = [];
        const types = ['rock', 'paper', 'scissors'];
        const centerX = CONFIG.arenaSize / 2;
        const centerY = CONFIG.arenaSize / 2;
        const radius = CONFIG.arenaSize / 2 - CONFIG.entitySize;

        let count = CONFIG.entityCount;

        // Infection mode starts with fewer entities
        if (CONFIG.gameMode === 'infection') {
            count = 3;
        }

        for (let i = 0; i < count; i++) {
            const type = types[i % 3];
            let x, y;

            switch (CONFIG.formation) {
                case 'clustered':
                    // Each type clusters in a third of the arena
                    const clusterAngle = (types.indexOf(type) / 3) * Math.PI * 2;
                    const clusterX = centerX + Math.cos(clusterAngle) * radius * 0.5;
                    const clusterY = centerY + Math.sin(clusterAngle) * radius * 0.5;
                    const spread = radius * 0.3;
                    x = clusterX + (Math.random() - 0.5) * spread;
                    y = clusterY + (Math.random() - 0.5) * spread;
                    break;

                case 'ring':
                    // Entities form a ring around the center
                    const ringAngle = (i / count) * Math.PI * 2;
                    const ringRadius = radius * 0.7;
                    x = centerX + Math.cos(ringAngle) * ringRadius + (Math.random() - 0.5) * 20;
                    y = centerY + Math.sin(ringAngle) * ringRadius + (Math.random() - 0.5) * 20;
                    break;

                case 'corners':
                    // Each type starts in a corner
                    const cornerAngles = [Math.PI * 0.75, Math.PI * 1.75, Math.PI * 0.25];
                    const cornerAngle = cornerAngles[types.indexOf(type)];
                    const cornerRadius = radius * 0.7;
                    x = centerX + Math.cos(cornerAngle) * cornerRadius + (Math.random() - 0.5) * 40;
                    y = centerY + Math.sin(cornerAngle) * cornerRadius + (Math.random() - 0.5) * 40;
                    break;

                default: // random
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * radius;
                    x = centerX + Math.cos(angle) * r;
                    y = centerY + Math.sin(angle) * r;
            }

            // Clamp to arena
            const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            if (dist > radius) {
                const angle = Math.atan2(y - centerY, x - centerX);
                x = centerX + Math.cos(angle) * radius;
                y = centerY + Math.sin(angle) * radius;
            }

            this.entities.push(new Entity(type, x, y));
        }

        // Reset battle royale shrink
        this.shrinkFactor = 1;
    }

    /**
     * Spawn an entity at a position
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} type - Entity type
     */
    spawnEntity(x, y, type = this.selectedSpawnType) {
        const centerX = CONFIG.arenaSize / 2;
        const centerY = CONFIG.arenaSize / 2;
        const radius = CONFIG.arenaSize / 2 - CONFIG.entitySize;

        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
        if (dist <= radius * this.shrinkFactor) {
            this.entities.push(new Entity(type, x, y));
            this.emit('entitySpawned', { type, x, y });

            // Render immediately if paused
            if (!this.running) {
                this.render(1);
            }
        }
    }

    /**
     * Start the game loop
     */
    start() {
        if (this.running) return;

        if (this.gameOver) {
            this.reset();
        }

        this.running = true;
        this.lastTime = performance.now();
        this.analytics.startRound();
        this.gameLoop();

        this.emit('started');
    }

    /**
     * Pause the game
     */
    pause() {
        this.running = false;
        this.emit('paused');
    }

    /**
     * Reset the game
     */
    reset() {
        this.running = false;
        this.gameOver = false;
        this.winner = null;
        this.accumulator = 0;
        this.shrinkFactor = 1;
        this.initEntities();
        this.analytics.reset();
        this.renderer.particleSystem.clear();
        this.render(1);

        this.emit('reset');
    }

    /**
     * Trigger extinction event (removes 50% of dominant type)
     */
    extinctionEvent() {
        const counts = this.getPopulationCounts();
        let dominantType = 'rock';
        let maxCount = counts.rock;

        for (const type of ['paper', 'scissors']) {
            if (counts[type] > maxCount) {
                maxCount = counts[type];
                dominantType = type;
            }
        }

        // Remove 50% of dominant type
        const toRemove = Math.floor(maxCount / 2);
        let removed = 0;

        this.entities = this.entities.filter(entity => {
            if (entity.type === dominantType && removed < toRemove) {
                this.renderer.createTransformEffect(entity.x, entity.y, dominantType);
                removed++;
                return false;
            }
            return true;
        });

        this.emit('extinction', { type: dominantType, removed });

        // Render immediately if paused
        if (!this.running) {
            this.render(1);
        }
    }

    /**
     * Get population counts
     * @returns {Object} Counts by type
     */
    getPopulationCounts() {
        const counts = { rock: 0, paper: 0, scissors: 0 };
        for (const entity of this.entities) {
            counts[entity.type]++;
        }
        return counts;
    }

    /**
     * Fixed timestep game loop
     */
    gameLoop() {
        if (!this.running) return;

        const currentTime = performance.now();
        let deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;

        // Clamp delta time
        if (deltaTime > CONFIG.maxDeltaTime) {
            deltaTime = CONFIG.maxDeltaTime;
        }

        // Apply time scale
        deltaTime *= CONFIG.timeScale;

        this.accumulator += deltaTime;

        // Fixed timestep updates
        while (this.accumulator >= CONFIG.fixedTimestep) {
            this.update(CONFIG.fixedTimestep);
            this.accumulator -= CONFIG.fixedTimestep;
        }

        // Interpolation alpha for smooth rendering
        this.interpolationAlpha = this.accumulator / CONFIG.fixedTimestep;

        // Render
        this.render(this.interpolationAlpha);

        // Continue loop
        requestAnimationFrame(() => this.gameLoop());
    }

    /**
     * Update game state
     * @param {number} dt - Delta time
     */
    update(dt) {
        const centerX = CONFIG.arenaSize / 2;
        const centerY = CONFIG.arenaSize / 2;
        const baseRadius = CONFIG.arenaSize / 2 - CONFIG.entitySize;
        const effectiveRadius = baseRadius * this.shrinkFactor;

        // Battle royale shrinking
        if (CONFIG.gameMode === 'battleRoyale' && this.shrinkFactor > 0.3) {
            this.shrinkFactor -= this.shrinkRate * dt;

            // Push entities inside shrinking boundary
            for (const entity of this.entities) {
                const dx = entity.x - centerX;
                const dy = entity.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > effectiveRadius) {
                    const angle = Math.atan2(dy, dx);
                    entity.x = centerX + Math.cos(angle) * (effectiveRadius - 5);
                    entity.y = centerY + Math.sin(angle) * (effectiveRadius - 5);
                }
            }
        }

        // Balanced mode: auto-spawn losing types
        if (CONFIG.gameMode === 'balanced') {
            const counts = this.getPopulationCounts();
            const total = counts.rock + counts.paper + counts.scissors;
            const target = total / 3;

            for (const type of ['rock', 'paper', 'scissors']) {
                if (counts[type] < target * 0.5 && counts[type] > 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * effectiveRadius * 0.8;
                    this.spawnEntity(
                        centerX + Math.cos(angle) * r,
                        centerY + Math.sin(angle) * r,
                        type
                    );
                }
            }
        }

        // Build spatial grid
        this.spatialGrid.clear();
        for (const entity of this.entities) {
            this.spatialGrid.insert(entity);
        }

        // Update entities
        const transformations = [];

        for (const entity of this.entities) {
            const nearby = this.spatialGrid.getNearby(
                entity.x, entity.y,
                Math.max(CONFIG.fearRadius, CONFIG.flockRadius) * 1.5
            );

            entity.flock(nearby);
            const caught = entity.interact(nearby);

            if (caught && caught.type !== entity.type) {
                transformations.push({ prey: caught, predator: entity });
            }

            entity.update(dt, centerX, centerY, effectiveRadius);
        }

        // Process transformations
        for (const { prey, predator } of transformations) {
            if (prey.type !== predator.type) {
                const oldType = prey.type;
                prey.transform(predator.type);
                this.renderer.createTransformEffect(prey.x, prey.y, predator.type);
                this.analytics.recordTransformation(oldType, predator.type);
                this.emit('transformation', { from: oldType, to: predator.type });
            }
        }

        // Record analytics (only while game is active)
        const counts = this.getPopulationCounts();
        if (!this.gameOver) {
            this.analytics.recordPopulation(counts);
        }

        // Check for game over
        const aliveTypes = ['rock', 'paper', 'scissors'].filter(t => counts[t] > 0);
        if (aliveTypes.length === 1) {
            this.winner = aliveTypes[0];
            this.gameOver = true;
            this.analytics.recordVictory();

            // Tournament mode handling
            if (CONFIG.gameMode === 'tournament') {
                this.tournamentWins[this.winner]++;
                if (this.tournamentRound < this.tournamentRounds) {
                    this.tournamentRound++;
                    setTimeout(() => {
                        this.reset();
                        this.start();
                    }, 2000);
                }
            }

            this.emit('gameOver', { winner: this.winner });
        }

        // Update particles
        this.renderer.updateParticles();
    }

    /**
     * Render the game
     * @param {number} alpha - Interpolation alpha
     */
    render(alpha) {
        this.renderer.clear();
        this.renderer.drawArena(CONFIG.arenaSize / 2 - CONFIG.entitySize, this.shrinkFactor);

        if (CONFIG.showGrid) {
            this.renderer.drawGrid(this.spatialGrid);
        }

        this.renderer.drawTrails(this.entities);
        this.renderer.drawEntities(this.entities, alpha);
        this.renderer.drawParticles();

        // Victory celebration particles
        if (this.gameOver && this.winner) {
            this.renderer.drawVictoryCelebration(this.winner);
        }
    }
}

// ============================================================================
// UI CONTROLLER
// ============================================================================

/**
 * UI controller for game interface
 */
class UIController {
    /**
     * @param {Game} game - Game instance
     */
    constructor(game) {
        this.game = game;
        this.isDarkTheme = true;

        this.setupEventListeners();
        this.setupKeyboardShortcuts();
        this.setupPanels();
        this.updateUI();
    }

    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Control buttons
        document.getElementById('startBtn').addEventListener('click', () => {
            if (this.game.running) return;
            this.game.start();
            this.updateButtons();
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            this.game.pause();
            this.updateButtons();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            this.game.reset();
            this.updateButtons();
            this.hideVictoryOverlay();
        });

        document.getElementById('extinctionBtn').addEventListener('click', () => {
            this.game.extinctionEvent();
        });

        // Theme toggle
        document.getElementById('themeToggle').addEventListener('click', () => {
            this.toggleTheme();
        });

        // Fullscreen toggle
        document.getElementById('fullscreenToggle').addEventListener('click', () => {
            this.toggleFullscreen();
        });

        // Sidebar toggle
        document.getElementById('sidebarToggle').addEventListener('click', () => {
            this.toggleSidebar();
        });

        // Speed controls
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = parseFloat(btn.dataset.speed);
                CONFIG.timeScale = speed;
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Sliders
        this.setupSlider('entityCount', val => {
            CONFIG.entityCount = val;
            document.getElementById('entityCountValue').textContent = val;
        });

        this.setupSlider('entitySpeed', val => {
            CONFIG.entitySpeed = val;
            document.getElementById('entitySpeedValue').textContent = val;
        });

        this.setupSlider('arenaSize', val => {
            document.getElementById('arenaSizeValue').textContent = val;
            this.game.resize(val);
            this.game.reset();
        });

        this.setupSlider('cohesion', val => {
            CONFIG.cohesionWeight = val / 100;
            document.getElementById('cohesionValue').textContent = (val / 100).toFixed(1);
        });

        this.setupSlider('separation', val => {
            CONFIG.separationWeight = val / 100;
            document.getElementById('separationValue').textContent = (val / 100).toFixed(1);
        });

        this.setupSlider('alignment', val => {
            CONFIG.alignmentWeight = val / 100;
            document.getElementById('alignmentValue').textContent = (val / 100).toFixed(1);
        });

        this.setupSlider('fearRadius', val => {
            CONFIG.fearRadius = val;
            document.getElementById('fearRadiusValue').textContent = val;
        });

        // Entity selector
        document.querySelectorAll('.entity-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.entity-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.game.selectedSpawnType = btn.dataset.type;
            });
        });

        // Game mode selector
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                CONFIG.gameMode = btn.dataset.mode;

                document.getElementById('tournamentInfo').style.display =
                    CONFIG.gameMode === 'tournament' ? 'block' : 'none';

                if (CONFIG.gameMode === 'tournament') {
                    this.game.tournamentRound = 1;
                    this.game.tournamentWins = { rock: 0, paper: 0, scissors: 0 };
                }

                this.game.reset();
            });
        });

        // Formation selector
        document.querySelectorAll('[data-formation]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-formation]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                CONFIG.formation = btn.dataset.formation;
                this.game.reset();
            });
        });

        // Visual effect toggles
        document.getElementById('showTrails').addEventListener('change', e => {
            CONFIG.showTrails = e.target.checked;
        });

        document.getElementById('showParticles').addEventListener('change', e => {
            CONFIG.showParticles = e.target.checked;
        });

        document.getElementById('showGlow').addEventListener('change', e => {
            CONFIG.showGlow = e.target.checked;
        });

        document.getElementById('showGrid').addEventListener('change', e => {
            CONFIG.showGrid = e.target.checked;
        });

        // Canvas click to spawn
        this.game.canvas.addEventListener('click', e => {
            const rect = this.game.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            this.game.spawnEntity(x, y);
        });

        // Touch support
        this.game.canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = this.game.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            this.game.spawnEntity(x, y);
        });

        // Game events
        this.game.on('gameOver', ({ winner }) => {
            this.showVictoryOverlay(winner);
            this.updateButtons();
        });

        this.game.on('started', () => this.updateButtons());
        this.game.on('paused', () => this.updateButtons());
        this.game.on('reset', () => this.hideVictoryOverlay());

        // Update stats periodically
        setInterval(() => this.updateStats(), 100);
    }

    /**
     * Setup slider with callback
     */
    setupSlider(id, callback) {
        const slider = document.getElementById(id);
        slider.addEventListener('input', () => {
            callback(parseInt(slider.value));
        });
    }

    /**
     * Setup keyboard shortcuts
     */
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', e => {
            // Ignore if typing in an input
            if (e.target.tagName === 'INPUT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    if (this.game.running) {
                        this.game.pause();
                    } else {
                        this.game.start();
                    }
                    this.updateButtons();
                    break;

                case 'KeyR':
                    this.game.reset();
                    this.updateButtons();
                    this.hideVictoryOverlay();
                    break;

                case 'KeyE':
                    this.game.extinctionEvent();
                    break;

                case 'Tab':
                    e.preventDefault();
                    this.toggleSidebar();
                    break;

                case 'Digit1':
                    this.setSpeed(0.25);
                    break;
                case 'Digit2':
                    this.setSpeed(0.5);
                    break;
                case 'Digit3':
                    this.setSpeed(1);
                    break;
                case 'Digit4':
                    this.setSpeed(2);
                    break;
                case 'Digit5':
                    this.setSpeed(4);
                    break;
            }
        });
    }

    /**
     * Set game speed
     */
    setSpeed(speed) {
        CONFIG.timeScale = speed;
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
        });
    }

    /**
     * Setup collapsible panels
     */
    setupPanels() {
        document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('open');
            });
        });
    }

    /**
     * Update control buttons
     */
    updateButtons() {
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');

        startBtn.disabled = this.game.running;
        stopBtn.disabled = !this.game.running;
    }

    /**
     * Update statistics display
     */
    updateStats() {
        const counts = this.game.getPopulationCounts();

        document.getElementById('rockCount').textContent = counts.rock;
        document.getElementById('paperCount').textContent = counts.paper;
        document.getElementById('scissorsCount').textContent = counts.scissors;

        document.getElementById('generationCount').textContent = this.game.analytics.generation;
        document.getElementById('transformCount').textContent = this.game.analytics.transformations;

        // Momentum
        const momentum = this.game.analytics.getMomentum();
        const momentumDot = document.getElementById('momentumDot');
        const momentumType = document.getElementById('momentumType');

        if (momentum.type) {
            momentumDot.style.background = CONFIG.colors[momentum.type].main;
            momentumType.textContent = CONFIG.emojis[momentum.type];
        } else {
            momentumDot.style.background = '#666';
            momentumType.textContent = '-';
        }

        document.getElementById('avgVictoryTime').textContent = this.game.analytics.getAverageVictoryTime();

        // Tournament info
        if (CONFIG.gameMode === 'tournament') {
            document.getElementById('tournamentRound').textContent = this.game.tournamentRound;
            const totalWins = Object.values(this.game.tournamentWins).reduce((a, b) => a + b, 0);
            document.getElementById('tournamentWins').textContent = totalWins;
        }

        // Draw chart
        this.game.analytics.drawChart();
    }

    /**
     * Update full UI
     */
    updateUI() {
        this.updateButtons();
        this.updateStats();
    }

    /**
     * Toggle theme
     */
    toggleTheme() {
        this.isDarkTheme = !this.isDarkTheme;
        document.body.classList.toggle('light-theme', !this.isDarkTheme);
        document.getElementById('themeToggle').textContent = this.isDarkTheme ? 'üåô' : '‚òÄÔ∏è';
    }

    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    /**
     * Toggle sidebar
     */
    toggleSidebar() {
        document.getElementById('sidebar').classList.toggle('collapsed');
    }

    /**
     * Show victory overlay
     */
    showVictoryOverlay(winner) {
        const overlay = document.getElementById('victoryOverlay');
        const emoji = document.getElementById('victoryEmoji');
        const text = document.getElementById('victoryText');

        emoji.textContent = CONFIG.emojis[winner];
        text.textContent = `${winner.charAt(0).toUpperCase() + winner.slice(1)} Wins!`;
        text.style.color = CONFIG.colors[winner].main;

        overlay.classList.add('show');
    }

    /**
     * Hide victory overlay
     */
    hideVictoryOverlay() {
        document.getElementById('victoryOverlay').classList.remove('show');
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Create game instance
const game = new Game();
game.initEntities();
game.render(1);

// Create UI controller
const ui = new UIController(game);

// Initial stats update
ui.updateStats();
</script>
<script src="../logo.js"></script>
</body>
</html>
