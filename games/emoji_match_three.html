<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Match 3</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçì</text></svg>">
    <style>
        :root {
            --primary: #5c6bc0;
            --primary-light: #8e99f3;
            --primary-dark: #26418f;
            --secondary: #ff7043;
            --secondary-light: #ffa270;
            --secondary-dark: #c63f17;
            --bg: #f9f9fb;
            --text: #333;
            --text-light: #666;
            --text-inverse: #fff;
            --board-bg: #fff;
            --tile-bg: #e3f2fd;
            --tile-shadow: rgba(0, 0, 0, 0.1);
            --header-bg: #eaeafa;
            --card-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            --border: #e0e0e0;
            --success: #66bb6a;
            --hint: rgba(255, 235, 59, 0.5);
            --star: #ffc107;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary: #5c6bc0;
                --primary-light: #8e99f3;
                --primary-dark: #26418f;
                --secondary: #ff7043;
                --secondary-light: #ffa270;
                --secondary-dark: #c63f17;
                --bg: #121212;
                --text: #eee;
                --text-light: #aaa;
                --text-inverse: #fff;
                --board-bg: #1e1e1e;
                --tile-bg: #2a2a2a;
                --tile-shadow: rgba(0, 0, 0, 0.3);
                --header-bg: #2a2f4d;
                --card-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
                --border: #333;
                --success: #4caf50;
                --hint: rgba(255, 235, 59, 0.3);
                --star: #ffc107;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, transform 0.2s;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            background: var(--board-bg);
            border-radius: 20px;
            box-shadow: var(--card-shadow);
            padding: 24px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .game-title {
            text-align: center;
            margin-bottom: 16px;
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 0.5px;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            background: var(--header-bg);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 20px;
            font-weight: 600;
            box-shadow: 0 4px 8px var(--tile-shadow);
        }

        .header-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
        }

        .header-label {
            font-size: 12px;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .progress-container {
            height: 6px;
            background: var(--tile-bg);
            border-radius: 3px;
            margin: 12px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, var(--primary-light), var(--primary));
            width: 0%;
            transition: width 0.5s ease;
        }

        .game-board {
            aspect-ratio: 1/1;
            margin-bottom: 20px;
            position: relative;
            border-radius: 12px;
            background: var(--board-bg);
            overflow: hidden;
            box-shadow: inset 0 2px 10px var(--tile-shadow);
            touch-action: none;
        }

        .tile {
            position: absolute;
            width: 12.5%;
            height: 12.5%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--tile-bg);
            border-radius: 8px;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.3s, opacity 0.3s;
            box-shadow: 0 2px 4px var(--tile-shadow);
            z-index: 1;
        }

        .tile:hover {
            border: solid 1px #fff;
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 0 0 12px 5px var(--primary-light);
            z-index: 2;
        }

        .tile.matching {
            background-color: var(--success);
            animation: pulse 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .tile.special {
            background: linear-gradient(135deg, var(--secondary-light), var(--secondary));
            box-shadow: 0 3px 8px var(--tile-shadow);
        }

        .tile.hint {
            animation: hint-pulse 1.5s infinite;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .btn {
            padding: 14px 25px;
            background: var(--primary);
            color: var(--text-inverse);
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(92, 107, 192, 0.3);
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(92, 107, 192, 0.4);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(92, 107, 192, 0.2);
        }

        .btn-secondary {
            background: var(--secondary);
            box-shadow: 0 4px 8px rgba(255, 112, 67, 0.3);
        }

        .btn-secondary:hover {
            background: var(--secondary-dark);
            box-shadow: 0 6px 12px rgba(255, 112, 67, 0.4);
        }

        .btn-small {
            font-size: 14px;
            padding: 8px 16px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--board-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 24px;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            text-align: center;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-title {
            font-size: 28px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 700;
        }

        .modal-content {
            margin-bottom: 24px;
            line-height: 1.6;
            color: var(--text-light);
        }

        .points-popup {
            position: absolute;
            font-weight: bold;
            font-size: 20px;
            z-index: 10;
            pointer-events: none;
            animation: float-up 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        .points-popup.combo {
            color: var(--secondary);
            font-size: 24px;
        }

        .high-score {
            text-align: center;
            margin: 8px 0;
            font-size: 18px;
            color: var(--star);
        }

        .combo-counter {
            position: absolute;
            top: 16px;
            right: 16px;
            background: var(--secondary);
            color: var(--text-inverse);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
            font-size: 18px;
            opacity: 0;
            transform: scale(0);
            transition: transform 0.3s, opacity 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .combo-counter.active {
            opacity: 1;
            transform: scale(1);
        }

        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .paused-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .paused-message {
            font-size: 32px;
            color: var(--text-inverse);
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-up-banner {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 100%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--text-inverse);
            text-align: center;
            padding: 16px;
            font-size: 24px;
            font-weight: 700;
            z-index: 8;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .level-up-banner.active {
            animation: slide-in 1.5s ease-in-out forwards;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes float-up {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        @keyframes hint-pulse {
            0% { box-shadow: 0 0 0 0 var(--hint); }
            70% { box-shadow: 0 0 0 10px rgba(255, 235, 59, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); }
        }

        @keyframes slide-in {
            0% { opacity: 0; transform: translateY(-50%) translateX(-100%); }
            20% { opacity: 1; transform: translateY(-50%) translateX(0); }
            80% { opacity: 1; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(100%); }
        }

        @media (max-width: 500px) {
            .game-container { padding: 16px; }
            .game-header { padding: 12px; }
            .header-value { font-size: 18px; }
            .tile { font-size: 20px; }
            .modal-title { font-size: 24px; }
            .btn { padding: 12px 20px; font-size: 15px; }
        }
    </style>
</head>
<body>
<div class="game-container">
    <h1 class="game-title">Emoji Match 3</h1>

    <div class="game-header">
        <div class="header-item">
            <span class="header-value" id="score">0</span>
            <span class="header-label">Score</span>
        </div>
        <div class="header-item">
            <span class="header-value" id="level">1</span>
            <span class="header-label">Level</span>
        </div>
        <div class="header-item">
            <span class="header-value" id="timer">60</span>
            <span class="header-label">Time</span>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
    </div>

    <div class="game-board" id="game-board"></div>

    <div class="game-controls">
        <button id="start-btn" class="btn">Start Game</button>
        <button id="pause-btn" class="btn btn-secondary" style="display: none;">Pause</button>
        <button id="restart-btn" class="btn" style="display: none;">Restart</button>
    </div>

    <div class="high-score" id="high-score"></div>

    <div class="modal" id="welcome-modal">
        <h2 class="modal-title">Welcome to Emoji Match 3!</h2>
        <div class="modal-content">
            Swap adjacent emojis to create matches of 3 or more.
            Make longer matches for special tiles and bonus points!
            <br><br>
            Complete levels by reaching the target score before time runs out.
        </div>
        <button id="welcome-btn" class="btn">Let's Play!</button>
    </div>

    <div class="modal" id="game-over-modal">
        <h2 class="modal-title">Game Over!</h2>
        <div class="modal-content">
            <div id="final-score"></div>
            <div id="final-level"></div>
            <div id="new-high-score" style="display: none; color: var(--star); margin-top: 10px; font-weight: bold;">New High Score! üèÜ</div>
        </div>
        <button id="play-again-btn" class="btn">Play Again</button>
    </div>

    <div class="paused-overlay" id="paused-overlay">
        <div class="paused-message">PAUSED</div>
    </div>

    <div class="level-up-banner" id="level-up-banner">Level Up!</div>

    <div class="combo-counter" id="combo-counter">x1</div>
</div>

<script>
    // Game Configuration
    const BOARD_SIZE = 8;
    const EMOJIS = ['üêò', 'üê∏', 'üêî', 'üêô', 'ü¶â', 'üêù', 'ü¶ñ', 'ü¶Ñ'];
    const SPECIAL_EMOJIS = ['üî•', '‚ö°', 'üí•', 'üåü'];
    const STARTING_TIME = 60;
    const LEVEL_UP_SCORE = 500;
    const MATCH_POINTS = 10;
    const BONUS_POINTS = 5;
    const COMBO_MULTIPLIER = 1.5;
    const LEVEL_TIME_BONUS = 15;
    const HINT_DELAY = 5000;

    // Game State
    let board = [];
    let score = 0;
    let level = 1;
    let timeLeft = STARTING_TIME;
    let gameTimer = null;
    let hintTimer = null;
    let isPlaying = false;
    let isPaused = false;
    let isProcessing = false;
    let selectedTile = null;
    let comboCount = 0;
    let highScore = localStorage.getItem('emojiMatch3HighScore') || 0;
    let levelProgress = 0;

    // DOM Elements
    const gameBoard = document.getElementById('game-board');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const timerDisplay = document.getElementById('timer');
    const progressBar = document.getElementById('progress-bar');
    const highScoreDisplay = document.getElementById('high-score');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const restartBtn = document.getElementById('restart-btn');
    const welcomeModal = document.getElementById('welcome-modal');
    const welcomeBtn = document.getElementById('welcome-btn');
    const gameOverModal = document.getElementById('game-over-modal');
    const finalScoreDisplay = document.getElementById('final-score');
    const finalLevelDisplay = document.getElementById('final-level');
    const newHighScoreDisplay = document.getElementById('new-high-score');
    const playAgainBtn = document.getElementById('play-again-btn');
    const pausedOverlay = document.getElementById('paused-overlay');
    const levelUpBanner = document.getElementById('level-up-banner');
    const comboCounter = document.getElementById('combo-counter');

    // Initialize the game
    function init() {
        // Show welcome screen
        welcomeModal.classList.add('active');

        // Display high score if exists
        if (highScore > 0) {
            highScoreDisplay.textContent = `High Score: ${highScore}`;
        }

        // Initialize board
        initializeBoard();

        // Setup event listeners
        welcomeBtn.addEventListener('click', () => {
            welcomeModal.classList.remove('active');
            startGame();
        });

        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', restartGame);
        playAgainBtn.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            restartGame();
        });

        // Add keyboard support
        document.addEventListener('keydown', handleKeyPress);
    }

    function handleKeyPress(e) {
        if (!isPlaying) return;

        if (e.key === ' ' || e.key === 'Escape') {
            togglePause();
        } else if (e.key === 'h') {
            showHint();
        }
    }

    // Helper Functions
    function getRandomEmoji() {
        return EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
    }

    function getSpecialEmoji() {
        return SPECIAL_EMOJIS[Math.floor(Math.random() * SPECIAL_EMOJIS.length)];
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function positionToCoords(position) {
        return { row: Math.floor(position / BOARD_SIZE), col: position % BOARD_SIZE };
    }

    function coordsToPosition(row, col) {
        return row * BOARD_SIZE + col;
    }

    function getPositionStyle(row, col) {
        return { left: `${col * 12.5}%`, top: `${row * 12.5}%` };
    }

    function createTile(emoji, row, col, isSpecial = false) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        if (isSpecial) tile.classList.add('special');
        tile.textContent = emoji;
        tile.dataset.row = row;
        tile.dataset.col = col;
        tile.dataset.pos = coordsToPosition(row, col);
        tile.dataset.special = isSpecial;

        const style = getPositionStyle(row, col);
        tile.style.left = style.left;
        tile.style.top = style.top;
        tile.addEventListener('click', handleTileClick);

        return tile;
    }

    function showPointsPopup(points, x, y, isCombo = false) {
        const popup = document.createElement('div');
        popup.className = 'points-popup';
        if (isCombo) {
            popup.classList.add('combo');
            popup.textContent = `Combo! +${points}`;
        } else {
            popup.textContent = `+${points}`;
        }
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`;
        gameBoard.appendChild(popup);

        setTimeout(() => {
            popup.remove();
        }, 1000);
    }

    // Game Initialization
    function initializeBoard() {
        board = [];
        gameBoard.innerHTML = '';

        // Create board data structure
        for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
            const {row, col} = positionToCoords(i);

            // Generate emoji (avoid creating initial matches)
            let emoji;
            do {
                emoji = getRandomEmoji();
            } while (
                // Check for horizontal match (left)
            (col >= 2 && board[coordsToPosition(row, col - 1)] === emoji && board[coordsToPosition(row, col - 2)] === emoji) ||
            // Check for vertical match (up)
            (row >= 2 && board[coordsToPosition(row - 1, col)] === emoji && board[coordsToPosition(row - 2, col)] === emoji)
                );

            board[i] = emoji;

            // Create visual tile
            const tile = createTile(emoji, row, col);
            gameBoard.appendChild(tile);
        }
    }

    // Game Control Functions
    function startGame() {
        isPlaying = true;
        isPaused = false;
        timeLeft = STARTING_TIME;
        timerDisplay.textContent = timeLeft;

        startBtn.style.display = 'none';
        pauseBtn.style.display = 'inline-block';
        restartBtn.style.display = 'inline-block';

        // Update progress bar
        updateProgressBar();

        // Start the timer
        gameTimer = setInterval(() => {
            if (isPaused) return;

            timeLeft--;
            timerDisplay.textContent = timeLeft;

            if (timeLeft <= 0) {
                endGame();
            }
        }, 1000);

        // Start hint timer
        startHintTimer();
    }

    function togglePause() {
        isPaused = !isPaused;

        if (isPaused) {
            pauseBtn.textContent = 'Resume';
            pausedOverlay.classList.add('active');
            clearTimeout(hintTimer);
        } else {
            pauseBtn.textContent = 'Pause';
            pausedOverlay.classList.remove('active');
            startHintTimer();
        }
    }

    function endGame() {
        isPlaying = false;
        clearInterval(gameTimer);
        clearTimeout(hintTimer);

        // Check for high score
        const newRecord = score > highScore;
        if (newRecord) {
            highScore = score;
            localStorage.setItem('emojiMatch3HighScore', highScore);
            highScoreDisplay.textContent = `High Score: ${highScore}`;
            newHighScoreDisplay.style.display = 'block';
        } else {
            newHighScoreDisplay.style.display = 'none';
        }

        // Show game over modal
        finalScoreDisplay.textContent = `Final Score: ${score}`;
        finalLevelDisplay.textContent = `Level Reached: ${level}`;
        gameOverModal.classList.add('active');

        // Hide game controls
        pauseBtn.style.display = 'none';
    }

    function restartGame() {
        // Reset game state
        clearInterval(gameTimer);
        clearTimeout(hintTimer);
        score = 0;
        level = 1;
        comboCount = 0;
        isProcessing = false;
        isPaused = false;
        selectedTile = null;

        // Update displays
        scoreDisplay.textContent = score;
        levelDisplay.textContent = level;
        comboCounter.classList.remove('active');

        // Reinitialize and start
        initializeBoard();
        startGame();
    }

    function levelUp() {
        level++;
        levelDisplay.textContent = level;

        // Reset progress bar
        levelProgress = 0;
        updateProgressBar();

        // Add bonus time
        timeLeft += LEVEL_TIME_BONUS;
        timerDisplay.textContent = timeLeft;

        // Show level up banner
        levelUpBanner.classList.add('active');
        setTimeout(() => {
            levelUpBanner.classList.remove('active');
        }, 1500);
    }

    function updateProgressBar() {
        levelProgress = (score % LEVEL_UP_SCORE) / LEVEL_UP_SCORE * 100;
        progressBar.style.width = `${levelProgress}%`;
    }

    function updateComboDisplay() {
        if (comboCount > 1) {
            comboCounter.textContent = `x${comboCount}`;
            comboCounter.classList.add('active');
        } else {
            comboCounter.classList.remove('active');
        }
    }

    function startHintTimer() {
        clearTimeout(hintTimer);
        hintTimer = setTimeout(() => {
            if (!isPlaying || isPaused || isProcessing) return;
            showHint();
        }, HINT_DELAY);
    }

    function showHint() {
        // Clear any existing hints
        document.querySelectorAll('.tile.hint').forEach(tile => {
            tile.classList.remove('hint');
        });

        // Find a possible move
        const moves = findPossibleMoves();
        if (moves.length > 0) {
            const move = moves[Math.floor(Math.random() * moves.length)];
            const tile1 = document.querySelector(`.tile[data-pos="${move.pos1}"]`);
            const tile2 = document.querySelector(`.tile[data-pos="${move.pos2}"]`);

            if (tile1 && tile2) {
                tile1.classList.add('hint');
                tile2.classList.add('hint');
            }
        }

        // Reset hint timer
        startHintTimer();
    }

    function findPossibleMoves() {
        const moves = [];

        // Try all possible swaps and check if they create a match
        for (let row = 0; row < BOARD_SIZE; row++) {
            for (let col = 0; col < BOARD_SIZE; col++) {
                const pos = coordsToPosition(row, col);

                // Try swap right
                if (col < BOARD_SIZE - 1) {
                    const rightPos = coordsToPosition(row, col + 1);
                    swapInModel(pos, rightPos);
                    if (findMatches().length > 0) {
                        moves.push({ pos1: pos, pos2: rightPos });
                    }
                    swapInModel(pos, rightPos); // Swap back
                }

                // Try swap down
                if (row < BOARD_SIZE - 1) {
                    const downPos = coordsToPosition(row + 1, col);
                    swapInModel(pos, downPos);
                    if (findMatches().length > 0) {
                        moves.push({ pos1: pos, pos2: downPos });
                    }
                    swapInModel(pos, downPos); // Swap back
                }
            }
        }

        return moves;
    }

    function swapInModel(pos1, pos2) {
        const temp = board[pos1];
        board[pos1] = board[pos2];
        board[pos2] = temp;
    }

    // Tile Selection and Movement
    function handleTileClick(event) {
        if (!isPlaying || isPaused || isProcessing) return;

        // Reset hint timer on interaction
        startHintTimer();

        // Remove hint classes
        document.querySelectorAll('.tile.hint').forEach(tile => {
            tile.classList.remove('hint');
        });

        const tile = event.currentTarget;
        const row = parseInt(tile.dataset.row);
        const col = parseInt(tile.dataset.col);

        // First selection
        if (!selectedTile) {
            selectedTile = tile;
            tile.classList.add('selected');
            return;
        }

        // Deselect same tile
        if (selectedTile === tile) {
            selectedTile.classList.remove('selected');
            selectedTile = null;
            return;
        }

        // Check if adjacent
        const selectedRow = parseInt(selectedTile.dataset.row);
        const selectedCol = parseInt(selectedTile.dataset.col);
        const isAdjacent = (
            (Math.abs(row - selectedRow) === 1 && col === selectedCol) ||
            (Math.abs(col - selectedCol) === 1 && row === selectedRow)
        );

        if (isAdjacent) {
            // Try swap
            isProcessing = true;
            swapTiles(selectedRow, selectedCol, row, col);
        } else {
            // Select new tile
            selectedTile.classList.remove('selected');
            selectedTile = tile;
            tile.classList.add('selected');
        }
    }

    async function swapTiles(row1, col1, row2, col2) {
        const pos1 = coordsToPosition(row1, col1);
        const pos2 = coordsToPosition(row2, col2);
        const tile1 = document.querySelector(`.tile[data-pos="${pos1}"]`);
        const tile2 = document.querySelector(`.tile[data-pos="${pos2}"]`);

        const isSpecial1 = tile1.dataset.special === 'true';
        const isSpecial2 = tile2.dataset.special === 'true';

        // Special tile handling
        if (isSpecial1 || isSpecial2) {
            // For special tiles, always allow the swap and trigger special effects
            await handleSpecialTileSwap(row1, col1, row2, col2, isSpecial1, isSpecial2);
            isProcessing = false;
            return;
        }

        // Swap in data model
        swapInModel(pos1, pos2);

        // Swap visually
        const style1 = getPositionStyle(row1, col1);
        const style2 = getPositionStyle(row2, col2);
        tile1.style.left = style2.left;
        tile1.style.top = style2.top;
        tile2.style.left = style1.left;
        tile2.style.top = style1.top;

        // Update data attributes
        tile1.dataset.row = row2;
        tile1.dataset.col = col2;
        tile1.dataset.pos = pos2;
        tile2.dataset.row = row1;
        tile2.dataset.col = col1;
        tile2.dataset.pos = pos1;

        // Clear selection
        selectedTile.classList.remove('selected');
        selectedTile = null;

        // Check for matches
        await sleep(250); // Wait for animation
        const matches = findMatches();

        if (matches.length > 0) {
            comboCount = 1; // Start combo counter
            updateComboDisplay();
            await processMatches(matches);
        } else {
            // Revert the swap if no matches
            swapInModel(pos1, pos2);
            tile1.style.left = style1.left;
            tile1.style.top = style1.top;
            tile2.style.left = style2.left;
            tile2.style.top = style2.top;
            tile1.dataset.row = row1;
            tile1.dataset.col = col1;
            tile1.dataset.pos = pos1;
            tile2.dataset.row = row2;
            tile2.dataset.col = col2;
            tile2.dataset.pos = pos2;
            await sleep(250); // Wait for animation
        }

        isProcessing = false;
    }

    async function handleSpecialTileSwap(row1, col1, row2, col2, isSpecial1, isSpecial2) {
        const pos1 = coordsToPosition(row1, col1);
        const pos2 = coordsToPosition(row2, col2);

        // Swap visually first
        const tile1 = document.querySelector(`.tile[data-pos="${pos1}"]`);
        const tile2 = document.querySelector(`.tile[data-pos="${pos2}"]`);
        const style1 = getPositionStyle(row1, col1);
        const style2 = getPositionStyle(row2, col2);

        tile1.style.left = style2.left;
        tile1.style.top = style2.top;
        tile2.style.left = style1.left;
        tile2.style.top = style1.top;

        // Update data attributes
        tile1.dataset.row = row2;
        tile1.dataset.col = col2;
        tile1.dataset.pos = pos2;
        tile2.dataset.row = row1;
        tile2.dataset.col = col1;
        tile2.dataset.pos = pos1;

        // Clear selection
        selectedTile.classList.remove('selected');
        selectedTile = null;

        await sleep(250); // Wait for animation

        // Handle special tile effects
        const tilesToClear = new Set();

        if (isSpecial1) {
            // Row/column clearer
            for (let i = 0; i < BOARD_SIZE; i++) {
                tilesToClear.add(coordsToPosition(row2, i)); // Clear row
                tilesToClear.add(coordsToPosition(i, col2)); // Clear column
            }
        }

        if (isSpecial2) {
            // Row/column clearer
            for (let i = 0; i < BOARD_SIZE; i++) {
                tilesToClear.add(coordsToPosition(row1, i)); // Clear row
                tilesToClear.add(coordsToPosition(i, col1)); // Clear column
            }
        }

        // Add bonus points for special tile
        const specialBonus = 50;
        score += specialBonus;
        scoreDisplay.textContent = score;
        updateProgressBar();

        // Show points popup
        const rect = tile1.getBoundingClientRect();
        const boardRect = gameBoard.getBoundingClientRect();
        const x = rect.left - boardRect.left + rect.width / 2;
        const y = rect.top - boardRect.top;
        showPointsPopup(specialBonus, x, y, true);

        // Process special tile effects
        for (const pos of tilesToClear) {
            const tile = document.querySelector(`.tile[data-pos="${pos}"]`);
            if (tile) {
                tile.classList.add('matching');
            }
        }

        await sleep(600); // Wait for animation

        // Remove matched tiles
        for (const pos of tilesToClear) {
            const tile = document.querySelector(`.tile[data-pos="${pos}"]`);
            if (tile) {
                gameBoard.removeChild(tile);
                board[pos] = null;
            }
        }

        // Drop tiles and fill empty spaces
        await dropTiles();

        // Check for cascading matches
        const newMatches = findMatches();
        if (newMatches.length > 0) {
            comboCount++;
            updateComboDisplay();
            await processMatches(newMatches);
        } else {
            comboCount = 0;
            updateComboDisplay();
        }

        // Check for level up
        if (score >= level * LEVEL_UP_SCORE) {
            levelUp();
        }
    }

    // Match Detection
    function findMatches() {
        const matches = new Set();

        // Check horizontal matches
        for (let row = 0; row < BOARD_SIZE; row++) {
            let matchCount = 1;
            let matchType = board[coordsToPosition(row, 0)];

            for (let col = 1; col < BOARD_SIZE; col++) {
                const pos = coordsToPosition(row, col);
                const currentType = board[pos];

                if (currentType === matchType && currentType !== null) {
                    matchCount++;
                } else {
                    // Check if we found a match (3+ in a row)
                    if (matchCount >= 3) {
                        for (let i = 0; i < matchCount; i++) {
                            matches.add(coordsToPosition(row, col - 1 - i));
                        }
                    }
                    // Reset match
                    matchCount = 1;
                    matchType = currentType;
                }
            }

            // Check end of row
            if (matchCount >= 3 && matchType !== null) {
                for (let i = 0; i < matchCount; i++) {
                    matches.add(coordsToPosition(row, BOARD_SIZE - 1 - i));
                }
            }
        }

        // Check vertical matches
        for (let col = 0; col < BOARD_SIZE; col++) {
            let matchCount = 1;
            let matchType = board[coordsToPosition(0, col)];

            for (let row = 1; row < BOARD_SIZE; row++) {
                const pos = coordsToPosition(row, col);
                const currentType = board[pos];

                if (currentType === matchType && currentType !== null) {
                    matchCount++;
                } else {
                    // Check if we found a match (3+ in a row)
                    if (matchCount >= 3) {
                        for (let i = 0; i < matchCount; i++) {
                            matches.add(coordsToPosition(row - 1 - i, col));
                        }
                    }
                    // Reset match
                    matchCount = 1;
                    matchType = currentType;
                }
            }

            // Check end of column
            if (matchCount >= 3 && matchType !== null) {
                for (let i = 0; i < matchCount; i++) {
                    matches.add(coordsToPosition(BOARD_SIZE - 1 - i, col));
                }
            }
        }

        return Array.from(matches);
    }

    // Processing Matches and Cascading
    async function processMatches(matches) {
        if (matches.length === 0) return;

        timeLeft += matches.length;

        // Track match patterns for special tiles
        const matchPatterns = findMatchPatterns(matches);
        const specialTilePositions = [];

        // Calculate points with combo multiplier
        const basePoints = matches.length * MATCH_POINTS;
        const comboBonus = comboCount > 1 ? Math.floor(basePoints * (comboCount * COMBO_MULTIPLIER - 1)) : 0;
        const pointsEarned = basePoints + comboBonus;

        // Update score
        score += pointsEarned;
        scoreDisplay.textContent = score;
        updateProgressBar();

        // Show points popup
        if (matches.length > 0) {
            const firstMatchPos = matches[0];
            const {row, col} = positionToCoords(firstMatchPos);
            const tile = document.querySelector(`.tile[data-pos="${firstMatchPos}"]`);

            if (tile) {
                const rect = tile.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();
                const x = rect.left - boardRect.left + rect.width / 2;
                const y = rect.top - boardRect.top;
                showPointsPopup(pointsEarned, x, y, comboCount > 1);
            }
        }

        // Level up if needed
        if (score >= level * LEVEL_UP_SCORE) {
            levelUp();
        }

        // Animate and remove matches
        for (const pos of matches) {
            const tile = document.querySelector(`.tile[data-pos="${pos}"]`);
            if (tile) {
                tile.classList.add('matching');
            }
        }

        await sleep(600); // Wait for animation

        // Remove matched tiles
        for (const pos of matches) {
            const tile = document.querySelector(`.tile[data-pos="${pos}"]`);
            if (tile) {
                gameBoard.removeChild(tile);
            }
        }

        // Create special tiles based on match patterns
        for (const pattern of matchPatterns) {
            if (pattern.length >= 4) {
                // Get a position for the special tile (preferably the swap position)
                const specialPos = pattern[Math.floor(pattern.length / 2)];
                const {row, col} = positionToCoords(specialPos);
                specialTilePositions.push({row, col, pos: specialPos});
            }
        }

        // Mark matched positions as empty in the board
        for (const pos of matches) {
            board[pos] = null;
        }

        // Drop tiles and fill empty spaces
        await dropTiles(specialTilePositions);

        // Check for cascading matches
        const newMatches = findMatches();
        if (newMatches.length > 0) {
            comboCount++;
            updateComboDisplay();
            await processMatches(newMatches);
        } else {
            comboCount = 0;
            updateComboDisplay();
        }
    }

    function findMatchPatterns(matches) {
        const patterns = [];
        const visited = new Set();

        // For each match position
        for (const pos of matches) {
            if (visited.has(pos)) continue;

            const {row, col} = positionToCoords(pos);
            const emoji = board[pos];
            const pattern = [];

            // Build horizontal pattern
            let hCount = 0;
            for (let c = col; c < BOARD_SIZE; c++) {
                const p = coordsToPosition(row, c);
                if (matches.includes(p) && board[p] === emoji && !visited.has(p)) {
                    pattern.push(p);
                    visited.add(p);
                    hCount++;
                } else {
                    break;
                }
            }

            // Build vertical pattern
            let vCount = 0;
            for (let r = row; r < BOARD_SIZE; r++) {
                const p = coordsToPosition(r, col);
                if (matches.includes(p) && board[p] === emoji && !visited.has(p)) {
                    if (r > row) { // Don't double-count the intersection point
                        pattern.push(p);
                        visited.add(p);
                    }
                    vCount++;
                } else {
                    break;
                }
            }

            if (pattern.length >= 3) {
                patterns.push(pattern);
            }
        }

        return patterns;
    }

    async function dropTiles(specialTilePositions = []) {
        // Process column by column
        for (let col = 0; col < BOARD_SIZE; col++) {
            // Count empty slots in each column
            const emptySlots = [];
            for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                const pos = coordsToPosition(row, col);
                if (board[pos] === null) {
                    emptySlots.push(row);
                } else if (emptySlots.length > 0) {
                    // Move this tile down to the lowest empty slot
                    const newRow = emptySlots.shift();
                    const oldPos = coordsToPosition(row, col);
                    const newPos = coordsToPosition(newRow, col);

                    // Update data model
                    board[newPos] = board[oldPos];
                    board[oldPos] = null;

                    // Move tile visually
                    const tile = document.querySelector(`.tile[data-pos="${oldPos}"]`);
                    if (tile) {
                        const style = getPositionStyle(newRow, col);
                        tile.style.top = style.top;

                        // Update data attributes
                        tile.dataset.row = newRow;
                        tile.dataset.pos = newPos;
                    }

                    // Add the current position as a new empty slot
                    emptySlots.push(row);

                    // Sort empty slots to maintain descending order
                    emptySlots.sort((a, b) => b - a);
                }
            }

            // Fill top empty slots with new tiles
            for (const row of emptySlots) {
                const pos = coordsToPosition(row, col);

                // Check if this should be a special tile
                const specialTileIndex = specialTilePositions.findIndex(st => st.pos === pos);
                const isSpecial = specialTileIndex !== -1;

                if (isSpecial) {
                    // Create special tile
                    const emoji = getSpecialEmoji();
                    board[pos] = emoji;

                    // Remove from the list
                    specialTilePositions.splice(specialTileIndex, 1);

                    // Create new tile starting above the board
                    const tile = createTile(emoji, -1, col, true);
                    gameBoard.appendChild(tile);

                    // Set final position (with delay for animation)
                    setTimeout(() => {
                        const style = getPositionStyle(row, col);
                        tile.style.top = style.top;
                        tile.dataset.row = row;
                        tile.dataset.pos = pos;
                    }, 10);
                } else {
                    // Create normal tile
                    const emoji = getRandomEmoji();
                    board[pos] = emoji;

                    // Create new tile starting above the board
                    const tile = createTile(emoji, -1, col);
                    gameBoard.appendChild(tile);

                    // Set final position (with delay for animation)
                    setTimeout(() => {
                        const style = getPositionStyle(row, col);
                        tile.style.top = style.top;
                        tile.dataset.row = row;
                        tile.dataset.pos = pos;
                    }, 10);
                }
            }
        }

        // Wait for animations to complete
        await sleep(400);
    }

    // Initialize the game
    init();
</script>
</body>
</html>