<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="description" content="Play QIX Territory - a modern browser recreation of the classic arcade game. Claim territory by drawing lines while avoiding the Qix and Sparx. Keyboard and touch controls supported.">
    <meta name="author" content="Claude Opus 4.6 prompted by Tobias Müller">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/qix.html">
    <meta property="og:title" content="QIX Territory - Classic Arcade Game">
    <meta property="og:description" content="Play QIX Territory - a modern browser recreation of the classic arcade game. Claim territory by drawing lines while avoiding the Qix and Sparx.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/qix.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_251.webp">
    <meta property="og:image:alt" content="QIX Territory gameplay screenshot">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="QIX Territory - Classic Arcade Game">
    <meta name="twitter:description" content="Play QIX Territory - a modern browser recreation of the classic arcade game. Claim territory by drawing lines while avoiding the Qix and Sparx.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_251.webp">
    <title>QIX</title>
    <style>* {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    body {
        background: #0a0a12;
        overflow: hidden;
        font-family: 'Courier New', monospace;
        color: #dfe6e9;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100vw;
        touch-action: none;
        user-select: none
    }

    canvas {
        display: block;
        position: relative;
        z-index: 1
    }

    .ov {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        background: rgba(10, 10, 18, 0.93)
    }

    .ov.hid {
        display: none
    }

    .pnl {
        text-align: center;
        max-width: 440px;
        padding: 40px
    }

    .pnl h1 {
        font-size: 68px;
        letter-spacing: 18px;
        color: #ffeaa7;
        margin-bottom: 6px;
        font-weight: 900
    }

    .pnl h2 {
        font-size: 26px;
        letter-spacing: 6px;
        color: #74b9ff;
        margin-bottom: 28px;
        font-weight: 400
    }

    .pnl p {
        font-size: 13px;
        color: #636e72;
        line-height: 1.9;
        margin-bottom: 4px
    }

    .kbd {
        display: inline-block;
        background: #16162a;
        padding: 2px 8px;
        border-radius: 3px;
        color: #dfe6e9;
        font-size: 12px;
        margin: 0 2px
    }

    .btn {
        display: inline-block;
        margin-top: 24px;
        padding: 14px 48px;
        background: #ffeaa7;
        color: #0a0a12;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 4px;
        border: none;
        cursor: pointer
    }

    .btn:hover {
        opacity: 0.9
    }

    .btn:active {
        transform: scale(0.97)
    }

    .sc {
        font-size: 48px;
        color: #ffeaa7;
        letter-spacing: 4px;
        margin: 14px 0
    }

    .sr {
        font-size: 14px;
        color: #636e72;
        margin: 4px 0
    }

    .sr span {
        color: #dfe6e9
    }

    .hint {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: #16162a;
        padding: 10px 20px;
        border-radius: 4px;
        font-size: 11px;
        color: #636e72;
        z-index: 5;
        transition: opacity 0.5s
    }

    .hint.hid {
        opacity: 0;
        pointer-events: none
    }</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="menu" class="ov">
    <div class="pnl"><h1>QIX</h1>
        <h2>TERRITORY</h2>
        <p><span class="kbd">↑↓←→</span>or<span class="kbd">WASD</span>to move</p>
        <p>Hold<span class="kbd">SHIFT</span>for slow draw (2× points)</p>
        <p>Draw lines back to the border to claim territory</p>
        <p style="color:#00b894;margin-top:10px">Claim the target % to advance. Don't touch the Qix!</p>
        <button class="btn" id="startBtn">START</button>
    </div>
</div>
<div id="gameover" class="ov hid">
    <div class="pnl"><h2>GAME OVER</h2>
        <div class="sc" id="fScore">0</div>
        <div class="sr">Level <span id="fLvl">1</span></div>
        <div class="sr">Territory <span id="fPct">0%</span></div>
        <button class="btn" id="restartBtn">RESTART</button>
    </div>
</div>
<div id="lvlUp" class="ov hid">
    <div class="pnl"><h2 id="lvlTxt">LEVEL COMPLETE</h2>
        <div class="sc" id="lvlBonus">+0</div>
        <p id="lvlNext" style="color:#00b894"></p></div>
</div>
<div class="hint" id="hint">Arrow keys / WASD to move · SHIFT = slow draw · Swipe on mobile</div>
<script>(() => {
    const W = 300, H = 220;
    const C_NONE = [10, 10, 18], C_BORDER = [28, 28, 50], C_SLOW = [0, 184, 148], C_FAST = [225, 112, 85],
        C_STIX = [116, 185, 255];
    const cv = document.getElementById('c'), ctx = cv.getContext('2d');
    const ob = document.createElement('canvas');
    ob.width = W;
    ob.height = H;
    const oc = ob.getContext('2d');
    let grid = new Uint8Array(W * H), gDirty = true;
    let sc = 1, ox = 0, oy = 0, hudH = 42;
    let aCtx = null;

    function iAudio() {
        if (!aCtx) try {
            aCtx = new (window.AudioContext || window.webkitAudioContext)
        } catch (e) {
        }
    }

    function tone(f, d, t = 'square', v = 0.08, sl = 0) {
        if (!aCtx) return;
        try {
            const o = aCtx.createOscillator(), g = aCtx.createGain();
            o.type = t;
            o.frequency.setValueAtTime(f, aCtx.currentTime);
            if (sl) o.frequency.linearRampToValueAtTime(f + sl, aCtx.currentTime + d);
            g.gain.setValueAtTime(v, aCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, aCtx.currentTime + d);
            o.connect(g);
            g.connect(aCtx.destination);
            o.start();
            o.stop(aCtx.currentTime + d)
        } catch (e) {
        }
    }

    function sndDraw() {
        tone(180, 0.05, 'sawtooth', 0.03)
    }

    function sndClaim() {
        tone(440, 0.15, 'sine', 0.1, 300);
        setTimeout(() => tone(660, 0.15, 'sine', 0.08, 200), 80);
        setTimeout(() => tone(880, 0.2, 'sine', 0.07), 160)
    }

    function sndDie() {
        tone(200, 0.4, 'sawtooth', 0.12, -150);
        setTimeout(() => tone(120, 0.5, 'square', 0.08, -80), 100)
    }

    function sndLvl() {
        for (let i = 0; i < 5; i++) setTimeout(() => tone(440 + i * 110, 0.15, 'sine', 0.08), i * 80)
    }

    function sndFuse() {
        tone(800, 0.06, 'square', 0.05)
    }

    let state = 'MENU', level = 1, lives = 3, score = 0, claimed = 0, target = 65, fc = 0;
    let spawnProtect = 0;
    let drawGrace = 0; // BUG1 FIX: grace period after starting to draw
    let pl = {x: 0, y: 0, drawing: false, slow: false, stix: []};
    let qix = {pts: [], vels: [], trail: []};
    let sparx = [];
    let fuse = {active: false, idx: 0, timer: 0};
    let shake = 0, flash = 0, deathT = 0, lvlT = 0;
    let inDir = {dx: 0, dy: 0};
    let keys = {};
    let hintVis = true;
    let touchSt = null;

    function gI(x, y) {
        return y * W + x
    }

    function inB(x, y) {
        return x >= 0 && x < W && y >= 0 && y < H
    }

    function gG(x, y) {
        return inB(x, y) ? grid[gI(x, y)] : 1
    }

    function gS(x, y, v) {
        if (inB(x, y)) {
            grid[gI(x, y)] = v;
            gDirty = true
        }
    }

    function isCl(x, y) {
        let v = gG(x, y);
        return v >= 1 && v <= 3
    }

    function isUn(x, y) {
        return inB(x, y) && grid[gI(x, y)] === 0
    }

    function isSt(x, y) {
        return gG(x, y) === 4
    }

// BUG2+3 FIX: New traversal function replaces isBrd for movement.
// Cells on the grid edge are always traversable (fixes corner problem for sparx).
// Interior claimed cells need an orthogonal unclaimed neighbor to count.
    function canTraverse(x, y) {
        if (!inB(x, y) || !isCl(x, y)) return false;
        if (x === 0 || x === W - 1 || y === 0 || y === H - 1) return true;
        return isUn(x - 1, y) || isUn(x + 1, y) || isUn(x, y - 1) || isUn(x, y + 1);
    }

// BUG3 FIX: Find nearest traversable cell for respawn
    function findSpawn() {
        const cx = Math.floor(W / 2), cy = H - 1;
        if (canTraverse(cx, cy)) return {x: cx, y: cy};
        // Spiral outward from default spawn along the bottom edge first, then expand
        for (let r = 1; r < Math.max(W, H); r++) {
            // Prioritize bottom border
            for (let dx = -r; dx <= r; dx++) {
                const nx = cx + dx, ny = cy;
                if (canTraverse(nx, ny)) return {x: nx, y: ny};
            }
            // Then other borders
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                    const nx = cx + dx, ny = cy + dy;
                    if (canTraverse(nx, ny)) return {x: nx, y: ny};
                }
            }
        }
        return {x: cx, y: cy};
    }

    function resize() {
        const mw = window.innerWidth, mh = window.innerHeight - hudH;
        const ar = W / H;
        if (mw / mh > ar) {
            sc = mh / H;
            ox = (mw - W * sc) / 2;
            oy = hudH
        } else {
            sc = mw / W;
            ox = 0;
            oy = (mh - H * sc) / 2 + hudH
        }
        cv.width = window.innerWidth;
        cv.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    function initGrid() {
        grid.fill(0);
        for (let x = 0; x < W; x++) {
            gS(x, 0, 1);
            gS(x, H - 1, 1)
        }
        for (let y = 0; y < H; y++) {
            gS(0, y, 1);
            gS(W - 1, y, 1)
        }
        gDirty = true;
    }

    function initQix() {
        const mx = W / 2, my = H / 2;
        qix.pts = [];
        qix.vels = [];
        qix.trail = [];
        for (let i = 0; i < 8; i++) {
            qix.pts.push({x: mx + (Math.random() - 0.5) * 60, y: my + (Math.random() - 0.5) * 40});
            qix.vels.push({vx: (Math.random() - 0.5) * 1.5, vy: (Math.random() - 0.5) * 1.5});
        }
    }

    function initSparx(n) {
        sparx = [];
        for (let i = 0; i < n; i++) {
            // BUG2 FIX: Spawn sparx at known good border positions (not corners)
            // and assign alternating CW/CCW directions
            const side = Math.floor(Math.random() * 4);
            let x, y, dx, dy;
            if (side === 0) {
                x = Math.floor(Math.random() * (W - 4)) + 2;
                y = 0;
                dx = (i % 2 === 0) ? 1 : -1;
                dy = 0;
            } else if (side === 1) {
                x = W - 1;
                y = Math.floor(Math.random() * (H - 4)) + 2;
                dx = 0;
                dy = (i % 2 === 0) ? 1 : -1;
            } else if (side === 2) {
                x = Math.floor(Math.random() * (W - 4)) + 2;
                y = H - 1;
                dx = (i % 2 === 0) ? -1 : 1;
                dy = 0;
            } else {
                x = 0;
                y = Math.floor(Math.random() * (H - 4)) + 2;
                dx = 0;
                dy = (i % 2 === 0) ? -1 : 1;
            }
            sparx.push({x, y, dx, dy, speed: 0.8 + level * 0.1, cw: i % 2 === 0});
        }
    }

    function startLevel() {
        initGrid();
        initQix();
        initSparx(Math.min(1 + Math.floor(level / 2), 5));
        pl.x = Math.floor(W / 2);
        pl.y = H - 1;
        pl.drawing = false;
        pl.stix = [];
        pl.slow = false;
        fuse.active = false;
        fuse.timer = 0;
        drawGrace = 0;
        target = Math.min(60 + level * 5, 85);
        claimed = 0;
        inDir = {dx: 0, dy: 0};
        spawnProtect = 60;
        state = 'PLAYING';
        gDirty = true;
    }

    function claimTerritory() {
        const fv = pl.slow ? 2 : 3;
        for (const p of pl.stix) gS(p.x, p.y, fv);

        // Flood-fill from qix side to find which unclaimed region contains the qix
        let sx = -1, sy = -1;
        for (const p of qix.pts) {
            const gx = Math.round(p.x), gy = Math.round(p.y);
            if (inB(gx, gy) && gG(gx, gy) === 0) {
                sx = gx;
                sy = gy;
                break;
            }
        }
        if (sx < 0) {
            for (const p of qix.pts) {
                const cx2 = Math.round(p.x), cy2 = Math.round(p.y);
                let found = false;
                for (let r = 1; r < 40 && !found; r++) {
                    for (let ddx = -r; ddx <= r && !found; ddx++) {
                        for (let ddy = -r; ddy <= r && !found; ddy++) {
                            const nx = cx2 + ddx, ny = cy2 + ddy;
                            if (inB(nx, ny) && gG(nx, ny) === 0) {
                                sx = nx;
                                sy = ny;
                                found = true
                            }
                        }
                    }
                }
                if (found) break;
            }
        }
        if (sx < 0) {
            for (let i = 0; i < W * H; i++) if (grid[i] === 0) grid[i] = fv;
        } else {
            const q = [gI(sx, sy)];
            grid[gI(sx, sy)] = 5;
            let head = 0;
            while (head < q.length) {
                const idx = q[head++];
                const x2 = idx % W, y2 = (idx / W) | 0;
                const nb = [[x2 - 1, y2], [x2 + 1, y2], [x2, y2 - 1], [x2, y2 + 1]];
                for (const [nx, ny] of nb) {
                    if (inB(nx, ny)) {
                        const ni = gI(nx, ny);
                        if (grid[ni] === 0) {
                            grid[ni] = 5;
                            q.push(ni)
                        }
                    }
                }
            }
            let area = 0;
            for (let i = 0; i < W * H; i++) {
                if (grid[i] === 0) {
                    grid[i] = fv;
                    area++
                } else if (grid[i] === 5) grid[i] = 0;
            }
            const mult = pl.slow ? 2 : 1;
            score += area * mult * level;
        }

        const interior = (W - 2) * (H - 2);
        let cc = 0;
        for (let y = 1; y < H - 1; y++) for (let x = 1; x < W - 1; x++) if (grid[gI(x, y)] >= 2) cc++;
        claimed = Math.round(cc / interior * 100);
        pl.stix = [];
        pl.drawing = false;
        fuse.active = false;
        fuse.timer = 0;
        drawGrace = 0;
        gDirty = true;
        sndClaim();
        flash = 14;

        if (claimed >= target) {
            lvlT = 120;
            state = 'LEVEL_COMPLETE';
            const bonus = claimed * 10 * level;
            score += bonus;
            sndLvl();
            document.getElementById('lvlTxt').textContent = 'LEVEL ' + level + ' COMPLETE';
            document.getElementById('lvlBonus').textContent = '+' + bonus;
            document.getElementById('lvlNext').textContent = 'Next: Level ' + (level + 1) + ' · Target ' + Math.min(60 + (level + 1) * 5, 85) + '%';
            document.getElementById('lvlUp').classList.remove('hid');
        }
    }

    function playerDie() {
        if (state === 'DYING' || state === 'GAME_OVER' || state === 'LEVEL_COMPLETE') return;
        lives--;
        sndDie();
        shake = 20;
        for (const p of pl.stix) gS(p.x, p.y, 0);
        pl.stix = [];
        pl.drawing = false;
        fuse.active = false;
        fuse.timer = 0;
        drawGrace = 0;
        state = 'DYING';
        deathT = 90;
        gDirty = true;
    }

// BUG2 FIX: Completely rewritten sparx movement
// Uses proper wall-following with canTraverse instead of isBrd
    function moveSparxOne(s) {
        // Wall-following: CW sparx use right-hand rule, CCW use left-hand rule
        let dirs;
        if (s.cw) {
            // Right-hand rule: try right, straight, left, reverse
            dirs = [
                {dx: -s.dy, dy: s.dx},   // right turn
                {dx: s.dx, dy: s.dy},     // straight
                {dx: s.dy, dy: -s.dx},    // left turn
                {dx: -s.dx, dy: -s.dy}    // reverse
            ];
        } else {
            // Left-hand rule: try left, straight, right, reverse
            dirs = [
                {dx: s.dy, dy: -s.dx},    // left turn
                {dx: s.dx, dy: s.dy},      // straight
                {dx: -s.dy, dy: s.dx},     // right turn
                {dx: -s.dx, dy: -s.dy}     // reverse
            ];
        }

        for (const d of dirs) {
            const nx = s.x + d.dx, ny = s.y + d.dy;
            if (canTraverse(nx, ny)) {
                s.x = nx;
                s.y = ny;
                s.dx = d.dx;
                s.dy = d.dy;
                return;
            }
        }

        // Absolute fallback: try any traversable neighbor
        for (const [ddx, ddy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
            const nx = s.x + ddx, ny = s.y + ddy;
            if (canTraverse(nx, ny)) {
                s.x = nx;
                s.y = ny;
                s.dx = ddx;
                s.dy = ddy;
                return;
            }
        }
    }

    function updateSparx() {
        if (state !== 'PLAYING' && state !== 'DRAWING') return;
        for (const s of sparx) {
            const steps = Math.ceil(s.speed);
            for (let st = 0; st < steps; st++) {
                if (state === 'DYING') return;
                moveSparxOne(s);
                if (spawnProtect <= 0 && s.x === pl.x && s.y === pl.y) {
                    playerDie();
                    return;
                }
            }
        }
    }

// BUG1 FIX: Qix stays strictly in unclaimed territory
    function updateQix() {
        const spd = 1 + level * 0.25;
        for (let i = 0; i < qix.pts.length; i++) {
            const p = qix.pts[i], v = qix.vels[i];
            v.vx += (Math.random() - 0.5) * 0.4;
            v.vy += (Math.random() - 0.5) * 0.4;
            const mag = Math.sqrt(v.vx * v.vx + v.vy * v.vy);
            if (mag > spd) {
                v.vx = v.vx / mag * spd;
                v.vy = v.vy / mag * spd
            }

            let nx = p.x + v.vx, ny = p.y + v.vy;

            // Check X movement
            const gxn = Math.round(nx), gyo = Math.round(p.y);
            if (!inB(gxn, gyo) || gG(gxn, gyo) !== 0) {
                v.vx = -v.vx;
                nx = p.x + v.vx;
            }
            // Check Y movement
            const gxo = Math.round(p.x), gyn = Math.round(ny);
            if (!inB(gxo, gyn) || gG(gxo, gyn) !== 0) {
                v.vy = -v.vy;
                ny = p.y + v.vy;
            }

            // Final validation: ensure destination cell is unclaimed
            const fgx = Math.round(nx), fgy = Math.round(ny);
            if (!inB(fgx, fgy) || gG(fgx, fgy) !== 0) {
                // Reject move entirely, add random perturbation to escape
                v.vx = (Math.random() - 0.5) * spd;
                v.vy = (Math.random() - 0.5) * spd;
                // Don't update position
            } else {
                p.x = Math.max(1.5, Math.min(W - 2.5, nx));
                p.y = Math.max(1.5, Math.min(H - 2.5, ny));
            }
        }

        if (fc % 2 === 0) {
            qix.trail.push(qix.pts.map(p => ({x: p.x, y: p.y})));
            if (qix.trail.length > 14) qix.trail.shift();
        }
    }

    function updateFuse() {
        if (!pl.drawing || pl.stix.length < 2) return;
        if (inDir.dx === 0 && inDir.dy === 0) {
            fuse.timer++;
            if (fuse.timer > 40 && !fuse.active) {
                fuse.active = true;
                fuse.idx = 0
            }
            if (fuse.active) {
                fuse.idx += 2;
                if (fc % 4 === 0) sndFuse();
                if (fuse.idx >= pl.stix.length - 1) playerDie();
            }
        } else {
            fuse.active = false;
            fuse.timer = 0;
            fuse.idx = 0;
        }
    }

// BUG1 FIX: More precise Qix collision detection
// Only checks actual Qix control points (not dense interpolation),
// and respects a grace period after the player starts drawing.
    function checkQixCol() {
        if (state !== 'DRAWING' || !pl.drawing) return;
        if (drawGrace > 0) {
            drawGrace--;
            return;
        }

        // Check each Qix line segment against stix cells and player
        for (let i = 0; i < qix.pts.length - 1; i++) {
            const a = qix.pts[i], b = qix.pts[i + 1];
            const dist = Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
            // Use fewer interpolation steps (every ~2 pixels instead of every pixel)
            const steps = Math.max(1, Math.ceil(dist / 2));
            for (let t = 0; t <= steps; t++) {
                if (state !== 'DRAWING') return;
                const fr = steps === 0 ? 0 : t / steps;
                const fx = a.x + (b.x - a.x) * fr;
                const fy = a.y + (b.y - a.y) * fr;
                const px = Math.round(fx), py = Math.round(fy);

                if (!inB(px, py)) continue;

                // Check stix collision: require the floating-point position to be
                // genuinely close to the cell center (within 0.7), not just rounded there
                if (gG(px, py) === 4) {
                    const cellDist = Math.abs(fx - px) + Math.abs(fy - py);
                    if (cellDist < 0.7) {
                        playerDie();
                        return;
                    }
                }
                // Check player collision with same proximity requirement
                if (px === pl.x && py === pl.y) {
                    const plDist = Math.abs(fx - pl.x) + Math.abs(fy - pl.y);
                    if (plDist < 0.9) {
                        playerDie();
                        return;
                    }
                }
            }
        }
    }

    function setDir(dx, dy) {
        if (pl.drawing && pl.stix.length >= 2) {
            const last = pl.stix[pl.stix.length - 1], prev = pl.stix[pl.stix.length - 2];
            const rdx = last.x - prev.x, rdy = last.y - prev.y;
            if (rdx !== 0 && dx === -Math.sign(rdx) && dy === 0) return;
            if (rdy !== 0 && dy === -Math.sign(rdy) && dx === 0) return;
        }
        inDir.dx = dx;
        inDir.dy = dy;
    }

// BUG3 FIX: Player movement uses canTraverse instead of isBrd
    function updatePlayer() {
        if (state !== 'PLAYING' && state !== 'DRAWING') return;
        if (spawnProtect > 0) spawnProtect--;
        const dir = {...inDir};
        if (dir.dx !== 0 && dir.dy !== 0) dir.dy = 0;
        const spd = pl.drawing ? (pl.slow ? 1 : 2) : 2;
        for (let s = 0; s < spd; s++) {
            if (state !== 'PLAYING' && state !== 'DRAWING') return;
            if (dir.dx === 0 && dir.dy === 0) break;
            const nx = pl.x + dir.dx, ny = pl.y + dir.dy;
            if (!inB(nx, ny)) break;
            if (pl.drawing) {
                if (isSt(nx, ny)) {
                    playerDie();
                    return
                }
                if (isCl(nx, ny)) {
                    pl.x = nx;
                    pl.y = ny;
                    claimTerritory();
                    return;
                }
                if (gG(nx, ny) === 0) {
                    pl.x = nx;
                    pl.y = ny;
                    pl.stix.push({x: nx, y: ny});
                    gS(nx, ny, 4);
                    if (fc % 4 === 0) sndDraw();
                }
            } else {
                if (gG(nx, ny) === 0) {
                    pl.drawing = true;
                    state = 'DRAWING';
                    pl.slow = !!(keys['ShiftLeft'] || keys['ShiftRight']);
                    pl.stix = [{x: pl.x, y: pl.y}, {x: nx, y: ny}];
                    gS(nx, ny, 4);
                    pl.x = nx;
                    pl.y = ny;
                    drawGrace = 12; // BUG1 FIX: grace frames before qix collision activates
                    sndDraw();
                } else if (canTraverse(nx, ny)) {
                    pl.x = nx;
                    pl.y = ny;
                }
            }
        }
    }

    function renderTerr() {
        if (!gDirty) return;
        const id = oc.createImageData(W, H), d = id.data;
        for (let i = 0; i < W * H; i++) {
            const v = grid[i];
            let c = v === 0 ? C_NONE : v === 1 ? C_BORDER : v === 2 ? C_SLOW : v === 3 ? C_FAST : C_STIX;
            d[i * 4] = c[0];
            d[i * 4 + 1] = c[1];
            d[i * 4 + 2] = c[2];
            d[i * 4 + 3] = 255;
        }
        oc.putImageData(id, 0, 0);
        gDirty = false;
    }

    function toC(x, y) {
        return [ox + x * sc, oy + y * sc]
    }

    function render() {
        ctx.clearRect(0, 0, cv.width, cv.height);
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, cv.width, cv.height);
        let sx2 = 0, sy2 = 0;
        if (shake > 0) {
            sx2 = (Math.random() - 0.5) * shake * 0.8;
            sy2 = (Math.random() - 0.5) * shake * 0.8;
            shake--
        }
        ctx.save();
        ctx.translate(sx2, sy2);
        renderTerr();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(ob, ox, oy, W * sc, H * sc);
        if (flash > 0) {
            ctx.fillStyle = 'rgba(255,255,255,' + (flash / 20) + ')';
            ctx.fillRect(ox, oy, W * sc, H * sc);
            flash--
        }

        // Stix line
        if (pl.stix.length > 1) {
            ctx.strokeStyle = 'rgba(116,185,255,' + (0.6 + 0.4 * Math.sin(fc * 0.2)) + ')';
            ctx.lineWidth = Math.max(2, sc * 0.8);
            ctx.beginPath();
            let s0 = toC(pl.stix[0].x + 0.5, pl.stix[0].y + 0.5);
            ctx.moveTo(s0[0], s0[1]);
            for (let i = 1; i < pl.stix.length; i++) {
                let sp = toC(pl.stix[i].x + 0.5, pl.stix[i].y + 0.5);
                ctx.lineTo(sp[0], sp[1])
            }
            ctx.stroke();
            if (fuse.active && fuse.idx < pl.stix.length) {
                ctx.strokeStyle = 'rgba(253,203,110,' + (0.7 + 0.3 * Math.sin(fc * 0.5)) + ')';
                ctx.lineWidth = Math.max(3, sc * 1.2);
                ctx.beginPath();
                let f0 = toC(pl.stix[0].x + 0.5, pl.stix[0].y + 0.5);
                ctx.moveTo(f0[0], f0[1]);
                const end = Math.min(fuse.idx, pl.stix.length - 1);
                for (let i = 1; i <= end; i++) {
                    let fp = toC(pl.stix[i].x + 0.5, pl.stix[i].y + 0.5);
                    ctx.lineTo(fp[0], fp[1])
                }
                ctx.stroke();
                if (end > 0) {
                    const fh = toC(pl.stix[end].x + 0.5, pl.stix[end].y + 0.5);
                    ctx.fillStyle = '#fdcb6e';
                    ctx.beginPath();
                    ctx.arc(fh[0], fh[1], sc * 2.5, 0, Math.PI * 2);
                    ctx.fill()
                }
            }
        }

        // Qix trail
        for (let t = 0; t < qix.trail.length; t++) {
            const al = (t / qix.trail.length) * 0.3;
            const pts = qix.trail[t];
            if (pts.length < 2) continue;
            ctx.strokeStyle = 'rgba(200,200,255,' + al + ')';
            ctx.lineWidth = Math.max(1, sc * 0.5);
            ctx.beginPath();
            let q0 = toC(pts[0].x + 0.5, pts[0].y + 0.5);
            ctx.moveTo(q0[0], q0[1]);
            for (let i = 1; i < pts.length; i++) {
                let qp = toC(pts[i].x + 0.5, pts[i].y + 0.5);
                ctx.lineTo(qp[0], qp[1])
            }
            ctx.stroke();
        }

        // Qix body
        if (qix.pts.length > 1) {
            const hue = (fc * 3) % 360;
            ctx.lineWidth = Math.max(3, sc * 1.2);
            for (let i = 0; i < qix.pts.length - 1; i++) {
                const sh = (hue + i * 45) % 360;
                ctx.strokeStyle = 'hsl(' + sh + ',100%,65%)';
                ctx.beginPath();
                let qa = toC(qix.pts[i].x + 0.5, qix.pts[i].y + 0.5);
                let qb = toC(qix.pts[i + 1].x + 0.5, qix.pts[i + 1].y + 0.5);
                ctx.moveTo(qa[0], qa[1]);
                ctx.lineTo(qb[0], qb[1]);
                ctx.stroke();
            }
            for (let i = 0; i < qix.pts.length; i++) {
                const sh = (hue + i * 45) % 360;
                const qp = toC(qix.pts[i].x + 0.5, qix.pts[i].y + 0.5);
                ctx.fillStyle = 'hsl(' + sh + ',100%,75%)';
                ctx.beginPath();
                ctx.arc(qp[0], qp[1], Math.max(2, sc * 1), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Sparx
        for (const s of sparx) {
            const sp = toC(s.x + 0.5, s.y + 0.5);
            const pulse = 0.8 + 0.2 * Math.sin(fc * 0.3 + s.x);
            ctx.fillStyle = 'rgba(255,107,107,' + pulse + ')';
            const r = Math.max(3, sc * 1.3);
            ctx.beginPath();
            ctx.moveTo(sp[0], sp[1] - r);
            ctx.lineTo(sp[0] + r, sp[1]);
            ctx.lineTo(sp[0], sp[1] + r);
            ctx.lineTo(sp[0] - r, sp[1]);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(255,220,220,0.9)';
            const ri = r * 0.4;
            ctx.beginPath();
            ctx.moveTo(sp[0], sp[1] - ri);
            ctx.lineTo(sp[0] + ri, sp[1]);
            ctx.lineTo(sp[0], sp[1] + ri);
            ctx.lineTo(sp[0] - ri, sp[1]);
            ctx.closePath();
            ctx.fill();
        }

        // Player
        if (state !== 'DYING' || fc % 6 < 4) {
            const pp = toC(pl.x + 0.5, pl.y + 0.5);
            const pr = Math.max(4, sc * 1.5);
            const ppulse = pl.drawing ? 0.7 + 0.3 * Math.sin(fc * 0.15) : 1;
            ctx.fillStyle = 'rgba(255,234,167,' + ppulse + ')';
            ctx.beginPath();
            ctx.moveTo(pp[0], pp[1] - pr);
            ctx.lineTo(pp[0] + pr, pp[1]);
            ctx.lineTo(pp[0], pp[1] + pr);
            ctx.lineTo(pp[0] - pr, pp[1]);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,200,50,0.8)';
            ctx.lineWidth = Math.max(1, sc * 0.4);
            ctx.stroke();
        }

        // Death burst
        if (state === 'DYING' && deathT > 50) {
            const pp = toC(pl.x + 0.5, pl.y + 0.5);
            const da = (deathT - 50) / 40;
            ctx.strokeStyle = 'rgba(255,100,100,' + da + ')';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const ang = i * Math.PI / 4 + fc * 0.1;
                const dist = (90 - deathT) * 2.5;
                ctx.beginPath();
                ctx.moveTo(pp[0] + Math.cos(ang) * dist * sc * 0.04, pp[1] + Math.sin(ang) * dist * sc * 0.04);
                ctx.lineTo(pp[0] + Math.cos(ang) * (dist + 12) * sc * 0.04, pp[1] + Math.sin(ang) * (dist + 12) * sc * 0.04);
                ctx.stroke();
            }
        }
        ctx.restore();

        // HUD
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, cv.width, hudH);
        ctx.fillStyle = '#16162a';
        ctx.fillRect(0, hudH - 1, cv.width, 1);
        const fs = Math.max(13, Math.min(16, cv.width / 50));
        ctx.font = 'bold ' + fs + 'px Courier New,monospace';
        ctx.textBaseline = 'middle';
        const cy2 = hudH / 2;
        ctx.fillStyle = '#636e72';
        ctx.textAlign = 'left';
        ctx.fillText('LVL', 12, cy2);
        ctx.fillStyle = '#dfe6e9';
        ctx.fillText('' + level, 12 + fs * 2.5, cy2);
        if (pl.drawing) {
            ctx.font = (fs * 0.8) + 'px Courier New,monospace';
            ctx.fillStyle = pl.slow ? '#00b894' : '#e17055';
            ctx.fillText(pl.slow ? 'SLOW' : 'FAST', 12 + fs * 4.5, cy2)
        }
        ctx.font = 'bold ' + fs + 'px Courier New,monospace';
        ctx.fillStyle = '#636e72';
        ctx.textAlign = 'center';
        ctx.fillText('SCORE', cv.width / 2 - fs * 2, cy2);
        ctx.fillStyle = '#ffeaa7';
        ctx.fillText(score.toLocaleString(), cv.width / 2 + fs * 2, cy2);
        const pctCol = claimed >= target ? '#00b894' : '#74b9ff';
        ctx.fillStyle = pctCol;
        ctx.textAlign = 'right';
        ctx.fillText(claimed + '%', cv.width - 12 - fs * 5, cy2);
        ctx.fillStyle = '#636e72';
        ctx.fillText('/' + target + '%', cv.width - 12 - fs * 2.5, cy2);
        const lx2 = cv.width - 12;
        for (let i = 0; i < lives; i++) {
            const llx = lx2 - i * (fs * 1.2);
            ctx.fillStyle = '#ffeaa7';
            ctx.beginPath();
            const lr = fs * 0.35;
            ctx.moveTo(llx, cy2 - lr);
            ctx.lineTo(llx + lr, cy2);
            ctx.lineTo(llx, cy2 + lr);
            ctx.lineTo(llx - lr, cy2);
            ctx.closePath();
            ctx.fill();
        }
    }

// Input
    const keyMap = {
        'ArrowUp': [0, -1],
        'ArrowDown': [0, 1],
        'ArrowLeft': [-1, 0],
        'ArrowRight': [1, 0],
        'KeyW': [0, -1],
        'KeyS': [0, 1],
        'KeyA': [-1, 0],
        'KeyD': [1, 0]
    };
    document.addEventListener('keydown', e => {
        if (state === 'MENU' || state === 'GAME_OVER') return;
        keys[e.code] = true;
        if (hintVis) {
            hintVis = false;
            document.getElementById('hint').classList.add('hid')
        }
        if (keyMap[e.code]) {
            e.preventDefault();
            setDir(keyMap[e.code][0], keyMap[e.code][1])
        }
        if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') pl.slow = true;
    });
    document.addEventListener('keyup', e => {
        keys[e.code] = false;
        if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') pl.slow = false;
        if (keyMap[e.code]) {
            const [dx, dy] = keyMap[e.code];
            if (inDir.dx === dx && inDir.dy === dy) {
                let found = false;
                for (const [code, [ddx, ddy]] of Object.entries(keyMap)) {
                    if (keys[code] && (ddx !== dx || ddy !== dy)) {
                        setDir(ddx, ddy);
                        found = true;
                        break
                    }
                }
                if (!found) setDir(0, 0);
            }
        }
    });

    cv.addEventListener('touchstart', e => {
        e.preventDefault();
        iAudio();
        if (hintVis) {
            hintVis = false;
            document.getElementById('hint').classList.add('hid')
        }
        const t = e.touches[0];
        touchSt = {x: t.clientX, y: t.clientY}
    }, {passive: false});
    cv.addEventListener('touchmove', e => {
        e.preventDefault();
        if (!touchSt) return;
        const t = e.touches[0];
        const dx = t.clientX - touchSt.x, dy = t.clientY - touchSt.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 12) {
            if (Math.abs(dx) > Math.abs(dy)) setDir(dx > 0 ? 1 : -1, 0); else setDir(0, dy > 0 ? 1 : -1);
            touchSt = {x: t.clientX, y: t.clientY}
        }
    }, {passive: false});
    cv.addEventListener('touchend', e => {
        e.preventDefault();
        touchSt = null
    }, {passive: false});

    document.getElementById('startBtn').addEventListener('click', () => {
        iAudio();
        document.getElementById('menu').classList.add('hid');
        level = 1;
        lives = 3;
        score = 0;
        startLevel()
    });
    document.getElementById('restartBtn').addEventListener('click', () => {
        document.getElementById('gameover').classList.add('hid');
        level = 1;
        lives = 3;
        score = 0;
        startLevel()
    });

    function showGameOver() {
        state = 'GAME_OVER';
        document.getElementById('fScore').textContent = score.toLocaleString();
        document.getElementById('fLvl').textContent = '' + level;
        document.getElementById('fPct').textContent = claimed + '%';
        document.getElementById('gameover').classList.remove('hid');
    }

    function update() {
        fc++;
        if (state === 'PLAYING' || state === 'DRAWING') {
            updatePlayer();
            if (state === 'PLAYING' || state === 'DRAWING') {
                updateQix();
                updateSparx();
                if (state === 'DRAWING') updateFuse();
                if (state === 'DRAWING') checkQixCol();
            }
        } else if (state === 'DYING') {
            deathT--;
            if (deathT <= 0) {
                if (lives <= 0) {
                    showGameOver()
                } else {
                    // BUG3 FIX: Find a valid traversable spawn point
                    const sp = findSpawn();
                    pl.x = sp.x;
                    pl.y = sp.y;
                    pl.drawing = false;
                    pl.stix = [];
                    inDir = {dx: 0, dy: 0};
                    fuse.active = false;
                    fuse.timer = 0;
                    drawGrace = 0;
                    spawnProtect = 60;
                    state = 'PLAYING';
                }
            }
        } else if (state === 'LEVEL_COMPLETE') {
            lvlT--;
            if (lvlT <= 0) {
                document.getElementById('lvlUp').classList.add('hid');
                level++;
                startLevel()
            }
        }
    }

    function loop() {
        update();
        render();
        requestAnimationFrame(loop)
    }

    requestAnimationFrame(loop);
})();</script>
<script src="../logo.js"></script>
</body>
</html>