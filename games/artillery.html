<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Artillery is a turn-based tank battle game. Adjust angle, power and account for wind to destroy your opponent. First to 3 wins takes the match.">
    <meta name="author" content="Claude Opus 4.6 prompted by Tobias Müller">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/artillery.html">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Artillery — Turn-Based Tank Battle">
    <meta property="og:description" content="Adjust angle, power and account for wind to destroy your opponent in this turn-based tank battle. First to 3 wins takes the match.">
    <meta property="og:url" content="https://www.gptgames.dev/games/artillery.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_252.webp">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="GPT Games">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Artillery — Turn-Based Tank Battle">
    <meta name="twitter:description" content="Adjust angle, power and account for wind to destroy your opponent in this turn-based tank battle. First to 3 wins takes the match.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_252.webp">
    <title>Artillery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            background: #0a1118;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            height: 100vh;
            color: #e2e8f0;
            user-select: none
        }

        canvas {
            display: block
        }

        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 16px 24px;
            pointer-events: none;
            z-index: 10
        }

        .pi {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 150px;
            transition: opacity 0.4s, transform 0.4s;
            transform-origin: top left
        }

        .pi.right {
            align-items: flex-end;
            transform-origin: top right
        }

        .pi.dim {
            opacity: 0.3;
            transform: scale(0.95)
        }

        .pname {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase
        }

        .hpbg {
            width: 140px;
            height: 6px;
            background: #152030;
            border-radius: 3px;
            overflow: hidden
        }

        .hpbar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease-out
        }

        .sc {
            font-size: 11px;
            opacity: 0.4;
            margin-top: 2px;
            font-variant-numeric: tabular-nums
        }

        #windBox {
            text-align: center;
            padding: 8px 20px;
            background: #111c28;
            border-radius: 8px;
            border: 1px solid #1c2b3a
        }

        .wlbl {
            font-size: 9px;
            opacity: 0.35;
            text-transform: uppercase;
            letter-spacing: 1.5px
        }

        .wval {
            font-size: 17px;
            font-weight: 700;
            margin-top: 2px;
            min-width: 70px;
            font-variant-numeric: tabular-nums;
            transition: color 0.3s
        }

        #ctrl {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px 20px;
            padding: 12px 24px;
            background: #111c28;
            border-top: 1px solid #1c2b3a;
            z-index: 10;
            transition: transform 0.35s ease
        }

        #ctrl.hidden {
            transform: translateY(100%)
        }

        .tbadge {
            font-size: 11px;
            font-weight: 700;
            padding: 4px 14px;
            border-radius: 5px;
            letter-spacing: 0.5px;
            color: #fff;
            transition: background 0.3s
        }

        .cg {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .cg label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 40px
        }

        .cg .v {
            font-size: 13px;
            font-weight: 600;
            min-width: 36px;
            text-align: right;
            font-variant-numeric: tabular-nums
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 120px;
            height: 4px;
            background: #1c2b3a;
            border-radius: 2px;
            outline: none;
            cursor: pointer
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.15s
        }

        input[type=range]::-webkit-slider-thumb:active {
            transform: scale(1.25)
        }

        input[type=range]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            border: none
        }

        #fireBtn {
            padding: 9px 32px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            color: #fff
        }

        #fireBtn:hover {
            filter: brightness(1.15);
            transform: scale(1.03)
        }

        #fireBtn:active {
            transform: scale(0.96)
        }

        .kbd {
            font-size: 9px;
            opacity: 0.18;
            letter-spacing: 0.5px
        }

        #ov {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(6, 11, 16, 0.92);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px)
        }

        #ov.hidden {
            display: none
        }

        #ov h1 {
            font-size: 46px;
            font-weight: 800;
            letter-spacing: 6px;
            text-transform: uppercase
        }

        #ov .sub {
            font-size: 13px;
            opacity: 0.3;
            margin: 6px 0 28px;
            letter-spacing: 0.5px
        }

        #ov .info {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 24px;
            line-height: 1.7;
            text-align: center
        }

        #ov button {
            padding: 12px 48px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: 2px solid #e2e8f0;
            background: transparent;
            color: #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s
        }

        #ov button:hover {
            background: #e2e8f0;
            color: #0a1118
        }

        #turnBanner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.35s
        }

        #turnBanner span {
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 3px;
            text-transform: uppercase
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
    <div class="pi" id="p1i">
        <div class="pname" style="color:#3b82f6">Player 1</div>
        <div class="hpbg">
            <div class="hpbar" id="hp1" style="background:#3b82f6;width:100%"></div>
        </div>
        <div class="sc" id="sc1">Wins: 0</div>
    </div>
    <div id="windBox">
        <div class="wlbl">Wind</div>
        <div class="wval" id="wv">Calm</div>
    </div>
    <div class="pi right" id="p2i">
        <div class="pname" style="color:#ef4444">Player 2</div>
        <div class="hpbg">
            <div class="hpbar" id="hp2" style="background:#ef4444;width:100%"></div>
        </div>
        <div class="sc" id="sc2">Wins: 0</div>
    </div>
</div>
<div id="ctrl" class="hidden">
    <div class="tbadge" id="tbadge">Player 1</div>
    <div class="cg"><label>Angle</label><input type="range" id="asl" min="5" max="85" value="45"><span class="v"
                                                                                                       id="aval">45°</span>
    </div>
    <div class="cg"><label>Power</label><input type="range" id="psl" min="10" max="100" value="50"><span class="v"
                                                                                                         id="pval">50</span>
    </div>
    <button id="fireBtn">Fire</button>
    <span class="kbd">↑↓ Angle · ←→ Power · Space Fire</span>
</div>
<div id="turnBanner"><span id="turnText"></span></div>
<div id="ov"><h1>Artillery</h1>
    <div class="sub">Turn-based tank battle · First to 3 wins</div>
    <button id="startBtn">Start Game</button>
</div>
<script>
    const C = document.getElementById('c'), X = C.getContext('2d');
    const $ = id => document.getElementById(id);
    let W, H;
    const G = 400, ER = 36, TW = 28, TH = 12, MAXHP = 100, WINS = 3, SPD = 8;
    const COL = ['#3b82f6', '#ef4444'], COLD = ['#2563eb', '#dc2626'];
    let terrain = [], tanks = [], stars = [], particles = [], trails = [], floats = [], windDust = [];
    let turn = 0, wind = 0, proj = null, state = 'title', scores = [0, 0], shake = 0, settleWait = 0,
        roundChecked = false;
    let audioCtx, lastTime = 0;

    function resize() {
        W = C.width = innerWidth;
        H = C.height = innerHeight
    }

    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)
    }

    function snd(type) {
        try {
            initAudio()
        } catch (e) {
            return
        }
        const ac = audioCtx, t = ac.currentTime;
        if (type === 'fire') {
            const b = ac.createBuffer(1, ac.sampleRate * 0.12 | 0, ac.sampleRate), d = b.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2.2);
            const s = ac.createBufferSource();
            s.buffer = b;
            const g = ac.createGain();
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
            s.connect(g).connect(ac.destination);
            s.start(t);
        } else if (type === 'explode') {
            const o = ac.createOscillator();
            o.type = 'sine';
            o.frequency.setValueAtTime(65, t);
            o.frequency.exponentialRampToValueAtTime(12, t + 0.5);
            const g1 = ac.createGain();
            g1.gain.setValueAtTime(0.35, t);
            g1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
            o.connect(g1).connect(ac.destination);
            o.start(t);
            o.stop(t + 0.55);
            const b = ac.createBuffer(1, ac.sampleRate * 0.25 | 0, ac.sampleRate), d = b.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2.5);
            const s = ac.createBufferSource();
            s.buffer = b;
            const g2 = ac.createGain();
            g2.gain.setValueAtTime(0.3, t);
            g2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
            s.connect(g2).connect(ac.destination);
            s.start(t);
        } else if (type === 'destroy') {
            const o = ac.createOscillator();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(120, t);
            o.frequency.exponentialRampToValueAtTime(8, t + 0.7);
            const g1 = ac.createGain();
            g1.gain.setValueAtTime(0.25, t);
            g1.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
            o.connect(g1).connect(ac.destination);
            o.start(t);
            o.stop(t + 0.75);
            const b = ac.createBuffer(1, ac.sampleRate * 0.35 | 0, ac.sampleRate), d = b.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
            const s = ac.createBufferSource();
            s.buffer = b;
            const g2 = ac.createGain();
            g2.gain.setValueAtTime(0.35, t);
            g2.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
            s.connect(g2).connect(ac.destination);
            s.start(t);
        }
    }

    function genTerrain() {
        terrain = new Float32Array(W);
        const p1 = Math.random() * 6.28, p2 = Math.random() * 6.28, p3 = Math.random() * 6.28;
        for (let x = 0; x < W; x++) {
            let h = H * 0.52;
            h -= Math.sin(x * 0.003 + p1) * H * 0.12;
            h -= Math.sin(x * 0.008 + p2) * H * 0.06;
            h -= Math.sin(x * 0.02 + p3) * H * 0.025;
            terrain[x] = Math.max(H * 0.28, Math.min(H * 0.78, h));
        }
        if (tanks.length === 2) {
            tanks.forEach(t => {
                const hw = TW / 2 + 8;
                for (let i = 0; i < 6; i++) for (let x = Math.max(0, t.x - hw); x <= Math.min(W - 1, t.x + hw); x++) {
                    terrain[x] = (terrain[Math.max(0, x - 1)] + terrain[x] + terrain[Math.min(W - 1, x + 1)]) / 3;
                }
            });
        }
    }

    function genStars() {
        stars = [];
        for (let i = 0; i < 100; i++) stars.push({
            x: Math.random() * W,
            y: Math.random() * H * 0.6,
            r: Math.random() * 1.1 + 0.3,
            a: Math.random() * 0.4 + 0.1,
            phase: Math.random() * 6.28
        });
    }

    function initWindDust() {
        windDust = [];
        for (let i = 0; i < 35; i++) windDust.push({
            x: Math.random() * W,
            y: Math.random() * H * 0.88,
            sz: Math.random() * 1 + 0.4,
            a: Math.random() * 0.08 + 0.02,
            sp: Math.random() * 0.6 + 0.4
        });
    }

    function gy(x) {
        const i = Math.max(0, Math.min(W - 1, Math.floor(x)));
        return terrain[i] || H
    }

    function initTanks() {
        const m = W * 0.12;
        tanks = [
            {x: Math.floor(m + Math.random() * W * 0.12), y: 0, angle: 55, power: 50, hp: MAXHP, alive: true},
            {x: Math.floor(W - m - Math.random() * W * 0.12), y: 0, angle: 55, power: 50, hp: MAXHP, alive: true}
        ];
    }

    function placeTanks() {
        tanks.forEach(t => t.y = gy(t.x))
    }

    function newWind() {
        wind = (Math.random() - 0.5) * 160
    }

    function updateWindUI() {
        const w = Math.round(wind / 5);
        const el = $('wv');
        el.textContent = Math.abs(w) < 1 ? 'Calm' : (w < 0 ? '◂ ' : '▸ ') + Math.abs(w);
        el.style.color = Math.abs(w) < 1 ? '#e2e8f0' : Math.abs(w) > 8 ? '#fbbf24' : '#94a3b8';
    }

    function syncSliders() {
        if (!tanks[turn]) return;
        $('asl').value = tanks[turn].angle;
        $('aval').textContent = tanks[turn].angle + '°';
        $('psl').value = tanks[turn].power;
        $('pval').textContent = tanks[turn].power;
    }

    function updateHUD() {
        if (!tanks[0] || !tanks[1]) return;
        $('hp1').style.width = (tanks[0].hp / MAXHP * 100) + '%';
        $('hp2').style.width = (tanks[1].hp / MAXHP * 100) + '%';
        $('sc1').textContent = 'Wins: ' + scores[0];
        $('sc2').textContent = 'Wins: ' + scores[1];
        const b = $('tbadge');
        b.textContent = 'Player ' + (turn + 1);
        b.style.background = COL[turn];
        $('fireBtn').style.background = COL[turn];
        $('p1i').classList.toggle('dim', turn !== 0);
        $('p2i').classList.toggle('dim', turn !== 1);
        updateWindUI();
    }

    function showTurnBanner(cb) {
        const banner = $('turnBanner'), text = $('turnText');
        text.textContent = 'Player ' + (turn + 1);
        text.style.color = COL[turn];
        banner.style.opacity = '1';
        setTimeout(() => {
            banner.style.opacity = '0';
            setTimeout(cb, 300)
        }, 700);
    }

    function showOv(title, sub, info, btn, fn) {
        const o = $('ov');
        o.classList.remove('hidden');
        o.innerHTML = '<h1>' + title + '</h1><div class="sub">' + sub + '</div>' + (info ? '<div class="info">' + info + '</div>' : '') + '<button>' + btn + '</button>';
        o.querySelector('button').onclick = fn;
    }

    function startRound() {
        $('ov').classList.add('hidden');
        particles = [];
        trails = [];
        floats = [];
        proj = null;
        settleWait = 0;
        roundChecked = false;
        initTanks();
        genTerrain();
        placeTanks();
        genStars();
        initWindDust();
        newWind();
        turn = 0;
        syncSliders();
        updateHUD();
        state = 'turnBanner';
        showTurnBanner(() => {
            $('ctrl').classList.remove('hidden');
            state = 'aiming'
        });
    }

    function fire() {
        if (state !== 'aiming' || !tanks[turn]) return;
        const t = tanks[turn], dir = turn === 0 ? 1 : -1;
        const rad = t.angle * Math.PI / 180, spd = t.power * SPD, bl = 22;
        const mx = t.x + Math.cos(rad) * dir * bl, my = t.y - TH - 1 - Math.sin(rad) * bl;
        proj = {x: mx, y: my, vx: Math.cos(rad) * dir * spd, vy: -Math.sin(rad) * spd};
// muzzle flash
        for (let i = 0; i < 8; i++) {
            const a = Math.atan2(-Math.sin(rad), Math.cos(rad) * dir) + (Math.random() - 0.5) * 0.8;
            const sp = Math.random() * 120 + 40;
            particles.push({
                x: mx,
                y: my,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                life: 1,
                decay: 5 + Math.random() * 3,
                col: i < 4 ? '#fbbf24' : '#fff7ed',
                sz: Math.random() * 2.5 + 1,
                grav: false,
                ring: false
            });
        }
        trails = [];
        state = 'firing';
        $('ctrl').classList.add('hidden');
        snd('fire');
    }

    function crater(ex, ey) {
        const r = ER;
        for (let x = Math.max(0, Math.floor(ex - r)); x <= Math.min(W - 1, Math.ceil(ex + r)); x++) {
            const dx = x - ex;
            if (dx * dx < r * r) {
                const cb = ey + Math.sqrt(r * r - dx * dx);
                if (terrain[x] < cb) terrain[x] = cb
            }
        }
        const s = Math.max(1, Math.floor(ex - r - 6)), e = Math.min(W - 2, Math.ceil(ex + r + 6));
        for (let p = 0; p < 5; p++) for (let x = s; x <= e; x++) terrain[x] = (terrain[Math.max(0, x - 1)] + terrain[x] + terrain[Math.min(W - 1, x + 1)]) / 3;
    }

    function explode(ex, ey) {
// fire particles
        for (let i = 0; i < 35; i++) {
            const a = Math.random() * 6.28, sp = Math.random() * 220 + 60;
            particles.push({
                x: ex,
                y: ey,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp - 80,
                life: 1,
                decay: 1 / (Math.random() * 0.45 + 0.3),
                col: ['#f97316', '#ef4444', '#fbbf24', '#fff7ed'][Math.random() * 4 | 0],
                sz: Math.random() * 4.5 + 2,
                grav: false,
                ring: false
            });
        }
// debris
        for (let i = 0; i < 18; i++) {
            const a = -Math.PI / 2 + (Math.random() - 0.5) * 2.4, sp = Math.random() * 170 + 40;
            particles.push({
                x: ex,
                y: ey,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                life: 1,
                decay: 1 / (Math.random() * 0.5 + 0.35),
                col: '#3d2b1a',
                sz: Math.random() * 3 + 1,
                grav: true,
                ring: false
            });
        }
// shockwave ring
        particles.push({
            x: ex,
            y: ey,
            vx: 0,
            vy: 0,
            life: 1,
            decay: 2.8,
            col: '#fbbf24',
            sz: 0,
            grav: false,
            ring: true
        });
        crater(ex, ey);
// damage
        tanks.forEach((t, i) => {
            if (!t || t.hp <= 0) return;
            const dx = t.x - ex, dy = (t.y - TH / 2) - ey, dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < ER * 2.2) {
                const dmg = Math.round((1 - dist / (ER * 2.2)) * 55);
                if (dmg > 0) {
                    t.hp = Math.max(0, t.hp - dmg);
                    floats.push({x: t.x, y: t.y - TH - 30, txt: '-' + dmg, col: '#fbbf24', life: 1.5});
                    if (t.hp <= 0 && t.alive) {
                        t.alive = false;
// destruction particles
                        for (let j = 0; j < 25; j++) {
                            const da = Math.random() * 6.28, dsp = Math.random() * 160 + 50;
                            particles.push({
                                x: t.x + (Math.random() - 0.5) * TW,
                                y: t.y - TH / 2,
                                vx: Math.cos(da) * dsp,
                                vy: Math.sin(da) * dsp - 70,
                                life: 1,
                                decay: 1.1 + Math.random() * 0.4,
                                col: j < 12 ? COL[i] : (j < 18 ? COLD[i] : '#64748b'),
                                sz: Math.random() * 4 + 2,
                                grav: true,
                                ring: false
                            });
                        }
                        snd('destroy');
                    }
                }
            }
        });
        shake = 14;
        snd('explode');
        updateHUD();
    }

    function hitCheck() {
        if (!proj) return null;
        if (proj.x < -80 || proj.x > W + 80 || proj.y > H + 80) return 'miss';
        if (proj.y < -600) return null;
        const px = Math.floor(proj.x);
        if (px >= 0 && px < W && proj.y >= terrain[px]) return 'ground';
        for (let i = 0; i < 2; i++) {
            const t = tanks[i];
            if (!t || !t.alive) continue;
            if (proj.x > t.x - TW / 2 - 3 && proj.x < t.x + TW / 2 + 3 && proj.y > t.y - TH - 10 && proj.y < t.y + 2) return 'tank' + i;
        }
        return null;
    }

    function nextTurn() {
        turn = 1 - turn;
        newWind();
        syncSliders();
        updateHUD();
        state = 'turnBanner';
        showTurnBanner(() => {
            $('ctrl').classList.remove('hidden');
            state = 'aiming'
        });
    }

    function checkRoundEnd() {
        if (roundChecked || !tanks[0] || !tanks[1]) return;
        const dead = tanks.findIndex(t => t.hp <= 0);
        if (dead < 0) {
            nextTurn();
            return
        }
        roundChecked = true;
        const winner = dead === 0 ? 1 : 0;
        scores[winner]++;
        floats.push({x: tanks[dead].x, y: tanks[dead].y - 50, txt: 'DESTROYED', col: '#ef4444', life: 2});
        setTimeout(() => {
            $('ctrl').classList.add('hidden');
            updateHUD();
            if (scores[winner] >= WINS) {
                showOv('Victory', '', '<span style="color:' + COL[winner] + '">Player ' + (winner + 1) + '</span> wins the match!', 'Play Again', () => {
                    scores = [0, 0];
                    startRound()
                });
                state = 'gameOver';
            } else {
                showOv('Round Over', '', '<span style="color:' + COL[winner] + '">Player ' + (winner + 1) + '</span> wins!<br><span style="font-size:15px;opacity:0.4">' + scores[0] + ' — ' + scores[1] + '</span>', 'Next Round', startRound);
                state = 'roundOver';
            }
        }, 1400);
    }

    /* === RENDERING === */

    function drawTerrain() {
// deep layer
        X.fillStyle = '#0d2610';
        X.beginPath();
        X.moveTo(0, H);
        for (let x = 0; x < W; x += 2) X.lineTo(x, terrain[x] + 10);
        X.lineTo(W, H);
        X.closePath();
        X.fill();
// surface
        X.fillStyle = '#162e12';
        X.beginPath();
        X.moveTo(0, H);
        for (let x = 0; x < W; x += 2) X.lineTo(x, terrain[x]);
        X.lineTo(W, H);
        X.closePath();
        X.fill();
// grass line
        X.strokeStyle = '#3a7c24';
        X.lineWidth = 2;
        X.beginPath();
        for (let x = 0; x < W; x += 2) {
            x === 0 ? X.moveTo(x, terrain[x]) : X.lineTo(x, terrain[x])
        }
        X.stroke();
// highlight line
        X.strokeStyle = 'rgba(90,180,50,0.25)';
        X.lineWidth = 1;
        X.beginPath();
        for (let x = 0; x < W; x += 2) {
            x === 0 ? X.moveTo(x, terrain[x] - 1.5) : X.lineTo(x, terrain[x] - 1.5)
        }
        X.stroke();
    }

    function drawTank(idx) {
        const t = tanks[idx];
        if (!t || !t.alive) return;
        const dir = idx === 0 ? 1 : -1, rad = t.angle * Math.PI / 180, bl = 22;
// shadow
        X.fillStyle = 'rgba(0,0,0,0.2)';
        X.beginPath();
        X.ellipse(t.x, t.y + 2, TW / 2 + 4, 4, 0, 0, 6.28);
        X.fill();
// treads
        X.fillStyle = COLD[idx];
        rrect(t.x - TW / 2 - 3, t.y - 5, TW + 6, 7, 3);
// tread detail
        X.fillStyle = 'rgba(0,0,0,0.15)';
        for (let i = -TW / 2; i < TW / 2; i += 5) {
            X.fillRect(t.x + i, t.y - 4, 2, 5);
        }
// body
        X.fillStyle = COL[idx];
        rrect(t.x - TW / 2, t.y - TH - 1, TW, TH, 4);
// body highlight
        X.fillStyle = 'rgba(255,255,255,0.08)';
        rrect(t.x - TW / 2 + 2, t.y - TH, TW - 4, TH / 2 - 1, 3);
// turret dome
        X.fillStyle = COL[idx];
        X.beginPath();
        X.arc(t.x, t.y - TH - 1, 8, Math.PI, 0);
        X.fill();
// barrel
        X.strokeStyle = COLD[idx];
        X.lineWidth = 5;
        X.lineCap = 'round';
        X.beginPath();
        X.moveTo(t.x, t.y - TH - 1);
        X.lineTo(t.x + Math.cos(rad) * dir * bl, t.y - TH - 1 - Math.sin(rad) * bl);
        X.stroke();
        X.strokeStyle = COL[idx];
        X.lineWidth = 3;
        X.beginPath();
        X.moveTo(t.x, t.y - TH - 1);
        X.lineTo(t.x + Math.cos(rad) * dir * bl, t.y - TH - 1 - Math.sin(rad) * bl);
        X.stroke();
// hp bar
        if (t.hp < MAXHP) {
            const bw = 32, bh = 3, bx = t.x - bw / 2, by = t.y - TH - 24;
            X.fillStyle = '#0a1118';
            rrect(bx - 1, by - 1, bw + 2, bh + 2, 2);
            X.fillStyle = t.hp > 50 ? '#4ade80' : t.hp > 25 ? '#fbbf24' : '#ef4444';
            X.fillRect(bx, by, bw * t.hp / MAXHP, bh);
        }
// turn indicator
        if (state === 'aiming' && idx === turn) {
            const pulse = 0.5 + Math.sin(Date.now() * 0.005) * 0.4;
            X.fillStyle = COL[idx];
            X.globalAlpha = pulse;
            X.beginPath();
            X.moveTo(t.x, t.y - TH - 32);
            X.lineTo(t.x - 5, t.y - TH - 40);
            X.lineTo(t.x + 5, t.y - TH - 40);
            X.fill();
            X.globalAlpha = 1;
        }
    }

    function rrect(x, y, w, h, r) {
        X.beginPath();
        X.moveTo(x + r, y);
        X.arcTo(x + w, y, x + w, y + h, r);
        X.arcTo(x + w, y + h, x, y + h, r);
        X.arcTo(x, y + h, x, y, r);
        X.arcTo(x, y, x + w, y, r);
        X.closePath();
        X.fill();
    }

    function drawTrajectory() {
        if (state !== 'aiming' || !tanks[turn]) return;
        const t = tanks[turn], dir = turn === 0 ? 1 : -1, rad = t.angle * Math.PI / 180, spd = t.power * SPD, bl = 22;
        let px = t.x + Math.cos(rad) * dir * bl, py = t.y - TH - 1 - Math.sin(rad) * bl;
        let vx = Math.cos(rad) * dir * spd, vy = -Math.sin(rad) * spd;
        const dt = 0.022;
        for (let i = 0; i < 55; i++) {
            vx += wind * dt;
            vy += G * dt;
            px += vx * dt;
            py += vy * dt;
            if (py > H || px < 0 || px > W) break;
            if (px >= 0 && px < W && py >= terrain[Math.floor(px)]) break;
            if (i % 2 === 0) {
                const a = 0.3 * (1 - i / 55);
                X.fillStyle = turn === 0 ? `rgba(59,130,246,${a})` : `rgba(239,68,68,${a})`;
                X.beginPath();
                X.arc(px, py, 1.5, 0, 6.28);
                X.fill();
            }
        }
    }

    function drawWindDust(ts) {
        windDust.forEach(d => {
            const drift = wind * 0.012 * d.sp;
            d.x += drift;
            d.y += Math.sin(ts * 0.0008 + d.x * 0.005) * 0.15;
            if (d.x > W + 20) d.x = -20;
            if (d.x < -20) d.x = W + 20;
            X.fillStyle = `rgba(200,210,230,${d.a})`;
            X.beginPath();
            X.arc(d.x, d.y, d.sz, 0, 6.28);
            X.fill();
        });
    }

    function render(ts) {
        const sx = shake > 0 ? (Math.random() - 0.5) * shake : 0, sy = shake > 0 ? (Math.random() - 0.5) * shake : 0;
        X.save();
        X.translate(sx, sy);
// sky
        X.fillStyle = '#0a1118';
        X.fillRect(0, 0, W, H);
// stars with twinkle
        for (const s of stars) {
            const tw = 0.6 + 0.4 * Math.sin(ts * 0.0015 + s.phase);
            X.fillStyle = `rgba(255,255,255,${s.a * tw})`;
            X.beginPath();
            X.arc(s.x, s.y, s.r, 0, 6.28);
            X.fill();
        }
// wind dust
        drawWindDust(ts);
        drawTerrain();
        drawTrajectory();
        drawTank(0);
        drawTank(1);
// projectile
        if (proj) {
            X.shadowColor = '#fbbf24';
            X.shadowBlur = 16;
            X.fillStyle = '#fbbf24';
            X.beginPath();
            X.arc(proj.x, proj.y, 4, 0, 6.28);
            X.fill();
            X.shadowBlur = 0;
            X.fillStyle = 'rgba(255,247,237,0.7)';
            X.beginPath();
            X.arc(proj.x, proj.y, 2, 0, 6.28);
            X.fill();
        }
// trails
        for (const t of trails) {
            X.fillStyle = `rgba(251,191,36,${Math.max(0, t.life * 0.4)})`;
            X.beginPath();
            X.arc(t.x, t.y, 2 * t.life, 0, 6.28);
            X.fill();
        }
// particles
        for (const p of particles) {
            if (p.ring) {
                const radius = (1 - p.life) * ER * 3.5;
                X.globalAlpha = Math.max(0, p.life * 0.35);
                X.strokeStyle = p.col;
                X.lineWidth = 1.5;
                X.beginPath();
                X.arc(p.x, p.y, radius, 0, 6.28);
                X.stroke();
            } else {
                X.globalAlpha = Math.max(0, p.life);
                X.fillStyle = p.col;
                X.beginPath();
                X.arc(p.x, p.y, p.sz * p.life, 0, 6.28);
                X.fill();
            }
        }
        X.globalAlpha = 1;
// float text
        for (const f of floats) {
            X.globalAlpha = Math.min(1, f.life);
            X.fillStyle = f.col;
            X.font = 'bold 15px system-ui';
            X.textAlign = 'center';
            X.fillText(f.txt, f.x, f.y);
        }
        X.globalAlpha = 1;
        X.restore();
    }

    /* === GAME LOOP === */
    function loop(ts) {
        const dt = Math.min((ts - (lastTime || ts)) / 1000, 0.05);
        lastTime = ts;
// update particles
        particles = particles.filter(p => {
            p.life -= dt * p.decay;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            if (p.grav) p.vy += G * dt;
            return p.life > 0;
        });
        trails = trails.filter(t => {
            t.life -= dt * 2.8;
            return t.life > 0
        });
        floats = floats.filter(f => {
            f.life -= dt;
            f.y -= 28 * dt;
            return f.life > 0
        });
        if (shake > 0) shake = Math.max(0, shake - dt * 35);
// projectile physics
        if (state === 'firing' && proj) {
            const steps = 5, sd = dt / steps;
            for (let s = 0; s < steps; s++) {
                proj.vx += wind * sd;
                proj.vy += G * sd;
                proj.x += proj.vx * sd;
                proj.y += proj.vy * sd;
                trails.push({x: proj.x, y: proj.y, life: 1});
                const h = hitCheck();
                if (h) {
                    if (h === 'miss') {
                        floats.push({x: W / 2, y: H * 0.35, txt: 'MISS', col: '#475569', life: 1.5});
                        proj = null;
                    } else {
                        explode(proj.x, proj.y);
                        proj = null
                    }
                    state = 'settling';
                    settleWait = 0.7;
                    roundChecked = false;
                    break;
                }
            }
        }
// settling
        if (state === 'settling') {
            let settled = true;
            tanks.forEach(t => {
                if (!t || t.hp <= 0) return;
                const g = gy(t.x);
                if (t.y < g - 1) {
                    t.y = Math.min(t.y + 280 * dt, g);
                    settled = false
                } else t.y = g;
            });
            if (settled) {
                settleWait -= dt;
                if (settleWait <= 0) checkRoundEnd()
            }
        }
        render(ts);
        requestAnimationFrame(loop);
    }

    /* === EVENT HANDLERS === */
    $('asl').oninput = function () {
        if (state === 'aiming' && tanks[turn]) {
            tanks[turn].angle = +this.value;
            $('aval').textContent = this.value + '°'
        }
    };
    $('psl').oninput = function () {
        if (state === 'aiming' && tanks[turn]) {
            tanks[turn].power = +this.value;
            $('pval').textContent = this.value
        }
    };
    $('fireBtn').onclick = fire;

    document.addEventListener('keydown', e => {
        if (state !== 'aiming' || !tanks[turn]) return;
        const t = tanks[turn];
        let ok = true;
        switch (e.key) {
            case'ArrowUp':
                t.angle = Math.min(85, t.angle + 1);
                syncSliders();
                break;
            case'ArrowDown':
                t.angle = Math.max(5, t.angle - 1);
                syncSliders();
                break;
            case'ArrowRight':
                t.power = Math.min(100, t.power + 1);
                syncSliders();
                break;
            case'ArrowLeft':
                t.power = Math.max(10, t.power - 1);
                syncSliders();
                break;
            case' ':
                fire();
                break;
            default:
                ok = false
        }
        if (ok) e.preventDefault();
    });

    window.addEventListener('resize', () => {
        const oldW = W || innerWidth;
        resize();
        if (tanks.length === 2 && state !== 'title' && state !== 'gameOver' && state !== 'roundOver') {
            tanks.forEach(t => {
                t.x = Math.round(t.x * W / oldW)
            });
            genTerrain();
            placeTanks();
        }
        genStars();
        initWindDust();
    });

    resize();
    genStars();
    initWindDust();
    $('startBtn').onclick = startRound;
    requestAnimationFrame(loop);
</script>
<script src="../logo.js"></script>
</body>
</html>