<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description"
          content="Artillery is a turn-based tank battle game. Adjust angle,power and account for wind to destroy your opponent. First to 3 wins takes the match.">
    <meta name="author" content="Claude Opus 4.6 prompted by Tobias Müller">
    <meta name="robots" content="index,follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/artillery.html">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Artillery — Turn-Based Tank Battle">
    <meta property="og:description"
          content="Adjust angle,power and account for wind to destroy your opponent in this turn-based tank battle. First to 3 wins takes the match.">
    <meta property="og:url" content="https://www.gptgames.dev/games/artillery.html">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_252.webp">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="GPT Games">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Artillery — Turn-Based Tank Battle">
    <meta name="twitter:description"
          content="Adjust angle,power and account for wind to destroy your opponent in this turn-based tank battle. First to 3 wins takes the match.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_252.webp">
    <title>Artillery</title>
    <style>* {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    body {
        background: #0a1118;
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        overflow: hidden;
        height: 100vh;
        color: #e2e8f0;
        user-select: none;
        touch-action: manipulation
    }

    canvas {
        display: block
    }

    #hud {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 12px 16px;
        pointer-events: none;
        z-index: 10
    }

    .pi {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 120px;
        transition: opacity 0.4s, transform 0.4s;
        transform-origin: top left
    }

    .pi.right {
        align-items: flex-end;
        transform-origin: top right
    }

    .pi.dim {
        opacity: 0.3;
        transform: scale(0.95)
    }

    .pname {
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 1.2px;
        text-transform: uppercase
    }

    .hpbg {
        width: 110px;
        height: 5px;
        background: #152030;
        border-radius: 3px;
        overflow: hidden
    }

    .hpbar {
        height: 100%;
        border-radius: 3px;
        transition: width 0.5s ease-out
    }

    .sc {
        font-size: 10px;
        opacity: 0.4;
        margin-top: 2px;
        font-variant-numeric: tabular-nums
    }

    #windBox {
        text-align: center;
        padding: 6px 14px;
        background: #111c28;
        border-radius: 8px;
        border: 1px solid #1c2b3a
    }

    .wlbl {
        font-size: 9px;
        opacity: 0.35;
        text-transform: uppercase;
        letter-spacing: 1.5px
    }

    .wval {
        font-size: 15px;
        font-weight: 700;
        margin-top: 2px;
        min-width: 60px;
        font-variant-numeric: tabular-nums;
        transition: color 0.3s
    }

    #ctrl {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px 16px;
        padding: 10px 16px;
        background: #111c28;
        border-top: 1px solid #1c2b3a;
        z-index: 10;
        transition: transform 0.35s ease
    }

    #ctrl.hidden {
        transform: translateY(100%)
    }

    .tbadge {
        font-size: 11px;
        font-weight: 700;
        padding: 4px 14px;
        border-radius: 5px;
        letter-spacing: 0.5px;
        color: #fff;
        transition: background 0.3s
    }

    .cg {
        display: flex;
        align-items: center;
        gap: 8px
    }

    .cg label {
        font-size: 9px;
        opacity: 0.4;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 40px
    }

    .cg .v {
        font-size: 13px;
        font-weight: 600;
        min-width: 36px;
        text-align: right;
        font-variant-numeric: tabular-nums
    }

    input[type=range] {
        -webkit-appearance: none;
        width: 120px;
        height: 4px;
        background: #1c2b3a;
        border-radius: 2px;
        outline: none;
        cursor: pointer
    }

    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 22px;
        height: 22px;
        background: #e2e8f0;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.15s
    }

    input[type=range]::-webkit-slider-thumb:active {
        transform: scale(1.15)
    }

    input[type=range]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        background: #e2e8f0;
        border-radius: 50%;
        cursor: pointer;
        border: none
    }

    #fireBtn {
        padding: 12px 36px;
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s;
        color: #fff;
        min-height: 44px
    }

    #fireBtn:hover {
        filter: brightness(1.15);
        transform: scale(1.03)
    }

    #fireBtn:active {
        transform: scale(0.96)
    }

    .kbd {
        font-size: 9px;
        opacity: 0.18;
        letter-spacing: 0.5px
    }

    #ov {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 20;
        background: rgba(6, 11, 16, 0.92);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px)
    }

    #ov.hidden {
        display: none
    }

    #ov h1 {
        font-size: 38px;
        font-weight: 800;
        letter-spacing: 5px;
        text-transform: uppercase
    }

    #ov .sub {
        font-size: 12px;
        opacity: 0.3;
        margin: 6px 0 22px;
        letter-spacing: 0.5px
    }

    #ov .info {
        font-size: 17px;
        font-weight: 600;
        margin-bottom: 20px;
        line-height: 1.7;
        text-align: center
    }

    #ov .mode-select {
        display: flex;
        gap: 12px;
        margin-bottom: 24px
    }

    #ov .mode-btn {
        padding: 14px 28px;
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        border: 2px solid #2a3a4a;
        background: transparent;
        color: #8899aa;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px
    }

    #ov .mode-btn:hover {
        border-color: #4a5a6a;
        color: #c0c8d0
    }

    #ov .mode-btn.active {
        border-color: #e2e8f0;
        color: #e2e8f0;
        background: rgba(226, 232, 240, 0.06)
    }

    #ov .diff-select {
        display: flex;
        gap: 10px;
        margin-bottom: 24px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s, transform 0.3s;
        transform: translateY(-6px)
    }

    #ov .diff-select.show {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0)
    }

    #ov .diff-btn {
        padding: 10px 20px;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        border: 2px solid #2a3a4a;
        background: transparent;
        color: #8899aa;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 44px
    }

    #ov .diff-btn:hover {
        border-color: #4a5a6a;
        color: #c0c8d0
    }

    #ov .diff-btn.active {
        border-color: #e2e8f0;
        color: #e2e8f0;
        background: rgba(226, 232, 240, 0.06)
    }

    #ov button.start {
        padding: 14px 48px;
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
        border: 2px solid #e2e8f0;
        background: transparent;
        color: #e2e8f0;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 48px
    }

    #ov button.start:hover {
        background: #e2e8f0;
        color: #0a1118
    }

    #turnBanner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 15;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.35s
    }

    #turnBanner span {
        font-size: 20px;
        font-weight: 800;
        letter-spacing: 3px;
        text-transform: uppercase
    }

    #mobileAdj {
        display: none;
        gap: 4px;
        align-items: center
    }

    .adj-btn {
        width: 36px;
        height: 36px;
        border: 1px solid #2a3a4a;
        background: #152030;
        color: #e2e8f0;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.1s;
        -webkit-tap-highlight-color: transparent
    }

    .adj-btn:active {
        background: #2a3a4a
    }

    @media (max-width: 700px) {
        .kbd {
            display: none
        }

        #mobileAdj {
            display: flex
        }

        #ctrl {
            gap: 6px 10px;
            padding: 8px 10px;
            flex-wrap: wrap;
            justify-content: center
        }

        .cg {
            gap: 4px
        }

        .cg label {
            min-width: 32px;
            font-size: 8px
        }

        input[type=range] {
            width: 80px;
            height: 6px
        }

        input[type=range]::-webkit-slider-thumb {
            width: 26px;
            height: 26px
        }

        #fireBtn {
            padding: 14px 28px;
            font-size: 14px;
            flex-basis: 100%;
            order: 10
        }

        #ov h1 {
            font-size: 28px;
            letter-spacing: 3px
        }

        #ov .mode-btn {
            padding: 12px 18px;
            font-size: 11px
        }

        #ov .diff-btn {
            padding: 8px 14px;
            font-size: 10px
        }

        .hpbg {
            width: 80px
        }

        .pi {
            min-width: 90px
        }

        #windBox {
            padding: 5px 10px
        }

        .wval {
            font-size: 13px
        }
    }</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
    <div class="pi" id="p1i">
        <div class="pname" style="color:#3b82f6">Player 1</div>
        <div class="hpbg">
            <div class="hpbar" id="hp1" style="background:#3b82f6;width:100%"></div>
        </div>
        <div class="sc" id="sc1">Wins: 0</div>
    </div>
    <div id="windBox">
        <div class="wlbl">Wind</div>
        <div class="wval" id="wv">Calm</div>
    </div>
    <div class="pi right" id="p2i">
        <div class="pname" id="p2name" style="color:#ef4444">Player 2</div>
        <div class="hpbg">
            <div class="hpbar" id="hp2" style="background:#ef4444;width:100%"></div>
        </div>
        <div class="sc" id="sc2">Wins: 0</div>
    </div>
</div>
<div id="ctrl" class="hidden">
    <div class="tbadge" id="tbadge">Player 1</div>
    <div class="cg"><label>Angle</label>
        <div id="mobileAdj">
            <button class="adj-btn" data-target="asl" data-dir="-1">−</button>
        </div>
        <input type="range" id="asl" min="5" max="85" value="45">
        <div id="mobileAdj2" style="display:none">
            <button class="adj-btn" data-target="asl" data-dir="1">+</button>
        </div>
        <span class="v" id="aval">45°</span></div>
    <div class="cg"><label>Power</label>
        <div id="mobileAdj3" style="display:none">
            <button class="adj-btn" data-target="psl" data-dir="-1">−</button>
        </div>
        <input type="range" id="psl" min="10" max="100" value="50">
        <div id="mobileAdj4" style="display:none">
            <button class="adj-btn" data-target="psl" data-dir="1">+</button>
        </div>
        <span class="v" id="pval">50</span></div>
    <button id="fireBtn">Fire</button>
    <span class="kbd">↑↓ Angle · ←→ Power · Space Fire</span></div>
<div id="turnBanner"><span id="turnText"></span></div>
<div id="ov"><h1>Artillery</h1>
    <div class="sub">Turn-based tank battle · First to 3 wins</div>
    <div class="mode-select">
        <button class="mode-btn active" id="modePvP">2 Player</button>
        <button class="mode-btn" id="modeNPC">vs CPU</button>
    </div>
    <div class="diff-select" id="diffSelect">
        <button class="diff-btn" id="diffEasy">Easy</button>
        <button class="diff-btn active" id="diffMed">Medium</button>
        <button class="diff-btn" id="diffHard">Hard</button>
    </div>
    <button class="start" id="startBtn">Start Game</button>
</div>
<script>const C = document.getElementById('c'), X = C.getContext('2d');
const $ = id => document.getElementById(id);
let W, H;
const G = 400, ER = 36, TW = 28, TH = 12, MAXHP = 100, WINS = 3, SPD = 8;
const COL = ['#3b82f6', '#ef4444'], COLD = ['#2563eb', '#dc2626'];
let terrain = [], tanks = [], stars = [], particles = [], trails = [], floats = [], windDust = [];
let turn = 0, wind = 0, proj = null, state = 'title', scores = [0, 0], shake = 0, settleWait = 0, roundChecked = false;
let audioCtx, lastTime = 0;
let gameMode = 'pvp', difficulty = 'medium';
let npcThinking = false, npcTimer = 0;
const DIFF_SETTINGS = {
    easy: {errorAngle: 12, errorPower: 15, delay: 1.2},
    medium: {errorAngle: 6, errorPower: 8, delay: 0.9},
    hard: {errorAngle: 2, errorPower: 3, delay: 0.6}
};

function isMobile() {
    return window.innerWidth <= 700
}

function resize() {
    W = C.width = innerWidth;
    H = C.height = innerHeight
}

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)
}

function snd(type) {
    try {
        initAudio()
    } catch (e) {
        return
    }
    const ac = audioCtx, t = ac.currentTime;
    if (type === 'fire') {
        const b = ac.createBuffer(1, ac.sampleRate * 0.12 | 0, ac.sampleRate), d = b.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2.2);
        const s = ac.createBufferSource();
        s.buffer = b;
        const g = ac.createGain();
        g.gain.setValueAtTime(0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        s.connect(g).connect(ac.destination);
        s.start(t)
    } else if (type === 'explode') {
        const o = ac.createOscillator();
        o.type = 'sine';
        o.frequency.setValueAtTime(65, t);
        o.frequency.exponentialRampToValueAtTime(12, t + 0.5);
        const g1 = ac.createGain();
        g1.gain.setValueAtTime(0.35, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        o.connect(g1).connect(ac.destination);
        o.start(t);
        o.stop(t + 0.55);
        const b = ac.createBuffer(1, ac.sampleRate * 0.25 | 0, ac.sampleRate), d = b.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2.5);
        const s = ac.createBufferSource();
        s.buffer = b;
        const g2 = ac.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        s.connect(g2).connect(ac.destination);
        s.start(t)
    } else if (type === 'destroy') {
        const o = ac.createOscillator();
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(120, t);
        o.frequency.exponentialRampToValueAtTime(8, t + 0.7);
        const g1 = ac.createGain();
        g1.gain.setValueAtTime(0.25, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
        o.connect(g1).connect(ac.destination);
        o.start(t);
        o.stop(t + 0.75);
        const b = ac.createBuffer(1, ac.sampleRate * 0.35 | 0, ac.sampleRate), d = b.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
        const s = ac.createBufferSource();
        s.buffer = b;
        const g2 = ac.createGain();
        g2.gain.setValueAtTime(0.35, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
        s.connect(g2).connect(ac.destination);
        s.start(t)
    }
}

function genTerrain() {
    terrain = new Float32Array(W);
    const p1 = Math.random() * 6.28, p2 = Math.random() * 6.28, p3 = Math.random() * 6.28;
    for (let x = 0; x < W; x++) {
        let h = H * 0.52;
        h -= Math.sin(x * 0.003 + p1) * H * 0.12;
        h -= Math.sin(x * 0.008 + p2) * H * 0.06;
        h -= Math.sin(x * 0.02 + p3) * H * 0.025;
        terrain[x] = Math.max(H * 0.28, Math.min(H * 0.78, h))
    }
    if (tanks.length === 2) {
        tanks.forEach(t => {
            const hw = TW / 2 + 8;
            for (let i = 0; i < 6; i++) for (let x = Math.max(0, t.x - hw); x <= Math.min(W - 1, t.x + hw); x++) {
                terrain[x] = (terrain[Math.max(0, x - 1)] + terrain[x] + terrain[Math.min(W - 1, x + 1)]) / 3
            }
        })
    }
}

function genStars() {
    stars = [];
    for (let i = 0; i < 100; i++) stars.push({
        x: Math.random() * W,
        y: Math.random() * H * 0.6,
        r: Math.random() * 1.1 + 0.3,
        a: Math.random() * 0.4 + 0.1,
        phase: Math.random() * 6.28
    })
}

function initWindDust() {
    windDust = [];
    for (let i = 0; i < 35; i++) windDust.push({
        x: Math.random() * W,
        y: Math.random() * H * 0.88,
        sz: Math.random() * 1 + 0.4,
        a: Math.random() * 0.08 + 0.02,
        sp: Math.random() * 0.6 + 0.4
    })
}

function gy(x) {
    const i = Math.max(0, Math.min(W - 1, Math.floor(x)));
    return terrain[i] || H
}

function initTanks() {
    const m = W * 0.12;
    tanks = [{
        x: Math.floor(m + Math.random() * W * 0.12),
        y: 0,
        angle: 55,
        power: 50,
        hp: MAXHP,
        alive: true
    }, {x: Math.floor(W - m - Math.random() * W * 0.12), y: 0, angle: 55, power: 50, hp: MAXHP, alive: true}]
}

function placeTanks() {
    tanks.forEach(t => t.y = gy(t.x))
}

function newWind() {
    wind = (Math.random() - 0.5) * 160
}

function updateWindUI() {
    const w = Math.round(wind / 5);
    const el = $('wv');
    el.textContent = Math.abs(w) < 1 ? 'Calm' : (w < 0 ? '◂ ' : '▸ ') + Math.abs(w);
    el.style.color = Math.abs(w) < 1 ? '#e2e8f0' : Math.abs(w) > 8 ? '#fbbf24' : '#94a3b8'
}

function syncSliders() {
    if (!tanks[turn]) return;
    $('asl').value = tanks[turn].angle;
    $('aval').textContent = tanks[turn].angle + '°';
    $('psl').value = tanks[turn].power;
    $('pval').textContent = tanks[turn].power
}

function updateHUD() {
    if (!tanks[0] || !tanks[1]) return;
    $('hp1').style.width = (tanks[0].hp / MAXHP * 100) + '%';
    $('hp2').style.width = (tanks[1].hp / MAXHP * 100) + '%';
    $('sc1').textContent = 'Wins: ' + scores[0];
    $('sc2').textContent = 'Wins: ' + scores[1];
    const b = $('tbadge');
    const isNPC = gameMode === 'npc' && turn === 1;
    b.textContent = isNPC ? 'CPU' : 'Player ' + (turn + 1);
    b.style.background = COL[turn];
    $('fireBtn').style.background = COL[turn];
    $('p1i').classList.toggle('dim', turn !== 0);
    $('p2i').classList.toggle('dim', turn !== 1);
    updateWindUI()
}

function showTurnBanner(cb) {
    const banner = $('turnBanner'), text = $('turnText');
    const isNPC = gameMode === 'npc' && turn === 1;
    text.textContent = isNPC ? 'CPU Turn' : 'Player ' + (turn + 1);
    text.style.color = COL[turn];
    banner.style.opacity = '1';
    setTimeout(() => {
        banner.style.opacity = '0';
        setTimeout(cb, 300)
    }, 700)
}

function showOv(title, sub, info, btn, fn) {
    const o = $('ov');
    o.classList.remove('hidden');
    o.innerHTML = '<h1>' + title + '</h1><div class="sub">' + sub + '</div>' + (info ? '<div class="info">' + info + '</div>' : '') + '<button class="start">' + btn + '</button>';
    o.querySelector('button').onclick = fn
}

function npcCalculateShot() {
    const me = tanks[1], target = tanks[0];
    const dx = target.x - me.x, dy = (target.y - TH / 2) - (me.y - TH - 1);
    const dist = Math.abs(dx);
    const settings = DIFF_SETTINGS[difficulty];
    let bestAngle = 45, bestPower = 50, bestDist = Infinity;
    for (let a = 10; a <= 80; a += 2) {
        for (let p = 15; p <= 100; p += 3) {
            const rad = a * Math.PI / 180;
            const dir = -1;
            const spd = p * SPD;
            const vx0 = Math.cos(rad) * dir * spd;
            const vy0 = -Math.sin(rad) * spd;
            let px = me.x + Math.cos(rad) * dir * 22;
            let py = me.y - TH - 1 - Math.sin(rad) * 22;
            let vx = vx0, vy = vy0;
            const dt = 0.025;
            let hit = false;
            for (let i = 0; i < 300; i++) {
                vx += wind * dt;
                vy += G * dt;
                px += vx * dt;
                py += vy * dt;
                if (px < -80 || px > W + 80 || py > H + 80) break;
                const ix = Math.floor(px);
                if (ix >= 0 && ix < W && py >= terrain[ix]) {
                    const d = Math.sqrt((px - target.x) ** 2 + (py - (target.y - TH / 2)) ** 2);
                    if (d < bestDist) {
                        bestDist = d;
                        bestAngle = a;
                        bestPower = p
                    }
                    hit = true;
                    break
                }
                if (px > target.x - TW / 2 - 3 && px < target.x + TW / 2 + 3 && py > target.y - TH - 10 && py < target.y + 2) {
                    bestDist = 0;
                    bestAngle = a;
                    bestPower = p;
                    hit = true;
                    break
                }
            }
        }
    }
    const errA = (Math.random() - 0.5) * 2 * settings.errorAngle;
    const errP = (Math.random() - 0.5) * 2 * settings.errorPower;
    return {
        angle: Math.max(5, Math.min(85, Math.round(bestAngle + errA))),
        power: Math.max(10, Math.min(100, Math.round(bestPower + errP)))
    }
}

function startNPCTurn() {
    npcThinking = true;
    const settings = DIFF_SETTINGS[difficulty];
    npcTimer = settings.delay;
    const shot = npcCalculateShot();
    tanks[1].angle = shot.angle;
    tanks[1].power = shot.power
}

function startRound() {
    $('ov').classList.add('hidden');
    particles = [];
    trails = [];
    floats = [];
    proj = null;
    settleWait = 0;
    roundChecked = false;
    npcThinking = false;
    npcTimer = 0;
    initTanks();
    genTerrain();
    placeTanks();
    genStars();
    initWindDust();
    newWind();
    turn = 0;
    $('p2name').textContent = gameMode === 'npc' ? 'CPU' : 'Player 2';
    syncSliders();
    updateHUD();
    state = 'turnBanner';
    showTurnBanner(() => {
        $('ctrl').classList.remove('hidden');
        state = 'aiming';
        if (gameMode === 'npc' && turn === 1) {
            $('ctrl').classList.add('hidden');
            startNPCTurn()
        }
    })
}

function fire() {
    if (state !== 'aiming' || !tanks[turn]) return;
    const t = tanks[turn], dir = turn === 0 ? 1 : -1;
    const rad = t.angle * Math.PI / 180, spd = t.power * SPD, bl = 22;
    const mx = t.x + Math.cos(rad) * dir * bl, my = t.y - TH - 1 - Math.sin(rad) * bl;
    proj = {x: mx, y: my, vx: Math.cos(rad) * dir * spd, vy: -Math.sin(rad) * spd};
    for (let i = 0; i < 8; i++) {
        const a = Math.atan2(-Math.sin(rad), Math.cos(rad) * dir) + (Math.random() - 0.5) * 0.8;
        const sp = Math.random() * 120 + 40;
        particles.push({
            x: mx,
            y: my,
            vx: Math.cos(a) * sp,
            vy: Math.sin(a) * sp,
            life: 1,
            decay: 5 + Math.random() * 3,
            col: i < 4 ? '#fbbf24' : '#fff7ed',
            sz: Math.random() * 2.5 + 1,
            grav: false,
            ring: false
        })
    }
    trails = [];
    state = 'firing';
    $('ctrl').classList.add('hidden');
    snd('fire')
}

function crater(ex, ey) {
    const r = ER;
    for (let x = Math.max(0, Math.floor(ex - r)); x <= Math.min(W - 1, Math.ceil(ex + r)); x++) {
        const dx = x - ex;
        if (dx * dx < r * r) {
            const cb = ey + Math.sqrt(r * r - dx * dx);
            if (terrain[x] < cb) terrain[x] = cb
        }
    }
    const s = Math.max(1, Math.floor(ex - r - 6)), e = Math.min(W - 2, Math.ceil(ex + r + 6));
    for (let p = 0; p < 5; p++) for (let x = s; x <= e; x++) terrain[x] = (terrain[Math.max(0, x - 1)] + terrain[x] + terrain[Math.min(W - 1, x + 1)]) / 3
}

function explode(ex, ey) {
    for (let i = 0; i < 35; i++) {
        const a = Math.random() * 6.28, sp = Math.random() * 220 + 60;
        particles.push({
            x: ex,
            y: ey,
            vx: Math.cos(a) * sp,
            vy: Math.sin(a) * sp - 80,
            life: 1,
            decay: 1 / (Math.random() * 0.45 + 0.3),
            col: ['#f97316', '#ef4444', '#fbbf24', '#fff7ed'][Math.random() * 4 | 0],
            sz: Math.random() * 4.5 + 2,
            grav: false,
            ring: false
        })
    }
    for (let i = 0; i < 18; i++) {
        const a = -Math.PI / 2 + (Math.random() - 0.5) * 2.4, sp = Math.random() * 170 + 40;
        particles.push({
            x: ex,
            y: ey,
            vx: Math.cos(a) * sp,
            vy: Math.sin(a) * sp,
            life: 1,
            decay: 1 / (Math.random() * 0.5 + 0.35),
            col: '#3d2b1a',
            sz: Math.random() * 3 + 1,
            grav: true,
            ring: false
        })
    }
    particles.push({x: ex, y: ey, vx: 0, vy: 0, life: 1, decay: 2.8, col: '#fbbf24', sz: 0, grav: false, ring: true});
    crater(ex, ey);
    tanks.forEach((t, i) => {
        if (!t || t.hp <= 0) return;
        const dx = t.x - ex, dy = (t.y - TH / 2) - ey, dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < ER * 2.2) {
            const dmg = Math.round((1 - dist / (ER * 2.2)) * 55);
            if (dmg > 0) {
                t.hp = Math.max(0, t.hp - dmg);
                floats.push({x: t.x, y: t.y - TH - 30, txt: '-' + dmg, col: '#fbbf24', life: 1.5});
                if (t.hp <= 0 && t.alive) {
                    t.alive = false;
                    for (let j = 0; j < 25; j++) {
                        const da = Math.random() * 6.28, dsp = Math.random() * 160 + 50;
                        particles.push({
                            x: t.x + (Math.random() - 0.5) * TW,
                            y: t.y - TH / 2,
                            vx: Math.cos(da) * dsp,
                            vy: Math.sin(da) * dsp - 70,
                            life: 1,
                            decay: 1.1 + Math.random() * 0.4,
                            col: j < 12 ? COL[i] : (j < 18 ? COLD[i] : '#64748b'),
                            sz: Math.random() * 4 + 2,
                            grav: true,
                            ring: false
                        })
                    }
                    snd('destroy')
                }
            }
        }
    });
    shake = 14;
    snd('explode');
    updateHUD()
}

function hitCheck() {
    if (!proj) return null;
    if (proj.x < -80 || proj.x > W + 80 || proj.y > H + 80) return 'miss';
    if (proj.y < -600) return null;
    const px = Math.floor(proj.x);
    if (px >= 0 && px < W && proj.y >= terrain[px]) return 'ground';
    for (let i = 0; i < 2; i++) {
        const t = tanks[i];
        if (!t || !t.alive) continue;
        if (proj.x > t.x - TW / 2 - 3 && proj.x < t.x + TW / 2 + 3 && proj.y > t.y - TH - 10 && proj.y < t.y + 2) return 'tank' + i
    }
    return null
}

function nextTurn() {
    turn = 1 - turn;
    newWind();
    syncSliders();
    updateHUD();
    state = 'turnBanner';
    showTurnBanner(() => {
        if (gameMode === 'npc' && turn === 1) {
            state = 'aiming';
            startNPCTurn()
        } else {
            $('ctrl').classList.remove('hidden');
            state = 'aiming'
        }
    })
}

function checkRoundEnd() {
    if (roundChecked || !tanks[0] || !tanks[1]) return;
    const dead = tanks.findIndex(t => t.hp <= 0);
    if (dead < 0) {
        nextTurn();
        return
    }
    roundChecked = true;
    const winner = dead === 0 ? 1 : 0;
    scores[winner]++;
    floats.push({x: tanks[dead].x, y: tanks[dead].y - 50, txt: 'DESTROYED', col: '#ef4444', life: 2});
    setTimeout(() => {
        $('ctrl').classList.add('hidden');
        updateHUD();
        if (scores[winner] >= WINS) {
            const wName = gameMode === 'npc' && winner === 1 ? 'CPU' : 'Player ' + (winner + 1);
            showOv('Victory', '', '<span style="color:' + COL[winner] + '">' + wName + '</span> wins the match!', 'Play Again', () => {
                scores = [0, 0];
                showTitle()
            });
            state = 'gameOver'
        } else {
            const wName = gameMode === 'npc' && winner === 1 ? 'CPU' : 'Player ' + (winner + 1);
            showOv('Round Over', '', '<span style="color:' + COL[winner] + '">' + wName + '</span> wins!<br><span style="font-size:15px;opacity:0.4">' + scores[0] + ' — ' + scores[1] + '</span>', 'Next Round', startRound);
            state = 'roundOver'
        }
    }, 1400)
}

function drawTerrain() {
    X.fillStyle = '#0d2610';
    X.beginPath();
    X.moveTo(0, H);
    for (let x = 0; x < W; x += 2) X.lineTo(x, terrain[x] + 10);
    X.lineTo(W, H);
    X.closePath();
    X.fill();
    X.fillStyle = '#162e12';
    X.beginPath();
    X.moveTo(0, H);
    for (let x = 0; x < W; x += 2) X.lineTo(x, terrain[x]);
    X.lineTo(W, H);
    X.closePath();
    X.fill();
    X.strokeStyle = '#3a7c24';
    X.lineWidth = 2;
    X.beginPath();
    for (let x = 0; x < W; x += 2) {
        x === 0 ? X.moveTo(x, terrain[x]) : X.lineTo(x, terrain[x])
    }
    X.stroke();
    X.strokeStyle = 'rgba(90,180,50,0.25)';
    X.lineWidth = 1;
    X.beginPath();
    for (let x = 0; x < W; x += 2) {
        x === 0 ? X.moveTo(x, terrain[x] - 1.5) : X.lineTo(x, terrain[x] - 1.5)
    }
    X.stroke()
}

function drawTank(idx) {
    const t = tanks[idx];
    if (!t || !t.alive) return;
    const dir = idx === 0 ? 1 : -1, rad = t.angle * Math.PI / 180, bl = 22;
    X.fillStyle = 'rgba(0,0,0,0.2)';
    X.beginPath();
    X.ellipse(t.x, t.y + 2, TW / 2 + 4, 4, 0, 0, 6.28);
    X.fill();
    X.fillStyle = COLD[idx];
    rrect(t.x - TW / 2 - 3, t.y - 5, TW + 6, 7, 3);
    X.fillStyle = 'rgba(0,0,0,0.15)';
    for (let i = -TW / 2; i < TW / 2; i += 5) {
        X.fillRect(t.x + i, t.y - 4, 2, 5)
    }
    X.fillStyle = COL[idx];
    rrect(t.x - TW / 2, t.y - TH - 1, TW, TH, 4);
    X.fillStyle = 'rgba(255,255,255,0.08)';
    rrect(t.x - TW / 2 + 2, t.y - TH, TW - 4, TH / 2 - 1, 3);
    X.fillStyle = COL[idx];
    X.beginPath();
    X.arc(t.x, t.y - TH - 1, 8, Math.PI, 0);
    X.fill();
    X.strokeStyle = COLD[idx];
    X.lineWidth = 5;
    X.lineCap = 'round';
    X.beginPath();
    X.moveTo(t.x, t.y - TH - 1);
    X.lineTo(t.x + Math.cos(rad) * dir * bl, t.y - TH - 1 - Math.sin(rad) * bl);
    X.stroke();
    X.strokeStyle = COL[idx];
    X.lineWidth = 3;
    X.beginPath();
    X.moveTo(t.x, t.y - TH - 1);
    X.lineTo(t.x + Math.cos(rad) * dir * bl, t.y - TH - 1 - Math.sin(rad) * bl);
    X.stroke();
    if (t.hp < MAXHP) {
        const bw = 32, bh = 3, bx = t.x - bw / 2, by = t.y - TH - 24;
        X.fillStyle = '#0a1118';
        rrect(bx - 1, by - 1, bw + 2, bh + 2, 2);
        X.fillStyle = t.hp > 50 ? '#4ade80' : t.hp > 25 ? '#fbbf24' : '#ef4444';
        X.fillRect(bx, by, bw * t.hp / MAXHP, bh)
    }
    if (state === 'aiming' && idx === turn) {
        const pulse = 0.5 + Math.sin(Date.now() * 0.005) * 0.4;
        X.fillStyle = COL[idx];
        X.globalAlpha = pulse;
        X.beginPath();
        X.moveTo(t.x, t.y - TH - 32);
        X.lineTo(t.x - 5, t.y - TH - 40);
        X.lineTo(t.x + 5, t.y - TH - 40);
        X.fill();
        X.globalAlpha = 1
    }
}

function rrect(x, y, w, h, r) {
    X.beginPath();
    X.moveTo(x + r, y);
    X.arcTo(x + w, y, x + w, y + h, r);
    X.arcTo(x + w, y + h, x, y + h, r);
    X.arcTo(x, y + h, x, y, r);
    X.arcTo(x, y, x + w, y, r);
    X.closePath();
    X.fill()
}

function drawTrajectory() {
    if (state !== 'aiming' || !tanks[turn]) return;
    if (gameMode === 'npc' && turn === 1) return;
    const t = tanks[turn], dir = turn === 0 ? 1 : -1, rad = t.angle * Math.PI / 180, spd = t.power * SPD, bl = 22;
    let px = t.x + Math.cos(rad) * dir * bl, py = t.y - TH - 1 - Math.sin(rad) * bl;
    let vx = Math.cos(rad) * dir * spd, vy = -Math.sin(rad) * spd;
    const dt = 0.022;
    for (let i = 0; i < 55; i++) {
        vx += wind * dt;
        vy += G * dt;
        px += vx * dt;
        py += vy * dt;
        if (py > H || px < 0 || px > W) break;
        if (px >= 0 && px < W && py >= terrain[Math.floor(px)]) break;
        if (i % 2 === 0) {
            const a = 0.3 * (1 - i / 55);
            X.fillStyle = turn === 0 ? `rgba(59,130,246,${a})` : `rgba(239,68,68,${a})`;
            X.beginPath();
            X.arc(px, py, 1.5, 0, 6.28);
            X.fill()
        }
    }
}

function drawNPCIndicator(ts) {
    if (gameMode !== 'npc' || turn !== 1 || !npcThinking) return;
    const t = tanks[1];
    if (!t) return;
    const dots = 3;
    const baseY = t.y - TH - 45;
    for (let i = 0; i < dots; i++) {
        const phase = ts * 0.004 + i * 1.2;
        const bounce = Math.sin(phase) * 4;
        const alpha = 0.4 + Math.sin(phase) * 0.3;
        X.fillStyle = `rgba(239,68,68,${alpha})`;
        X.beginPath();
        X.arc(t.x - 8 + i * 8, baseY + bounce, 2.5, 0, 6.28);
        X.fill()
    }
}

function drawWindDust(ts) {
    windDust.forEach(d => {
        const drift = wind * 0.012 * d.sp;
        d.x += drift;
        d.y += Math.sin(ts * 0.0008 + d.x * 0.005) * 0.15;
        if (d.x > W + 20) d.x = -20;
        if (d.x < -20) d.x = W + 20;
        X.fillStyle = `rgba(200,210,230,${d.a})`;
        X.beginPath();
        X.arc(d.x, d.y, d.sz, 0, 6.28);
        X.fill()
    })
}

function render(ts) {
    const sx = shake > 0 ? (Math.random() - 0.5) * shake : 0, sy = shake > 0 ? (Math.random() - 0.5) * shake : 0;
    X.save();
    X.translate(sx, sy);
    X.fillStyle = '#0a1118';
    X.fillRect(0, 0, W, H);
    for (const s of stars) {
        const tw = 0.6 + 0.4 * Math.sin(ts * 0.0015 + s.phase);
        X.fillStyle = `rgba(255,255,255,${s.a * tw})`;
        X.beginPath();
        X.arc(s.x, s.y, s.r, 0, 6.28);
        X.fill()
    }
    drawWindDust(ts);
    drawTerrain();
    drawTrajectory();
    drawTank(0);
    drawTank(1);
    drawNPCIndicator(ts);
    if (proj) {
        X.shadowColor = '#fbbf24';
        X.shadowBlur = 16;
        X.fillStyle = '#fbbf24';
        X.beginPath();
        X.arc(proj.x, proj.y, 4, 0, 6.28);
        X.fill();
        X.shadowBlur = 0;
        X.fillStyle = 'rgba(255,247,237,0.7)';
        X.beginPath();
        X.arc(proj.x, proj.y, 2, 0, 6.28);
        X.fill()
    }
    for (const t of trails) {
        X.fillStyle = `rgba(251,191,36,${Math.max(0, t.life * 0.4)})`;
        X.beginPath();
        X.arc(t.x, t.y, 2 * t.life, 0, 6.28);
        X.fill()
    }
    for (const p of particles) {
        if (p.ring) {
            const radius = (1 - p.life) * ER * 3.5;
            X.globalAlpha = Math.max(0, p.life * 0.35);
            X.strokeStyle = p.col;
            X.lineWidth = 1.5;
            X.beginPath();
            X.arc(p.x, p.y, radius, 0, 6.28);
            X.stroke()
        } else {
            X.globalAlpha = Math.max(0, p.life);
            X.fillStyle = p.col;
            X.beginPath();
            X.arc(p.x, p.y, p.sz * p.life, 0, 6.28);
            X.fill()
        }
    }
    X.globalAlpha = 1;
    for (const f of floats) {
        X.globalAlpha = Math.min(1, f.life);
        X.fillStyle = f.col;
        X.font = 'bold 15px system-ui';
        X.textAlign = 'center';
        X.fillText(f.txt, f.x, f.y)
    }
    X.globalAlpha = 1;
    X.restore()
}

function loop(ts) {
    const dt = Math.min((ts - (lastTime || ts)) / 1000, 0.05);
    lastTime = ts;
    particles = particles.filter(p => {
        p.life -= dt * p.decay;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.grav) p.vy += G * dt;
        return p.life > 0
    });
    trails = trails.filter(t => {
        t.life -= dt * 2.8;
        return t.life > 0
    });
    floats = floats.filter(f => {
        f.life -= dt;
        f.y -= 28 * dt;
        return f.life > 0
    });
    if (shake > 0) shake = Math.max(0, shake - dt * 35);
    if (npcThinking && state === 'aiming') {
        npcTimer -= dt;
        if (npcTimer <= 0) {
            npcThinking = false;
            fire()
        }
    }
    if (state === 'firing' && proj) {
        const steps = 5, sd = dt / steps;
        for (let s = 0; s < steps; s++) {
            proj.vx += wind * sd;
            proj.vy += G * sd;
            proj.x += proj.vx * sd;
            proj.y += proj.vy * sd;
            trails.push({x: proj.x, y: proj.y, life: 1});
            const h = hitCheck();
            if (h) {
                if (h === 'miss') {
                    floats.push({x: W / 2, y: H * 0.35, txt: 'MISS', col: '#475569', life: 1.5});
                    proj = null
                } else {
                    explode(proj.x, proj.y);
                    proj = null
                }
                state = 'settling';
                settleWait = 0.7;
                roundChecked = false;
                break
            }
        }
    }
    if (state === 'settling') {
        let settled = true;
        tanks.forEach(t => {
            if (!t || t.hp <= 0) return;
            const g = gy(t.x);
            if (t.y < g - 1) {
                t.y = Math.min(t.y + 280 * dt, g);
                settled = false
            } else t.y = g
        });
        if (settled) {
            settleWait -= dt;
            if (settleWait <= 0) checkRoundEnd()
        }
    }
    render(ts);
    requestAnimationFrame(loop)
}

$('asl').oninput = function () {
    if (state === 'aiming' && tanks[turn]) {
        tanks[turn].angle = +this.value;
        $('aval').textContent = this.value + '°'
    }
};
$('psl').oninput = function () {
    if (state === 'aiming' && tanks[turn]) {
        tanks[turn].power = +this.value;
        $('pval').textContent = this.value
    }
};
$('fireBtn').onclick = fire;
document.addEventListener('keydown', e => {
    if (state !== 'aiming' || !tanks[turn]) return;
    if (gameMode === 'npc' && turn === 1) return;
    const t = tanks[turn];
    let ok = true;
    switch (e.key) {
        case'ArrowUp':
            t.angle = Math.min(85, t.angle + 1);
            syncSliders();
            break;
        case'ArrowDown':
            t.angle = Math.max(5, t.angle - 1);
            syncSliders();
            break;
        case'ArrowRight':
            t.power = Math.min(100, t.power + 1);
            syncSliders();
            break;
        case'ArrowLeft':
            t.power = Math.max(10, t.power - 1);
            syncSliders();
            break;
        case' ':
            fire();
            break;
        default:
            ok = false
    }
    if (ok) e.preventDefault()
});
document.querySelectorAll('.adj-btn').forEach(btn => {
    let interval = null;
    const doAdj = () => {
        if (state !== 'aiming' || !tanks[turn]) return;
        if (gameMode === 'npc' && turn === 1) return;
        const target = $(btn.dataset.target);
        const dir = parseInt(btn.dataset.dir);
        const t = tanks[turn];
        if (btn.dataset.target === 'asl') {
            t.angle = Math.max(5, Math.min(85, t.angle + dir));
            target.value = t.angle;
            $('aval').textContent = t.angle + '°'
        } else {
            t.power = Math.max(10, Math.min(100, t.power + dir));
            target.value = t.power;
            $('pval').textContent = t.power
        }
    };
    btn.addEventListener('pointerdown', e => {
        e.preventDefault();
        doAdj();
        interval = setInterval(doAdj, 100)
    });
    btn.addEventListener('pointerup', () => clearInterval(interval));
    btn.addEventListener('pointerleave', () => clearInterval(interval))
});

function setupMobileAdjButtons() {
    const ctrl = $('ctrl');
    const existingAdj = ctrl.querySelectorAll('.mob-adj-wrap');
    existingAdj.forEach(e => e.remove());
    if (!isMobile()) return;
    const cgs = ctrl.querySelectorAll('.cg');
    cgs.forEach(cg => {
        const slider = cg.querySelector('input[type=range]');
        if (!slider) return;
        const id = slider.id;
        const minusBefore = document.createElement('div');
        minusBefore.className = 'mob-adj-wrap';
        minusBefore.style.display = 'flex';
        minusBefore.innerHTML = `<button class="adj-btn" data-target="${id}" data-dir="-1">−</button>`;
        const plusAfter = document.createElement('div');
        plusAfter.className = 'mob-adj-wrap';
        plusAfter.style.display = 'flex';
        plusAfter.innerHTML = `<button class="adj-btn" data-target="${id}" data-dir="1">+</button>`;
        slider.parentNode.insertBefore(minusBefore, slider);
        slider.after(plusAfter);
        [minusBefore.querySelector('.adj-btn'), plusAfter.querySelector('.adj-btn')].forEach(btn => {
            let interval = null;
            const doAdj = () => {
                if (state !== 'aiming' || !tanks[turn]) return;
                if (gameMode === 'npc' && turn === 1) return;
                const target = $(btn.dataset.target);
                const dir = parseInt(btn.dataset.dir);
                const t = tanks[turn];
                if (btn.dataset.target === 'asl') {
                    t.angle = Math.max(5, Math.min(85, t.angle + dir));
                    target.value = t.angle;
                    $('aval').textContent = t.angle + '°'
                } else {
                    t.power = Math.max(10, Math.min(100, t.power + dir));
                    target.value = t.power;
                    $('pval').textContent = t.power
                }
            };
            btn.addEventListener('pointerdown', e => {
                e.preventDefault();
                doAdj();
                interval = setInterval(doAdj, 100)
            });
            btn.addEventListener('pointerup', () => clearInterval(interval));
            btn.addEventListener('pointerleave', () => clearInterval(interval))
        })
    })
}

function showTitle() {
    const o = $('ov');
    o.classList.remove('hidden');
    o.innerHTML = `<h1>Artillery</h1><div class="sub">Turn-based tank battle · First to 3 wins</div><div class="mode-select"><button class="mode-btn${gameMode === 'pvp' ? ' active' : ''}" id="modePvP">2 Player</button><button class="mode-btn${gameMode === 'npc' ? ' active' : ''}" id="modeNPC">vs CPU</button></div><div class="diff-select${gameMode === 'npc' ? ' show' : ''}" id="diffSelect"><button class="diff-btn${difficulty === 'easy' ? ' active' : ''}" id="diffEasy">Easy</button><button class="diff-btn${difficulty === 'medium' ? ' active' : ''}" id="diffMed">Medium</button><button class="diff-btn${difficulty === 'hard' ? ' active' : ''}" id="diffHard">Hard</button></div><button class="start" id="startBtn">Start Game</button>`;
    $('modePvP').onclick = () => {
        gameMode = 'pvp';
        o.querySelector('.mode-select').querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        $('modePvP').classList.add('active');
        $('diffSelect').classList.remove('show')
    };
    $('modeNPC').onclick = () => {
        gameMode = 'npc';
        o.querySelector('.mode-select').querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        $('modeNPC').classList.add('active');
        $('diffSelect').classList.add('show')
    };
    $('diffEasy').onclick = () => {
        difficulty = 'easy';
        o.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
        $('diffEasy').classList.add('active')
    };
    $('diffMed').onclick = () => {
        difficulty = 'medium';
        o.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
        $('diffMed').classList.add('active')
    };
    $('diffHard').onclick = () => {
        difficulty = 'hard';
        o.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
        $('diffHard').classList.add('active')
    };
    $('startBtn').onclick = () => {
        scores = [0, 0];
        setupMobileAdjButtons();
        startRound()
    }
}

function nextTurnFixed() {
    turn = 1 - turn;
    newWind();
    syncSliders();
    updateHUD();
    state = 'turnBanner';
    showTurnBanner(() => {
        if (gameMode === 'npc' && turn === 1) {
            state = 'aiming';
            startNPCTurn()
        } else {
            $('ctrl').classList.remove('hidden');
            state = 'aiming'
        }
    })
}

window.addEventListener('resize', () => {
    const oldW = W || innerWidth;
    resize();
    if (tanks.length === 2 && state !== 'title' && state !== 'gameOver' && state !== 'roundOver') {
        tanks.forEach(t => {
            t.x = Math.round(t.x * W / oldW)
        });
        genTerrain();
        placeTanks()
    }
    genStars();
    initWindDust();
    setupMobileAdjButtons()
});
resize();
genStars();
initWindDust();
showTitle();
requestAnimationFrame(loop)
</script>
<script src="../logo.js"></script>
</body>
</html>