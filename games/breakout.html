<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Remastered</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß±</text></svg>">
    <style>
        :root {
            --primary-color: #2a2a72;
            --secondary-color: #009ffd;
            --accent-color: #ff7e5f;
            --background-color: #121212;
            --text-color: #ffffff;
            --paddle-color: linear-gradient(to right, #ff9966, #ff5e62);
            --ball-glow: 0 0 10px rgba(255, 255, 255, 0.7);
            --game-width: 600px;
            --game-height: 500px;
            --ui-blue: #0099ff;
            --ui-purple: #191b3a;
            --ui-pink: #ff6b97;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .game-container {
            position: relative;
            width: var(--game-width);
            margin: 20px auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 2px solid var(--secondary-color);
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .title-blue {
            color: var(--ui-blue);
        }

        .title-purple {
            color: #666;
        }

        .title-pink {
            color: var(--ui-pink);
        }

        .game-subtitle {
            color: #aaa;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            width: 100%;
            padding: 0 10px;
        }

        .stat {
            background: var(--ui-purple);
            padding: 10px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-icon {
            margin-right: 8px;
            font-size: 1.2rem;
        }

        #game-board {
            width: var(--game-width);
            height: var(--game-height);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                    linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
        }

        .ball {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, white, var(--secondary-color));
            position: absolute;
            filter: drop-shadow(var(--ball-glow));
            z-index: 10;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .ball-trail {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            filter: blur(3px);
            z-index: 5;
            opacity: 0;
            transform: translate(-50%, -50%);
            animation: fadeOut 0.5s ease-out forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 0.5; }
            100% { opacity: 0; }
        }

        .paddle {
            height: 20px;
            background: var(--paddle-color);
            position: absolute;
            bottom: 20px;
            border-radius: 10px;
            z-index: 10;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 94, 98, 0.7);
            transform: translateX(-50%);
        }

        .paddle-glow {
            position: absolute;
            bottom: 20px;
            height: 20px;
            border-radius: 10px;
            background: transparent;
            box-shadow: 0 0 20px 5px rgba(255, 94, 98, 0.5);
            filter: blur(3px);
            opacity: 0.7;
            z-index: 9;
            transform: translateX(-50%);
        }

        .brick {
            position: absolute;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-align: center;
            line-height: 25px;
            font-weight: bold;
            font-size: 12px;
            transition: opacity 0.1s;
            background-size: cover;
            transform: translateZ(0);
        }

        .powerup {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            z-index: 8;
            animation: pulse 1.5s infinite ease-in-out;
            text-align: center;
            line-height: 30px;
            font-size: 18px;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            z-index: 7;
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .explosion {
            position: absolute;
            border-radius: 50%;
            z-index: 15;
            background: radial-gradient(circle, #fff, #ff7e5f);
            opacity: 0.9;
            animation: explode 0.5s forwards;
            transform: translate(-50%, -50%);
        }

        @keyframes explode {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        .level-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 20;
            box-shadow: 0 0 10px rgba(0, 159, 253, 0.5);
            border: 1px solid var(--secondary-color);
        }

        /* Game Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(18, 18, 18, 0.9);
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            text-align: center;
            padding: 20px;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .screen h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(to right, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .screen p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(to right, var(--secondary-color), var(--accent-color));
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .controls-info {
            display: flex;
            background: rgba(25, 27, 58, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-width: 80%;
            gap: 20px;
        }

        .controls-column {
            flex: 1;
            padding: 10px;
            text-align: left;
        }

        .controls-column h3 {
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
        }

        .controls-column p {
            font-size: 0.95rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Level Transition */
        .level-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 40;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .level-transition.active {
            opacity: 1;
            pointer-events: all;
        }

        .level-message {
            font-size: 3rem;
            color: white;
            text-align: center;
            animation: scaleIn 0.5s ease-out;
        }

        @keyframes scaleIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Active Effects */
        .effect-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 20;
        }

        .effect {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid;
            opacity: 0.7;
            position: relative;
        }

        .effect .timer {
            position: absolute;
            bottom: -5px;
            left: 0;
            height: 3px;
            width: 100%;
            background: white;
            border-radius: 3px;
            transform-origin: left;
        }

        /* Mobile touch controls */
        .mobile-controls {
            display: none;
            width: 100%;
            padding: 20px 0;
            justify-content: space-between;
        }

        .touch-area {
            width: 48%;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        /* Game canvas backdrop */
        .game-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        /* Media queries */
        @media (max-width: 768px) {
            :root {
                --game-width: 100%;
                --game-height: 400px;
            }

            .game-container {
                width: 95%;
                padding: 0 10px;
            }

            .game-title {
                font-size: 2rem;
            }

            .mobile-controls {
                display: flex;
            }

            .controls-info {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-header">
        <div>
            <h1 class="game-title">
                <span class="title-blue">BREAKOUT</span>
                <span class="title-purple">REMASTERED</span>
            </h1>
            <p class="game-subtitle">GPTGames Edition</p>
        </div>
    </div>

    <div class="game-stats">
        <div class="stat">
            <span class="stat-icon">üèÜ</span>
            <span id="score">Score: 0</span>
        </div>
        <div class="stat">
            <span class="stat-icon">‚ù§Ô∏è</span>
            <span id="lives">Lives: 3</span>
        </div>
        <div class="stat">
            <span class="stat-icon">üî•</span>
            <span id="combo">Combo: x1</span>
        </div>
    </div>

    <div id="game-board">
        <div class="level-indicator">Level <span id="level-num">1</span></div>
        <div class="grid-overlay"></div>
        <div class="game-backdrop"></div>
        <div class="ball"></div>
        <div class="paddle-glow"></div>
        <div class="paddle"></div>
        <div class="effect-indicator"></div>

        <!-- Game screens -->
        <div id="start-screen" class="screen active">
            <h2>Breakout Remastered</h2>
            <p>The classic brick-breaker game, redesigned with modern visuals and exciting new features!</p>
            <button id="start-btn" class="btn">Start Game</button>
            <div class="controls-info">
                <div class="controls-column">
                    <h3>Controls:</h3>
                    <p>Mouse or Arrow Keys to move paddle</p>
                    <p>P to pause the game</p>
                    <p>Space to launch ball</p>
                </div>
                <div class="controls-column">
                    <h3>Power-Ups:</h3>
                    <p>üìè Paddle Size</p>
                    <p>üî• Fireball</p>
                    <p>‚ö° Speed</p>
                    <p>‚ù§Ô∏è Extra Life</p>
                    <p>üß≤ Sticky Paddle</p>
                </div>
            </div>
        </div>

        <div id="level-complete-screen" class="screen">
            <h2>Level Complete!</h2>
            <p>You've cleared all the bricks! Ready for the next challenge?</p>
            <button id="next-level-btn" class="btn">Next Level</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h2>Game Over</h2>
            <p>Your final score: <span id="final-score">0</span></p>
            <button id="restart-btn" class="btn">Play Again</button>
        </div>

        <div id="pause-screen" class="screen">
            <h2>Game Paused</h2>
            <button id="resume-btn" class="btn">Resume Game</button>
            <button id="restart-from-pause-btn" class="btn">Restart Game</button>
        </div>

        <div id="game-complete-screen" class="screen">
            <h2>You Win!</h2>
            <p>Congratulations! You've completed all 10 levels of Breakout Remastered!</p>
            <p>Final Score: <span id="final-complete-score">0</span></p>
            <button id="play-again-btn" class="btn">Play Again</button>
        </div>

        <div class="level-transition">
            <div class="level-message">Level <span id="transition-level">1</span></div>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="touch-area" id="touch-left">‚óÄ</div>
        <div class="touch-area" id="touch-right">‚ñ∂</div>
    </div>
</div>

<script>
    // Game configuration
    const config = {
        paddleWidth: 100,
        paddleHeight: 20,
        ballSize: 16,
        initialBallSpeed: 4,
        maxBallSpeed: 12,
        boardWidth: 0, // Will be calculated on init
        boardHeight: 0, // Will be calculated on init
        brickRowCount: 5,
        brickColumnCount: 10,
        brickWidth: 50,
        brickHeight: 25,
        brickPadding: 5,
        brickOffsetTop: 50,
        brickOffsetLeft: 30,
        maxLevels: 10,
        comboTimeout: 2000, // milliseconds before combo resets
        powerupChance: 0.2, // chance of brick dropping powerup
        powerupSpeed: 2,
        particleCount: 15, // particles when breaking a brick
        effectDuration: 10000, // powerup effect duration in ms
        touchSensitivity: 10, // for mobile controls
        shakeIntensity: 5,  // max pixels for screen shake
        shakeDuration: 300, // ms for screen shake
    };

    // Game state
    const state = {
        score: 0,
        lives: 3,
        level: 1,
        running: false,
        combo: 1,
        lastBrickHit: 0,
        paused: false,
        bricks: [],
        powerups: [],
        particles: [],
        effects: [],
        trails: [],
        keyStates: {
            left: false,
            right: false,
            space: false
        },
        touchActive: {
            left: false,
            right: false
        },
        transitionActive: false,
        launchReady: true
    };

    // Get DOM elements
    const elements = {
        gameBoard: document.getElementById('game-board'),
        ball: document.querySelector('.ball'),
        paddle: document.querySelector('.paddle'),
        paddleGlow: document.querySelector('.paddle-glow'),
        scoreDisplay: document.getElementById('score'),
        livesDisplay: document.getElementById('lives'),
        comboDisplay: document.getElementById('combo'),
        levelDisplay: document.getElementById('level-num'),
        transitionLevel: document.getElementById('transition-level'),
        levelTransition: document.querySelector('.level-transition'),
        effectIndicator: document.querySelector('.effect-indicator'),
        startScreen: document.getElementById('start-screen'),
        levelCompleteScreen: document.getElementById('level-complete-screen'),
        gameOverScreen: document.getElementById('game-over-screen'),
        pauseScreen: document.getElementById('pause-screen'),
        gameCompleteScreen: document.getElementById('game-complete-screen'),
        finalScore: document.getElementById('final-score'),
        finalCompleteScore: document.getElementById('final-complete-score'),
        startBtn: document.getElementById('start-btn'),
        nextLevelBtn: document.getElementById('next-level-btn'),
        restartBtn: document.getElementById('restart-btn'),
        resumeBtn: document.getElementById('resume-btn'),
        restartFromPauseBtn: document.getElementById('restart-from-pause-btn'),
        playAgainBtn: document.getElementById('play-again-btn'),
        touchLeft: document.getElementById('touch-left'),
        touchRight: document.getElementById('touch-right'),
        gameBackdrop: document.querySelector('.game-backdrop')
    };

    // Ball properties
    const ball = {
        x: 0, // Will be set on init
        y: 0, // Will be set on init
        dx: 0,
        dy: 0,
        speed: config.initialBallSpeed,
        launched: false,
        radius: config.ballSize / 2,
        fireball: false
    };

    // Paddle properties
    const paddle = {
        width: config.paddleWidth,
        height: config.paddleHeight,
        x: 0, // Will be set on init
        speed: 8,
        sticky: false
    };

    // Define brick types
    const brickTypes = {
        normal: { color: '#4CC9F0', hits: 1, points: 10 },
        strong: { color: '#4361EE', hits: 2, points: 20 },
        ultra: { color: '#3A0CA3', hits: 3, points: 30 },
        explosive: { color: '#F72585', hits: 1, points: 15, explodes: true },
        indestructible: { color: '#333333', hits: Infinity, points: 0 },
        rainbow: {
            color: 'linear-gradient(to right, #ff0000, #ff9900, #33cc33, #3399ff, #cc33ff)',
            hits: 1,
            points: 25,
            special: 'rainbow'
        }
    };

    // Define powerup types
    const powerupTypes = {
        paddleSize: { color: '#4CC9F0', symbol: 'üìè', effect: 'increasePaddle' },
        extraLife: { color: '#F72585', symbol: '‚ù§Ô∏è', effect: 'extraLife' },
        fireball: { color: '#FF9E00', symbol: 'üî•', effect: 'fireball' },
        multiball: { color: '#7209B7', symbol: 'üîÆ', effect: 'multiball' },
        speedUp: { color: '#4361EE', symbol: '‚ö°', effect: 'speedUp' },
        stickyPaddle: { color: '#80ED99', symbol: 'üß≤', effect: 'stickyPaddle' }
    };

    // Level data - each array defines brick types for a level
    const levelData = [
        // Level 1 - Basic intro level
        {
            rows: 4,
            cols: 8,
            bricks: [
                Array(8).fill('normal'),
                Array(8).fill('normal'),
                Array(8).fill('normal'),
                Array(8).fill('normal')
            ],
            ballSpeed: 1.0
        },
        // Level 2 - Introduce strong bricks
        {
            rows: 5,
            cols: 9,
            bricks: [
                Array(9).fill('normal'),
                Array(9).fill('normal'),
                '111STRONG111'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                Array(9).fill('normal'),
                Array(9).fill('normal')
            ],
            ballSpeed: 1.1
        },
        // Level 3 - Shapes and patterns
        {
            rows: 5,
            cols: 10,
            bricks: [
                'NNSSNNSSNN'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NSNNNNNNNS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'NSNNNNNNNS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NNSSNNSSNN'.split('').map(b => b === 'S' ? 'strong' : 'normal')
            ],
            ballSpeed: 1.2
        },
        // Level 4 - Introduce explosive bricks
        {
            rows: 6,
            cols: 10,
            bricks: [
                Array(10).fill('strong'),
                'NNENENENEN'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                Array(10).fill('normal'),
                Array(10).fill('normal'),
                'ENENENENNN'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                Array(10).fill('strong')
            ],
            ballSpeed: 1.25
        },
        // Level 5 - Introduce Ultra and Indestructible bricks
        {
            rows: 6,
            cols: 10,
            bricks: [
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'IINNNNNNII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal'))
            ],
            ballSpeed: 1.3
        },
        // Level 6 - Complex patterns
        {
            rows: 7,
            cols: 10,
            bricks: [
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNEENNEEII'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNSSSSSSNN'.split('').map(b => b === 'S' ? 'strong' : (b === 'I' ? 'indestructible' : 'normal')),
                'UUUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNSSSSSSNN'.split('').map(b => b === 'S' ? 'strong' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNEENNEEII'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : (b === 'I' ? 'indestructible' : 'normal'))
            ],
            ballSpeed: 1.35
        },
        // Level 7 - Blocker pattern
        {
            rows: 7,
            cols: 10,
            bricks: [
                Array(10).fill('normal'),
                'NNIINNIINN'.split('').map(b => b === 'I' ? 'indestructible' : 'normal'),
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'IINNSSNNII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NNIINNIINN'.split('').map(b => b === 'I' ? 'indestructible' : 'normal'),
                Array(10).fill('normal')
            ],
            ballSpeed: 1.4
        },
        // Level 8 - Rainbow challenges
        {
            rows: 8,
            cols: 10,
            bricks: [
                'RRRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'SSSSSSSSSS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'EEEEEEEEEE'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                'IISSIISSII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IISSIISSII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'EEEEEEEEEE'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                'SSSSSSSSSS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'RRRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal')
            ],
            ballSpeed: 1.45
        },
        // Level 9 - Ultra challenge
        {
            rows: 8,
            cols: 10,
            bricks: [
                'IUIUIUIUIU'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'UIUIUIUIUI'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'REREREREIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'R' ? 'rainbow' : 'normal'))),
                'SESESEIESE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal'))),
                'SESESEIESE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal'))),
                'REREREREIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'R' ? 'rainbow' : 'normal'))),
                'UIUIUIUIUI'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'IUIUIUIUIU'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal'))
            ],
            ballSpeed: 1.5
        },
        // Level 10 - Final boss level
        {
            rows: 10,
            cols: 10,
            bricks: [
                'RRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'UUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'EIEIEIEIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'EIEIEIEIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'UUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'RRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal')
            ],
            ballSpeed: 1.6
        }
    ];

    // Initialize game
    function init() {
        // Get actual board dimensions
        config.boardWidth = elements.gameBoard.offsetWidth;
        config.boardHeight = elements.gameBoard.offsetHeight;

        // Set up the paddle
        paddle.x = config.boardWidth / 2;
        elements.paddle.style.width = paddle.width + 'px';
        elements.paddle.style.height = paddle.height + 'px';
        elements.paddle.style.left = paddle.x + 'px';

        // Set up paddle glow
        elements.paddleGlow.style.width = paddle.width + 'px';
        elements.paddleGlow.style.left = paddle.x + 'px';

        // Reset ball position
        resetBall();

        // Reset game state
        state.score = 0;
        state.lives = 3;
        state.level = 1;
        state.combo = 1;
        state.powerups = [];
        state.particles = [];
        state.effects = [];
        state.trails = [];
        state.transitionActive = false;
        state.launchReady = true;

        // Update displays
        updateScoreDisplay();
        updateLivesDisplay();
        updateComboDisplay();
        updateLevelDisplay();

        // Clear any existing elements
        clearBricks();
        clearPowerups();
        clearParticles();

        // Build the level
        buildLevel(state.level);

        // Set up event listeners
        setupEventListeners();
    }

    // Set up event listeners
    function setupEventListeners() {
        // Mouse movement
        elements.gameBoard.addEventListener('mousemove', (e) => {
            if (state.running && !state.paused) {
                const relativeX = e.clientX - elements.gameBoard.getBoundingClientRect().left;
                if (relativeX > 0 && relativeX < config.boardWidth) {
                    paddle.x = relativeX;
                    updatePaddlePosition();
                }
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                state.keyStates.left = true;
            } else if (e.key === 'ArrowRight') {
                state.keyStates.right = true;
            } else if (e.key === ' ') {
                // Fix: Only process space if game is running and level transition is not active
                state.keyStates.space = true;
                if (state.running && !state.paused && !state.transitionActive && state.launchReady && !ball.launched) {
                    launchBall();
                }
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                state.keyStates.left = false;
            } else if (e.key === 'ArrowRight') {
                state.keyStates.right = false;
            } else if (e.key === ' ') {
                state.keyStates.space = false;
            }
        });

        // Touch controls for mobile
        elements.touchLeft.addEventListener('touchstart', () => {
            state.touchActive.left = true;
        });

        elements.touchRight.addEventListener('touchstart', () => {
            state.touchActive.right = true;
        });

        elements.touchLeft.addEventListener('touchend', () => {
            state.touchActive.left = false;
        });

        elements.touchRight.addEventListener('touchend', () => {
            state.touchActive.right = false;
        });

        // Button event listeners
        elements.startBtn.addEventListener('click', startGame);
        elements.nextLevelBtn.addEventListener('click', nextLevel);
        elements.restartBtn.addEventListener('click', restartGame);
        elements.resumeBtn.addEventListener('click', resumeGame);
        elements.restartFromPauseBtn.addEventListener('click', restartGame);
        elements.playAgainBtn.addEventListener('click', restartGame);
    }

    // Start the game
    function startGame() {
        hideAllScreens();
        state.running = true;
        state.paused = false;
        resetBall();
        showLevelTransition();
        gameLoop();
    }

    // Restart the game
    function restartGame() {
        hideAllScreens();
        init();
        startGame();
    }

    // Resume from pause
    function resumeGame() {
        state.paused = false;
        hideAllScreens();
        gameLoop();
    }

    // Toggle game pause
    function togglePause() {
        if (!state.running) return;

        state.paused = !state.paused;

        if (state.paused) {
            elements.pauseScreen.classList.add('active');
        } else {
            elements.pauseScreen.classList.remove('active');
            requestAnimationFrame(gameLoop);
        }
    }

    // Hide all screens
    function hideAllScreens() {
        elements.startScreen.classList.remove('active');
        elements.levelCompleteScreen.classList.remove('active');
        elements.gameOverScreen.classList.remove('active');
        elements.pauseScreen.classList.remove('active');
        elements.gameCompleteScreen.classList.remove('active');
    }

    // Show level transition
    function showLevelTransition() {
        elements.transitionLevel.textContent = state.level;
        elements.levelTransition.classList.add('active');
        state.transitionActive = true;

        setTimeout(() => {
            elements.levelTransition.classList.remove('active');
            state.transitionActive = false;
        }, 1500);
    }

    // Move to next level
    function nextLevel() {
        // Fix: Set state.launchReady to false until level is fully loaded
        state.launchReady = false;
        state.level++;

        if (state.level > config.maxLevels) {
            gameComplete();
            return;
        }

        clearBricks();
        clearPowerups();
        clearParticles();
        resetBall();
        updateLevelDisplay();
        buildLevel(state.level);
        hideAllScreens();
        showLevelTransition();

        // Fix: Re-enable ball launching after level transition completes
        setTimeout(() => {
            state.launchReady = true;
        }, 1500);

        gameLoop();
    }

    // Game completed
    function gameComplete() {
        state.running = false;
        elements.finalCompleteScore.textContent = state.score;
        elements.gameCompleteScreen.classList.add('active');
    }

    // Game loop
    function gameLoop() {
        if (!state.running || state.paused) return;

        // Process keyboard/touch input
        handleInput();

        // Update ball position
        if (ball.launched) {
            moveBall();
        } else {
            // Ball follows paddle until launched
            ball.x = paddle.x;
            updateBallPosition();
        }

        // Update powerups
        updatePowerups();

        // Update particles
        updateParticles();

        // Update ball trails
        updateTrails();

        // Update effects timers
        updateEffects();

        // Check combo timeout
        checkComboTimeout();

        requestAnimationFrame(gameLoop);
    }

    // Handle keyboard/touch input
    function handleInput() {
        if (state.keyStates.left || state.touchActive.left) {
            paddle.x -= paddle.speed;
            if (paddle.x < paddle.width / 2) {
                paddle.x = paddle.width / 2;
            }
        }

        if (state.keyStates.right || state.touchActive.right) {
            paddle.x += paddle.speed;
            if (paddle.x > config.boardWidth - paddle.width / 2) {
                paddle.x = config.boardWidth - paddle.width / 2;
            }
        }

        updatePaddlePosition();
    }

    // Launch the ball
    function launchBall() {
        if (!ball.launched && state.launchReady) {
            ball.launched = true;

            // Random angle between -45 and 45 degrees
            const angle = (Math.random() * 90 - 45) * Math.PI / 180;
            ball.dx = ball.speed * Math.sin(angle);
            ball.dy = -ball.speed * Math.cos(angle);
        }
    }

    // Update paddle position
    function updatePaddlePosition() {
        elements.paddle.style.left = paddle.x + 'px';
        elements.paddleGlow.style.left = paddle.x + 'px';
    }

    // Update ball position
    function updateBallPosition() {
        // Fix: Center the ball properly
        elements.ball.style.left = ball.x + 'px';
        elements.ball.style.top = ball.y + 'px';
    }

    // Apply screen shake effect
    function shakeScreen(intensity = 1) {
        if (!elements.gameBoard.style.transform) {
            const shakeAmount = config.shakeIntensity * intensity;
            const startTime = Date.now();

            function shake() {
                const elapsed = Date.now() - startTime;

                if (elapsed < config.shakeDuration) {
                    const xShake = (Math.random() - 0.5) * shakeAmount;
                    const yShake = (Math.random() - 0.5) * shakeAmount;
                    elements.gameBoard.style.transform = `translate(${xShake}px, ${yShake}px)`;
                    requestAnimationFrame(shake);
                } else {
                    elements.gameBoard.style.transform = 'translate(0px, 0px)';
                }
            }

            shake();
        }
    }

    // Move the ball
    function moveBall() {
        // Add trail effect
        if (Math.random() > 0.7) {
            addTrail();
        }

        // Update ball position
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Check for collisions with walls
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > config.boardWidth) {
            ball.dx = -ball.dx;

            // Adjust position to prevent sticking to wall
            if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
            } else {
                ball.x = config.boardWidth - ball.radius;
            }
        }

        if (ball.y - ball.radius < 0) {
            ball.dy = -ball.dy;
            ball.y = ball.radius;
        }

        // Check for collision with paddle
        const paddleTop = config.boardHeight - config.paddleHeight - 20; // -20 because paddle is 20px from bottom

        // Fix: Improved paddle collision detection that focuses on top of paddle
        if (ball.y + ball.radius > paddleTop &&
            ball.y - ball.radius < paddleTop + 10 && // Only check top portion of paddle
            ball.x > paddle.x - paddle.width / 2 &&
            ball.x < paddle.x + paddle.width / 2) {

            // Calculate rebound angle based on where ball hits paddle
            const hitPosition = (ball.x - paddle.x) / (paddle.width / 2);
            const angle = hitPosition * Math.PI / 3; // Max angle of 60 degrees

            // Set new direction
            ball.dx = ball.speed * Math.sin(angle);
            ball.dy = -ball.speed * Math.cos(angle);

            // Position adjustment to prevent sticking
            ball.y = paddleTop - ball.radius;

            // Handle sticky paddle power-up
            if (paddle.sticky && hasEffect('stickyPaddle')) {
                ball.launched = false;
            }
        }

        // Check if ball is out of bounds (bottom)
        if (ball.y + ball.radius > config.boardHeight) {
            loseLife();
            return;
        }

        // Check for collisions with bricks
        checkBrickCollisions();

        // Update ball position in DOM
        updateBallPosition();
    }

    // Add ball trail effect
    function addTrail() {
        const trail = document.createElement('div');
        trail.classList.add('ball-trail');
        trail.style.width = config.ballSize + 'px';
        trail.style.height = config.ballSize + 'px';
        trail.style.left = ball.x + 'px';
        trail.style.top = ball.y + 'px';

        if (ball.fireball) {
            trail.style.backgroundColor = 'rgba(255, 89, 0, 0.5)';
        }

        elements.gameBoard.appendChild(trail);

        state.trails.push({
            element: trail,
            timeCreated: Date.now()
        });
    }

    // Update ball trails
    function updateTrails() {
        const currentTime = Date.now();
        const trailsToRemove = [];

        state.trails.forEach((trail, index) => {
            if (currentTime - trail.timeCreated > 500) {
                trail.element.remove();
                trailsToRemove.push(index);
            }
        });

        // Remove expired trails from array (in reverse to not affect indexes)
        for (let i = trailsToRemove.length - 1; i >= 0; i--) {
            state.trails.splice(trailsToRemove[i], 1);
        }
    }

    // Check for brick collisions
    function checkBrickCollisions() {
        let collision = false;

        for (let i = 0; i < state.bricks.length; i++) {
            const brick = state.bricks[i];

            if (brick.hits <= 0 || brick.type === 'indestructible' && brick.hit) continue;

            // Check if ball collides with this brick
            if (ball.x + ball.radius > brick.x &&
                ball.x - ball.radius < brick.x + brick.width &&
                ball.y + ball.radius > brick.y &&
                ball.y - ball.radius < brick.y + brick.height) {

                // Fireball breaks through without bouncing
                if (!ball.fireball || brick.type === 'indestructible') {
                    // Determine collision side (top/bottom or left/right)
                    const ballBottom = ball.y + ball.radius;
                    const ballTop = ball.y - ball.radius;
                    const ballRight = ball.x + ball.radius;
                    const ballLeft = ball.x - ball.radius;

                    const brickBottom = brick.y + brick.height;
                    const brickTop = brick.y;
                    const brickRight = brick.x + brick.width;
                    const brickLeft = brick.x;

                    // Calculate overlap on each side
                    const bottomOverlap = ballBottom - brickTop;
                    const topOverlap = brickBottom - ballTop;
                    const rightOverlap = ballRight - brickLeft;
                    const leftOverlap = brickRight - ballLeft;

                    // Find smallest overlap (which is the side we hit)
                    const overlaps = [bottomOverlap, topOverlap, leftOverlap, rightOverlap];
                    const minOverlap = Math.min(...overlaps);

                    // Bounce based on collision side
                    if (minOverlap === bottomOverlap || minOverlap === topOverlap) {
                        ball.dy = -ball.dy;
                    } else {
                        ball.dx = -ball.dx;
                    }
                }

                // Handle the brick hit
                if (brick.type !== 'indestructible' || !brick.hit) {
                    collision = true;
                    hitBrick(i);
                }

                // If not a fireball or if it's an indestructible brick, can return after first collision
                if (!ball.fireball || brick.type === 'indestructible') {
                    return;
                }
            }
        }

        // Reset combo if no collision
        if (!collision && ball.dy < 0) {
            state.combo = 1;
            updateComboDisplay();
        }
    }

    // Hit a brick
    function hitBrick(index) {
        const brick = state.bricks[index];

        // Mark indestructible bricks as hit
        if (brick.type === 'indestructible') {
            brick.hit = true;
            brick.element.style.opacity = '0.5';
            return;
        }

        // Reduce hits remaining
        brick.hits--;

        // Update brick appearance based on hits remaining
        if (brick.hits > 0) {
            // More hits needed, just update appearance
            updateBrickAppearance(brick);
        } else {
            // Brick is destroyed
            destroyBrick(index);
        }

        // Update combo
        updateCombo();
    }

    // Update brick appearance based on hits remaining
    function updateBrickAppearance(brick) {
        // Get original brick color
        const originalType = Object.keys(brickTypes).find(type => {
            return brick.originalType === type;
        });

        if (originalType === 'strong') {
            brick.element.style.backgroundColor = '#7B5FFF';
        } else if (originalType === 'ultra') {
            brick.element.style.backgroundColor = brick.hits === 2 ? '#5E2BFF' : '#7209B7';
        }

        // Add hit effect
        brick.element.style.transform = 'scale(0.95)';
        setTimeout(() => {
            if (brick.element) {
                brick.element.style.transform = 'scale(1)';
            }
        }, 100);
    }

    // Destroy a brick
    function destroyBrick(index) {
        const brick = state.bricks[index];

        // Add score based on brick type and combo
        const brickType = brickTypes[brick.type];
        const points = brickType.points * state.combo;
        state.score += points;
        updateScoreDisplay();

        // Show points gained with floating text
        showFloatingText(`+${points}`, brick.x + brick.width / 2, brick.y + brick.height / 2);

        // Create particles
        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);

        // Check for powerup drop
        if (Math.random() < config.powerupChance) {
            dropPowerup(brick.x + brick.width / 2, brick.y + brick.height / 2);
        }

        // Handle explosive bricks
        if (brick.type === 'explosive') {
            createExplosion(brick.x + brick.width / 2, brick.y + brick.height / 2);
            explodeAdjacentBricks(index);
            shakeScreen(1.5);
        }

        // Remove brick element
        brick.element.remove();
        state.bricks.splice(index, 1);

        // Check if level is complete
        checkLevelComplete();
    }

    // Check if level is complete
    function checkLevelComplete() {
        // Count remaining breakable bricks
        const remainingBricks = state.bricks.filter(brick =>
            brick.type !== 'indestructible' && brick.hits > 0
        ).length;

        if (remainingBricks === 0) {
            levelComplete();
        }
    }

    // Level complete
    function levelComplete() {
        state.running = false;

        if (state.level === config.maxLevels) {
            // Game complete
            setTimeout(() => {
                gameComplete();
            }, 1000);
        } else {
            // Next level
            setTimeout(() => {
                elements.levelCompleteScreen.classList.add('active');
            }, 1000);
        }
    }

    // Create explosion effect
    function createExplosion(x, y) {
        const explosion = document.createElement('div');
        explosion.classList.add('explosion');
        explosion.style.width = '20px';
        explosion.style.height = '20px';
        explosion.style.left = x + 'px';
        explosion.style.top = y + 'px';
        elements.gameBoard.appendChild(explosion);

        // Remove explosion after animation completes
        setTimeout(() => {
            explosion.remove();
        }, 500);
    }

    // Explode adjacent bricks
    function explodeAdjacentBricks(brickIndex) {
        const targetBrick = state.bricks[brickIndex];
        const explosionRadius = 60;

        // Get bricks within explosion radius
        const affectedBricks = [];

        for (let i = 0; i < state.bricks.length; i++) {
            if (i === brickIndex) continue;

            const brick = state.bricks[i];

            // Calculate centers
            const brickCenterX = brick.x + brick.width / 2;
            const brickCenterY = brick.y + brick.height / 2;
            const explosionCenterX = targetBrick.x + targetBrick.width / 2;
            const explosionCenterY = targetBrick.y + targetBrick.height / 2;

            // Calculate distance
            const distance = Math.sqrt(
                Math.pow(brickCenterX - explosionCenterX, 2) +
                Math.pow(brickCenterY - explosionCenterY, 2)
            );

            if (distance < explosionRadius) {
                affectedBricks.push(i);
            }
        }

        // Destroy affected bricks (in reverse to not affect indexes)
        for (let i = affectedBricks.length - 1; i >= 0; i--) {
            const index = affectedBricks[i];
            if (state.bricks[index].type !== 'indestructible') {
                destroyBrick(index);
            }
        }
    }

    // Create particle effects
    function createParticles(x, y, color) {
        for (let i = 0; i < config.particleCount; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');

            // Random size between 3-6px
            const size = Math.random() * 3 + 3;
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';

            // Set position
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';

            // Set color (with some variation)
            particle.style.backgroundColor = color;

            // Add to document
            elements.gameBoard.appendChild(particle);

            // Add to state with velocity
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            state.particles.push({
                element: particle,
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                alpha: 1,
                size: size
            });
        }
    }

    // Update particles
    function updateParticles() {
        const particlesToRemove = [];

        for (let i = 0; i < state.particles.length; i++) {
            const particle = state.particles[i];

            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Add gravity
            particle.vy += 0.1;

            // Fade out
            particle.alpha -= 0.02;

            // Update DOM element
            particle.element.style.left = particle.x + 'px';
            particle.element.style.top = particle.y + 'px';
            particle.element.style.opacity = particle.alpha;

            // Mark for removal if faded out
            if (particle.alpha <= 0) {
                particlesToRemove.push(i);
                particle.element.remove();
            }
        }

        // Remove expired particles (in reverse order to not affect indexes)
        for (let i = particlesToRemove.length - 1; i >= 0; i--) {
            state.particles.splice(particlesToRemove[i], 1);
        }
    }

    // Clear all particles
    function clearParticles() {
        for (const particle of state.particles) {
            particle.element.remove();
        }
        state.particles = [];

        for (const trail of state.trails) {
            trail.element.remove();
        }
        state.trails = [];
    }

    // Drop a powerup
    function dropPowerup(x, y) {
        // Get random powerup type
        const powerupTypes = ['paddleSize', 'extraLife', 'fireball', 'multiball', 'speedUp', 'stickyPaddle'];
        const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

        // Create powerup element
        const powerup = document.createElement('div');
        powerup.classList.add('powerup');
        powerup.textContent = getPowerupSymbol(type);
        powerup.style.backgroundColor = getPowerupColor(type);
        powerup.style.left = x + 'px';
        powerup.style.top = y + 'px';

        elements.gameBoard.appendChild(powerup);

        // Add to game state
        state.powerups.push({
            element: powerup,
            x: x,
            y: y,
            type: type,
            width: 30,
            height: 30
        });
    }

    // Get powerup symbol
    function getPowerupSymbol(type) {
        const symbols = {
            paddleSize: 'üìè',
            extraLife: '‚ù§Ô∏è',
            fireball: 'üî•',
            multiball: 'üîÆ',
            speedUp: '‚ö°',
            stickyPaddle: 'üß≤'
        };

        return symbols[type] || '?';
    }

    // Get powerup color
    function getPowerupColor(type) {
        const colors = {
            paddleSize: '#4CC9F0',
            extraLife: '#F72585',
            fireball: '#FF9E00',
            multiball: '#7209B7',
            speedUp: '#4361EE',
            stickyPaddle: '#80ED99'
        };

        return colors[type] || '#ffffff';
    }

    // Update powerups
    function updatePowerups() {
        const powerupsToRemove = [];

        for (let i = 0; i < state.powerups.length; i++) {
            const powerup = state.powerups[i];

            // Move powerup down
            powerup.y += config.powerupSpeed;
            powerup.element.style.top = powerup.y + 'px';

            // Check for collision with paddle
            if (powerup.y + powerup.height / 2 > config.boardHeight - config.paddleHeight - 20 &&
                powerup.y - powerup.height / 2 < config.boardHeight - 20 &&
                powerup.x + powerup.width / 2 > paddle.x - paddle.width / 2 &&
                powerup.x - powerup.width / 2 < paddle.x + paddle.width / 2) {
                // Collect powerup
                collectPowerup(powerup.type);
                powerupsToRemove.push(i);
                powerup.element.remove();
            }

            // Check if powerup is out of bounds
            if (powerup.y - powerup.height / 2 > config.boardHeight) {
                powerupsToRemove.push(i);
                powerup.element.remove();
            }
        }

        // Remove collected or out of bounds powerups
        for (let i = powerupsToRemove.length - 1; i >= 0; i--) {
            state.powerups.splice(powerupsToRemove[i], 1);
        }
    }

    // Clear all powerups
    function clearPowerups() {
        for (const powerup of state.powerups) {
            powerup.element.remove();
        }
        state.powerups = [];
    }

    // Collect a powerup
    function collectPowerup(type) {
        // Show powerup collected message
        showFloatingText(getPowerupSymbol(type), paddle.x, config.boardHeight - config.paddleHeight - 20);

        // Apply the powerup effect
        switch (type) {
            case 'paddleSize':
                applyPaddleSizePowerup();
                break;
            case 'extraLife':
                applyExtraLifePowerup();
                break;
            case 'fireball':
                applyFireballPowerup();
                break;
            case 'multiball':
                applyMultiballPowerup();
                break;
            case 'speedUp':
                applySpeedUpPowerup();
                break;
            case 'stickyPaddle':
                applyStickyPaddlePowerup();
                break;
        }

        // Add effect to active effects
        addEffect(type);
    }

    // Apply paddle size powerup
    function applyPaddleSizePowerup() {
        paddle.width = Math.min(paddle.width * 1.5, 200);
        elements.paddle.style.width = paddle.width + 'px';
        elements.paddleGlow.style.width = paddle.width + 'px';
    }

    // Apply extra life powerup
    function applyExtraLifePowerup() {
        state.lives++;
        updateLivesDisplay();
    }

    // Apply fireball powerup
    function applyFireballPowerup() {
        ball.fireball = true;
        elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, #FF9E00)';
        elements.ball.style.boxShadow = '0 0 15px rgba(255, 158, 0, 0.7)';
    }

    // Apply multiball powerup (not fully implemented)
    function applyMultiballPowerup() {
        // Would create additional balls
        // For simplicity, just add points for now
        state.score += 100;
        updateScoreDisplay();
    }

    // Apply speed up powerup
    function applySpeedUpPowerup() {
        ball.speed = Math.min(ball.speed * 1.2, config.maxBallSpeed);
        // Maintain the direction but increase speed
        if (ball.dx !== 0 || ball.dy !== 0) {
            const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            ball.dx = (ball.dx / magnitude) * ball.speed;
            ball.dy = (ball.dy / magnitude) * ball.speed;
        }
    }

    // Apply sticky paddle powerup
    function applyStickyPaddlePowerup() {
        paddle.sticky = true;
        elements.paddle.style.background = 'linear-gradient(to right, #80ED99, #57CC99)';
    }

    // Add an active effect
    function addEffect(type) {
        // Check if effect already exists
        const existingEffect = state.effects.find(effect => effect.type === type);

        if (existingEffect) {
            // Reset timer for existing effect
            existingEffect.time = Date.now();
        } else {
            // Add new effect
            state.effects.push({
                type: type,
                time: Date.now()
            });

            // Update effect indicator
            updateEffectIndicator();
        }
    }

    // Update active effects
    function updateEffects() {
        const currentTime = Date.now();
        const effectsToRemove = [];

        for (let i = 0; i < state.effects.length; i++) {
            const effect = state.effects[i];
            const effectElement = document.querySelector(`.effect[data-type="${effect.type}"]`);

            if (effectElement) {
                // Update timer bar
                const elapsed = currentTime - effect.time;
                const remaining = 1 - (elapsed / config.effectDuration);
                effectElement.querySelector('.timer').style.transform = `scaleX(${Math.max(0, remaining)})`;
            }

            // Check if effect has expired
            if (currentTime - effect.time > config.effectDuration) {
                effectsToRemove.push(i);

                // Remove effect
                if (effectElement) {
                    effectElement.remove();
                }

                // Revert effect
                revertEffect(effect.type);
            }
        }

        // Remove expired effects
        for (let i = effectsToRemove.length - 1; i >= 0; i--) {
            state.effects.splice(effectsToRemove[i], 1);
        }
    }

    // Revert an effect when it expires
    function revertEffect(type) {
        switch (type) {
            case 'paddleSize':
                paddle.width = config.paddleWidth;
                elements.paddle.style.width = paddle.width + 'px';
                elements.paddleGlow.style.width = paddle.width + 'px';
                break;
            case 'fireball':
                ball.fireball = false;
                elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, var(--secondary-color))';
                elements.ball.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';
                break;
            case 'speedUp':
                ball.speed = config.initialBallSpeed * levelData[state.level - 1].ballSpeed;
                // Maintain direction but reduce speed
                if (ball.dx !== 0 || ball.dy !== 0) {
                    const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    ball.dx = (ball.dx / magnitude) * ball.speed;
                    ball.dy = (ball.dy / magnitude) * ball.speed;
                }
                break;
            case 'stickyPaddle':
                paddle.sticky = false;
                elements.paddle.style.background = 'var(--paddle-color)';
                break;
        }
    }

    // Update effect indicator
    function updateEffectIndicator() {
        // Clear indicator
        elements.effectIndicator.innerHTML = '';

        // Add effect icons
        for (const effect of state.effects) {
            const effectElement = document.createElement('div');
            effectElement.classList.add('effect');
            effectElement.dataset.type = effect.type;
            effectElement.textContent = getPowerupSymbol(effect.type);
            effectElement.style.borderColor = getPowerupColor(effect.type);

            // Add timer bar
            const timer = document.createElement('div');
            timer.classList.add('timer');
            timer.style.background = getPowerupColor(effect.type);
            effectElement.appendChild(timer);

            elements.effectIndicator.appendChild(effectElement);
        }
    }

    // Check if an effect is active
    function hasEffect(type) {
        return state.effects.some(effect => effect.type === type);
    }

    // Show floating text
    function showFloatingText(text, x, y) {
        const floatingText = document.createElement('div');
        floatingText.style.position = 'absolute';
        floatingText.style.left = x + 'px';
        floatingText.style.top = y + 'px';
        floatingText.style.color = 'white';
        floatingText.style.fontSize = '18px';
        floatingText.style.fontWeight = 'bold';
        floatingText.style.pointerEvents = 'none';
        floatingText.style.textShadow = '0 0 5px rgba(0,0,0,0.5)';
        floatingText.style.zIndex = '30';
        floatingText.style.transform = 'translate(-50%, -50%)';
        floatingText.textContent = text;
        elements.gameBoard.appendChild(floatingText);

        // Animate
        floatingText.animate([
            { opacity: 1, transform: 'translate(-50%, -50%)' },
            { opacity: 0, transform: 'translate(-50%, -150%)' }
        ], {
            duration: 1000,
            easing: 'ease-out'
        }).onfinish = () => {
            floatingText.remove();
        };
    }

    // Reset the ball
    function resetBall() {
        // Fix: Set proper initial position for ball
        ball.x = paddle.x;
        ball.y = config.boardHeight - config.paddleHeight - config.ballSize / 2 - 25; // Additional offset to position above paddle
        ball.dx = 0;
        ball.dy = 0;
        ball.launched = false;
        ball.speed = config.initialBallSpeed * (state.level > 0 ? levelData[state.level - 1].ballSpeed : 1);
        ball.fireball = false;

        elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, var(--secondary-color))';
        elements.ball.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';

        updateBallPosition();
    }

    // Lose a life
    function loseLife() {
        state.lives--;
        updateLivesDisplay();

        // Reset combo
        state.combo = 1;
        updateComboDisplay();

        // Clear all powerups on screen
        clearPowerups();

        // Clear all active effects
        for (const effect of state.effects) {
            revertEffect(effect.type);
        }
        state.effects = [];
        elements.effectIndicator.innerHTML = '';

        if (state.lives <= 0) {
            gameOver();
        } else {
            resetBall();
        }
    }

    // Update combo
    function updateCombo() {
        const now = Date.now();

        // Increase combo if multiple bricks hit in quick succession
        if (now - state.lastBrickHit < config.comboTimeout) {
            state.combo++;
        } else {
            state.combo = 1;
        }

        state.lastBrickHit = now;
        updateComboDisplay();
    }

    // Check combo timeout
    function checkComboTimeout() {
        const now = Date.now();
        if (state.combo > 1 && now - state.lastBrickHit > config.comboTimeout) {
            state.combo = 1;
            updateComboDisplay();
        }
    }

    // Game over
    function gameOver() {
        state.running = false;
        elements.finalScore.textContent = state.score;
        elements.gameOverScreen.classList.add('active');
    }

    // Clear all bricks
    function clearBricks() {
        // Remove brick elements
        const brickElements = document.querySelectorAll('.brick');
        brickElements.forEach(brick => brick.remove());

        // Clear bricks array
        state.bricks = [];
    }

    // Build a level
    function buildLevel(level) {
        // Make sure level is valid
        if (level < 1 || level > levelData.length) {
            console.error(`Invalid level: ${level}`);
            return;
        }

        const levelConfig = levelData[level - 1];
        const brickRowCount = levelConfig.rows;
        const brickColumnCount = levelConfig.cols;

        // Calculate brick dimensions based on board size and brick count
        const brickWidth = (config.boardWidth - (config.brickOffsetLeft * 2) - (config.brickPadding * (brickColumnCount - 1))) / brickColumnCount;
        const brickHeight = config.brickHeight;

        // Create all bricks for this level
        for (let r = 0; r < brickRowCount; r++) {
            for (let c = 0; c < brickColumnCount; c++) {
                // Determine brick type from level data
                // Handle potential index errors in brick definition
                let brickType = 'normal';
                if (levelConfig.bricks[r] && levelConfig.bricks[r][c]) {
                    brickType = levelConfig.bricks[r][c];
                }

                const brickTypeInfo = brickTypes[brickType];

                if (!brickTypeInfo) continue; // Skip if invalid type

                // Calculate position
                const brickX = (c * (brickWidth + config.brickPadding)) + config.brickOffsetLeft;
                const brickY = (r * (brickHeight + config.brickPadding)) + config.brickOffsetTop;

                // Create the brick element
                const brick = document.createElement('div');
                brick.classList.add('brick');
                brick.style.left = brickX + 'px';
                brick.style.top = brickY + 'px';
                brick.style.width = brickWidth + 'px';
                brick.style.height = brickHeight + 'px';
                brick.style.background = brickTypeInfo.color;

                // Add to game board
                elements.gameBoard.appendChild(brick);

                // Add to bricks array
                state.bricks.push({
                    element: brick,
                    x: brickX,
                    y: brickY,
                    width: brickWidth,
                    height: brickHeight,
                    type: brickType,
                    originalType: brickType,
                    hits: brickTypeInfo.hits,
                    color: brickTypeInfo.color
                });
            }
        }

        // Set ball speed for this level
        ball.speed = config.initialBallSpeed * levelConfig.ballSpeed;
    }

    // Update score display
    function updateScoreDisplay() {
        elements.scoreDisplay.textContent = `Score: ${state.score}`;
    }

    // Update lives display
    function updateLivesDisplay() {
        elements.livesDisplay.textContent = `Lives: ${state.lives}`;
    }

    // Update combo display
    function updateComboDisplay() {
        elements.comboDisplay.textContent = `Combo: x${state.combo}`;
    }

    // Update level display
    function updateLevelDisplay() {
        elements.levelDisplay.textContent = state.level;
    }

    // Initialize the game
    window.addEventListener('load', init);
</script>
<script src="../sidebar.js" data-position="bottom-right"></script>
</body>
</html>