<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Remastered</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🧱</text></svg>">
    <style>
        :root {
            --primary-color: #2a2a72;
            --secondary-color: #009ffd;
            --accent-color: #ff7e5f;
            --background-color: #121212;
            --text-color: #ffffff;
            --paddle-color: linear-gradient(to right, #ff9966, #ff5e62);
            --ball-glow: 0 0 10px rgba(255, 255, 255, 0.7);
            --game-width: 600px;
            --game-height: 500px;
            --ui-blue: #0099ff;
            --ui-purple: #191b3a;
            --ui-pink: #ff6b97;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .game-container {
            position: relative;
            width: var(--game-width);
            margin: 20px auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 2px solid var(--secondary-color);
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .title-blue {
            color: var(--ui-blue);
        }

        .title-purple {
            color: #666;
        }

        .title-pink {
            color: var(--ui-pink);
        }

        .game-subtitle {
            color: #aaa;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            width: 100%;
            padding: 0 10px;
        }

        .stat {
            background: var(--ui-purple);
            padding: 10px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-icon {
            margin-right: 8px;
            font-size: 1.2rem;
        }

        #game-board {
            width: var(--game-width);
            height: var(--game-height);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                    linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
        }

        .ball {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, white, var(--secondary-color));
            position: absolute;
            filter: drop-shadow(var(--ball-glow));
            z-index: 10;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .ball-trail {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            filter: blur(3px);
            z-index: 5;
            opacity: 0;
            transform: translate(-50%, -50%);
            animation: fadeOut 0.5s ease-out forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 0.5; }
            100% { opacity: 0; }
        }

        .paddle {
            height: 20px;
            background: var(--paddle-color);
            position: absolute;
            bottom: 20px;
            border-radius: 10px;
            z-index: 10;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 94, 98, 0.7);
            transform: translateX(-50%);
        }

        .paddle-glow {
            position: absolute;
            bottom: 20px;
            height: 20px;
            border-radius: 10px;
            background: transparent;
            box-shadow: 0 0 20px 5px rgba(255, 94, 98, 0.5);
            filter: blur(3px);
            opacity: 0.7;
            z-index: 9;
            transform: translateX(-50%);
        }

        .brick {
            position: absolute;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-align: center;
            line-height: 25px;
            font-weight: bold;
            font-size: 12px;
            transition: opacity 0.1s;
            background-size: cover;
            transform: translateZ(0);
        }

        .powerup {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            z-index: 8;
            animation: pulse 1.5s infinite ease-in-out;
            text-align: center;
            line-height: 30px;
            font-size: 18px;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            z-index: 7;
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .explosion {
            position: absolute;
            border-radius: 50%;
            z-index: 15;
            background: radial-gradient(circle, #fff, #ff7e5f);
            opacity: 0.9;
            animation: explode 0.5s forwards;
            transform: translate(-50%, -50%);
        }

        @keyframes explode {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        .level-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 20;
            box-shadow: 0 0 10px rgba(0, 159, 253, 0.5);
            border: 1px solid var(--secondary-color);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(18, 18, 18, 0.9);
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .screen h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(to right, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .screen p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(to right, var(--secondary-color), var(--accent-color));
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .controls-info {
            display: flex;
            background: rgba(25, 27, 58, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin: 20px auto;
            width: 80%;
            max-width: 500px;
            gap: 20px;
        }

        .controls-column {
            flex: 1;
            padding: 10px;
            text-align: left;
        }

        .controls-column h3 {
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
        }

        .controls-column p {
            font-size: 0.95rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .level-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 40;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .level-transition.active {
            opacity: 1;
            pointer-events: all;
        }

        .level-message {
            font-size: 3rem;
            color: white;
            text-align: center;
            animation: scaleIn 0.5s ease-out;
        }

        @keyframes scaleIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .effect-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 20;
        }

        .effect {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid;
            opacity: 0.7;
            position: relative;
        }

        .effect .timer {
            position: absolute;
            bottom: -5px;
            left: 0;
            height: 3px;
            width: 100%;
            background: white;
            border-radius: 3px;
            transform-origin: left;
        }

        .mobile-controls {
            display: none;
            width: 100%;
            padding: 20px 0;
            justify-content: space-between;
        }

        .touch-area {
            width: 48%;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .game-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        @media (max-width: 768px) {
            :root {
                --game-width: 100%;
                --game-height: 400px;
            }

            .game-container {
                width: 95%;
                padding: 0 10px;
            }

            .game-title {
                font-size: 2rem;
            }

            .mobile-controls {
                display: flex;
            }

            .controls-info {
                flex-direction: column;
            }
        }


        @media (min-width: 769px) {
            .game-container {
                width: var(--game-width);
                margin: 20px auto;
                max-height: 90vh;
            }

            #game-board {
                height: min(var(--game-height), 70vh);
            }
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-header">
        <div>
            <h1 class="game-title">
                <span class="title-blue">BREAKOUT</span>
                <span class="title-purple">REMASTERED</span>
            </h1>
            <p class="game-subtitle">GPTGames Edition</p>
        </div>
    </div>

    <div class="game-stats">
        <div class="stat">
            <span class="stat-icon">🏆</span>
            <span id="score">Score: 0</span>
        </div>
        <div class="stat">
            <span class="stat-icon">❤️</span>
            <span id="lives">Lives: 3</span>
        </div>
        <div class="stat">
            <span class="stat-icon">🔥</span>
            <span id="combo">Combo: x1</span>
        </div>
    </div>

    <div id="game-board">
        <div class="level-indicator">Level <span id="level-num">1</span></div>
        <div class="grid-overlay"></div>
        <div class="game-backdrop"></div>
        <div class="ball"></div>
        <div class="paddle-glow"></div>
        <div class="paddle"></div>
        <div class="effect-indicator"></div>

        <div id="start-screen" class="screen active">
            <h2>Breakout Remastered</h2>
            <p>The classic brick-breaker game, redesigned with modern visuals and exciting new features!</p>
            <button id="start-btn" class="btn">Start Game</button>
            <div class="controls-info">
                <div class="controls-column">
                    <h3>Controls:</h3>
                    <p>Mouse or Arrow Keys to move paddle</p>
                    <p>Click or Space to launch ball</p>
                    <p>P to pause the game</p>
                </div>
                <div class="controls-column">
                    <h3>Power-Ups:</h3>
                    <p>📏 Paddle Size</p>
                    <p>🔥 Fireball</p>
                    <p>⚡ Speed</p>
                    <p>❤️ Extra Life</p>
                    <p>🔮 Multiball</p>
                    <p>🧲 Sticky Paddle</p>
                </div>
            </div>
        </div>

        <div id="level-complete-screen" class="screen">
            <h2>Level Complete!</h2>
            <p>You've cleared all the bricks! Ready for the next challenge?</p>
            <button id="next-level-btn" class="btn">Next Level</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h2>Game Over</h2>
            <p>Your final score: <span id="final-score">0</span></p>
            <button id="restart-btn" class="btn">Play Again</button>
        </div>

        <div id="pause-screen" class="screen">
            <h2>Game Paused</h2>
            <button id="resume-btn" class="btn">Resume Game</button>
            <button id="restart-from-pause-btn" class="btn">Restart Game</button>
        </div>

        <div id="game-complete-screen" class="screen">
            <h2>You Win!</h2>
            <p>Congratulations! You've completed all 10 levels of Breakout Remastered!</p>
            <p>Final Score: <span id="final-complete-score">0</span></p>
            <button id="play-again-btn" class="btn">Play Again</button>
        </div>

        <div class="level-transition">
            <div class="level-message">Level <span id="transition-level">1</span></div>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="touch-area" id="touch-left">◀</div>
        <div class="touch-area" id="touch-right">▶</div>
    </div>
</div>

<script>
    const config = {
        paddleWidth: 100,
        paddleHeight: 20,
        ballSize: 16,
        initialBallSpeed: 4,
        maxBallSpeed: 12,
        boardWidth: 0,
        boardHeight: 0,
        brickRowCount: 5,
        brickColumnCount: 10,
        brickWidth: 50,
        brickHeight: 25,
        brickPadding: 5,
        brickOffsetTop: 50,
        brickOffsetLeft: 30,
        maxLevels: 10,
        comboTimeout: 5000,
        powerupChance: 0.2,
        powerupSpeed: 2,
        particleCount: 15,
        effectDuration: 10000,
        touchSensitivity: 10,
        shakeIntensity: 5,
        shakeDuration: 300,
        multiBallCount: 2,
    };

    const state = {
        score: 0,
        lives: 3,
        level: 1,
        running: false,
        combo: 1,
        lastBrickHit: 0,
        paused: false,
        bricks: [],
        powerups: [],
        particles: [],
        effects: [],
        trails: [],
        balls: [],
        keyStates: {
            left: false,
            right: false,
            space: false
        },
        touchActive: {
            left: false,
            right: false
        },
        transitionActive: false,
        launchReady: true
    };

    const elements = {
        gameBoard: document.getElementById('game-board'),
        ball: document.querySelector('.ball'),
        paddle: document.querySelector('.paddle'),
        paddleGlow: document.querySelector('.paddle-glow'),
        scoreDisplay: document.getElementById('score'),
        livesDisplay: document.getElementById('lives'),
        comboDisplay: document.getElementById('combo'),
        levelDisplay: document.getElementById('level-num'),
        transitionLevel: document.getElementById('transition-level'),
        levelTransition: document.querySelector('.level-transition'),
        effectIndicator: document.querySelector('.effect-indicator'),
        startScreen: document.getElementById('start-screen'),
        levelCompleteScreen: document.getElementById('level-complete-screen'),
        gameOverScreen: document.getElementById('game-over-screen'),
        pauseScreen: document.getElementById('pause-screen'),
        gameCompleteScreen: document.getElementById('game-complete-screen'),
        finalScore: document.getElementById('final-score'),
        finalCompleteScore: document.getElementById('final-complete-score'),
        startBtn: document.getElementById('start-btn'),
        nextLevelBtn: document.getElementById('next-level-btn'),
        restartBtn: document.getElementById('restart-btn'),
        resumeBtn: document.getElementById('resume-btn'),
        restartFromPauseBtn: document.getElementById('restart-from-pause-btn'),
        playAgainBtn: document.getElementById('play-again-btn'),
        touchLeft: document.getElementById('touch-left'),
        touchRight: document.getElementById('touch-right'),
        gameBackdrop: document.querySelector('.game-backdrop')
    };

    const ball = {
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        speed: config.initialBallSpeed,
        launched: false,
        radius: config.ballSize / 2,
        fireball: false
    };

    const paddle = {
        width: config.paddleWidth,
        height: config.paddleHeight,
        x: 0,
        speed: 8,
        sticky: false
    };

    const brickTypes = {
        normal: { color: '#4CC9F0', hits: 1, points: 10 },
        strong: { color: '#4361EE', hits: 2, points: 20 },
        ultra: { color: '#3A0CA3', hits: 3, points: 30 },
        explosive: { color: '#F72585', hits: 1, points: 15, explodes: true },
        indestructible: { color: '#333333', hits: Infinity, points: 0 },
        rainbow: {
            color: 'linear-gradient(to right, #ff0000, #ff9900, #33cc33, #3399ff, #cc33ff)',
            hits: 1,
            points: 25,
            special: 'rainbow'
        }
    };

    const powerupTypes = {
        paddleSize: { color: '#4CC9F0', symbol: '📏', effect: 'increasePaddle' },
        extraLife: { color: '#F72585', symbol: '❤️', effect: 'extraLife' },
        fireball: { color: '#FF9E00', symbol: '🔥', effect: 'fireball' },
        multiball: { color: '#7209B7', symbol: '🔮', effect: 'multiball' },
        speedUp: { color: '#4361EE', symbol: '⚡', effect: 'speedUp' },
        stickyPaddle: { color: '#80ED99', symbol: '🧲', effect: 'stickyPaddle' }
    };

    const levelData = [
        {
            rows: 4,
            cols: 8,
            bricks: [
                Array(8).fill('normal'),
                Array(8).fill('normal'),
                Array(8).fill('normal'),
                Array(8).fill('normal')
            ],
            ballSpeed: 1.0
        },
        {
            rows: 5,
            cols: 9,
            bricks: [
                Array(9).fill('normal'),
                Array(9).fill('normal'),
                '111STRONG111'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                Array(9).fill('normal'),
                Array(9).fill('normal')
            ],
            ballSpeed: 1.1
        },
        {
            rows: 5,
            cols: 10,
            bricks: [
                'NNSSNNSSNN'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NSNNNNNNNS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'NSNNNNNNNS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'NNSSNNSSNN'.split('').map(b => b === 'S' ? 'strong' : 'normal')
            ],
            ballSpeed: 1.2
        },
        {
            rows: 6,
            cols: 10,
            bricks: [
                Array(10).fill('strong'),
                'NNENENENEN'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                Array(10).fill('normal'),
                Array(10).fill('normal'),
                'ENENENENNN'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                Array(10).fill('strong')
            ],
            ballSpeed: 1.25
        },
        {
            rows: 6,
            cols: 10,
            bricks: [
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NUNNNNNNUN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'IINNNNNNII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal'))
            ],
            ballSpeed: 1.3
        },
        {
            rows: 7,
            cols: 10,
            bricks: [
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNEENNEEII'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNSSSSSSNN'.split('').map(b => b === 'S' ? 'strong' : (b === 'I' ? 'indestructible' : 'normal')),
                'UUUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNSSSSSSNN'.split('').map(b => b === 'S' ? 'strong' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNEENNEEII'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'NNNNRRNNNN'.split('').map(b => b === 'R' ? 'rainbow' : (b === 'I' ? 'indestructible' : 'normal'))
            ],
            ballSpeed: 1.35
        },
        {
            rows: 7,
            cols: 10,
            bricks: [
                Array(10).fill('normal'),
                'NNIINNIINN'.split('').map(b => b === 'I' ? 'indestructible' : 'normal'),
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'IINNSSNNII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'NNUUUUUUNN'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'NNIINNIINN'.split('').map(b => b === 'I' ? 'indestructible' : 'normal'),
                Array(10).fill('normal')
            ],
            ballSpeed: 1.4
        },
        {
            rows: 8,
            cols: 10,
            bricks: [
                'RRRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'SSSSSSSSSS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'EEEEEEEEEE'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                'IISSIISSII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IISSIISSII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'EEEEEEEEEE'.split('').map(b => b === 'E' ? 'explosive' : 'normal'),
                'SSSSSSSSSS'.split('').map(b => b === 'S' ? 'strong' : 'normal'),
                'RRRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal')
            ],
            ballSpeed: 1.45
        },
        {
            rows: 8,
            cols: 10,
            bricks: [
                'IUIUIUIUIU'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'UIUIUIUIUI'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'REREREREIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'R' ? 'rainbow' : 'normal'))),
                'SESESEIESE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal'))),
                'SESESEIESE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal'))),
                'REREREREIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : (b === 'R' ? 'rainbow' : 'normal'))),
                'UIUIUIUIUI'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal')),
                'IUIUIUIUIU'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'U' ? 'ultra' : 'normal'))
            ],
            ballSpeed: 1.5
        },
        {
            rows: 10,
            cols: 10,
            bricks: [
                'RRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal'),
                'UUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'EIEIEIEIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'IIISSSIII'.split('').map(b => b === 'I' ? 'indestructible' : (b === 'S' ? 'strong' : 'normal')),
                'EIEIEIEIE'.split('').map(b => b === 'E' ? 'explosive' : (b === 'I' ? 'indestructible' : 'normal')),
                'UUUUUUUUU'.split('').map(b => b === 'U' ? 'ultra' : 'normal'),
                'RRRRRRRRR'.split('').map(b => b === 'R' ? 'rainbow' : 'normal')
            ],
            ballSpeed: 1.6
        }
    ];

    function init() {
        config.boardWidth = elements.gameBoard.offsetWidth;
        config.boardHeight = elements.gameBoard.offsetHeight;

        if (window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            config.initialBallSpeed *= 0.7;
            config.maxBallSpeed *= 0.7;
            paddle.speed *= 0.7;
            config.powerupSpeed *= 0.7;
        }

        paddle.x = config.boardWidth / 2;
        elements.paddle.style.width = paddle.width + 'px';
        elements.paddle.style.height = paddle.height + 'px';
        elements.paddle.style.left = paddle.x + 'px';

        elements.paddleGlow.style.width = paddle.width + 'px';
        elements.paddleGlow.style.left = paddle.x + 'px';

        resetBall();

        state.score = 0;
        state.lives = 3;
        state.level = 1;
        state.combo = 0;
        state.powerups = [];
        state.particles = [];
        state.effects = [];
        state.trails = [];
        state.balls = [];
        state.transitionActive = false;
        state.launchReady = true;

        updateScoreDisplay();
        updateLivesDisplay();
        updateComboDisplay();
        updateLevelDisplay();

        clearBricks();
        clearPowerups();
        clearParticles();

        buildLevel(state.level);
        setupEventListeners();
    }

    function setupEventListeners() {
        elements.gameBoard.addEventListener('mousemove', (e) => {
            if (state.running && !state.paused) {
                const relativeX = e.clientX - elements.gameBoard.getBoundingClientRect().left;
                if (relativeX > 0 && relativeX < config.boardWidth) {
                    paddle.x = relativeX;
                    updatePaddlePosition();
                }
            }
        });

        elements.gameBoard.addEventListener('click', () => {
            if (state.running && !state.paused && !state.transitionActive && state.launchReady &&
                (!ball.launched || (state.balls.length > 0 && state.balls.some(b => !b.launched)))) {
                launchBall();
            }
        });

        elements.gameBoard.addEventListener('touchmove', (e) => {
            if (state.running && !state.paused) {
                e.preventDefault(); // Prevent scrolling
                const touch = e.touches[0];
                const gameBoardRect = elements.gameBoard.getBoundingClientRect();
                const relativeX = touch.clientX - gameBoardRect.left;

                if (relativeX > 0 && relativeX < config.boardWidth) {
                    paddle.x = relativeX;
                    updatePaddlePosition();
                }
            }
        });

        elements.gameBoard.addEventListener('touchend', (e) => {
            if (state.running && !state.paused && !state.transitionActive && state.launchReady &&
                (!ball.launched || (state.balls.length > 0 && state.balls.some(b => !b.launched)))) {
                launchBall();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                state.keyStates.left = true;
            } else if (e.key === 'ArrowRight') {
                state.keyStates.right = true;
            } else if (e.key === ' ') {
                state.keyStates.space = true;
                if (state.running && !state.paused && !state.transitionActive && state.launchReady &&
                    (!ball.launched || (state.balls.length > 0 && state.balls.some(b => !b.launched)))) {
                    launchBall();
                }
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                state.keyStates.left = false;
            } else if (e.key === 'ArrowRight') {
                state.keyStates.right = false;
            } else if (e.key === ' ') {
                state.keyStates.space = false;
            }
        });

        elements.touchLeft.addEventListener('touchstart', () => {
            state.touchActive.left = true;
        });

        elements.touchRight.addEventListener('touchstart', () => {
            state.touchActive.right = true;
        });

        elements.touchLeft.addEventListener('touchend', () => {
            state.touchActive.left = false;
        });

        elements.touchRight.addEventListener('touchend', () => {
            state.touchActive.right = false;
        });

        elements.startBtn.addEventListener('click', startGame);
        elements.nextLevelBtn.addEventListener('click', nextLevel);
        elements.restartBtn.addEventListener('click', restartGame);
        elements.resumeBtn.addEventListener('click', resumeGame);
        elements.restartFromPauseBtn.addEventListener('click', restartGame);
        elements.playAgainBtn.addEventListener('click', restartGame);
    }

    function startGame() {
        hideAllScreens();
        state.running = true;
        state.paused = false;
        resetBall();
        showLevelTransition();
        gameLoop();
    }

    function restartGame() {
        hideAllScreens();
        init();
        startGame();
    }

    function resumeGame() {
        state.paused = false;
        hideAllScreens();
        gameLoop();
    }

    function togglePause() {
        if (!state.running) return;

        state.paused = !state.paused;

        if (state.paused) {
            elements.pauseScreen.classList.add('active');
        } else {
            elements.pauseScreen.classList.remove('active');
            requestAnimationFrame(gameLoop);
        }
    }

    function hideAllScreens() {
        elements.startScreen.classList.remove('active');
        elements.levelCompleteScreen.classList.remove('active');
        elements.gameOverScreen.classList.remove('active');
        elements.pauseScreen.classList.remove('active');
        elements.gameCompleteScreen.classList.remove('active');
    }

    function showLevelTransition() {
        elements.transitionLevel.textContent = state.level;
        elements.levelTransition.classList.add('active');
        state.transitionActive = true;

        setTimeout(() => {
            elements.levelTransition.classList.remove('active');
            state.transitionActive = false;
        }, 1500);
    }

    function nextLevel() {
        state.level++;

        if (state.level > config.maxLevels) {
            gameComplete();
            return;
        }

        // Prepare for next level
        state.launchReady = false;
        clearBricks();
        clearPowerups();
        clearParticles();
        clearAdditionalBalls();
        resetBall();
        updateLevelDisplay();
        buildLevel(state.level);
        hideAllScreens();

        // Set running to true BEFORE showing transition
        state.running = true;
        showLevelTransition();

        // Enable ball launch after transition
        setTimeout(() => {
            state.launchReady = true;
        }, 1500);

        // Ensure game loop is restarted
        requestAnimationFrame(gameLoop);
    }

    function clearAdditionalBalls() {
        state.balls.forEach(ballObj => {
            if (ballObj.element && ballObj.element.parentNode) {
                ballObj.element.parentNode.removeChild(ballObj.element);
            }
        });
        state.balls = [];
    }

    function gameComplete() {
        state.running = false;
        elements.finalCompleteScore.textContent = state.score;
        elements.gameCompleteScreen.classList.add('active');
    }

    function gameLoop() {
        if (!state.running || state.paused) return;

        handleInput();

        if (ball.launched) {
            moveBall(ball, elements.ball);
        } else {
            ball.x = paddle.x;
            updateBallPosition(ball, elements.ball);
        }

        state.balls.forEach(ballObj => {
            if (ballObj.launched) {
                moveBall(ballObj, ballObj.element);
            } else {
                ballObj.x = paddle.x;
                updateBallPosition(ballObj, ballObj.element);
            }
        });

        updatePowerups();
        updateParticles();
        updateTrails();
        updateEffects();
        checkComboTimeout();

        requestAnimationFrame(gameLoop);
    }

    function handleInput() {
        if (state.keyStates.left || state.touchActive.left) {
            paddle.x -= paddle.speed;
            if (paddle.x < paddle.width / 2) {
                paddle.x = paddle.width / 2;
            }
        }

        if (state.keyStates.right || state.touchActive.right) {
            paddle.x += paddle.speed;
            if (paddle.x > config.boardWidth - paddle.width / 2) {
                paddle.x = config.boardWidth - paddle.width / 2;
            }
        }

        updatePaddlePosition();
    }

    function launchBall() {
        if (!ball.launched && state.launchReady) {
            ball.launched = true;

            const angle = (Math.random() * 90 - 45) * Math.PI / 180;
            ball.dx = ball.speed * Math.sin(angle);
            ball.dy = -ball.speed * Math.cos(angle);
        }

        state.balls.forEach(ballObj => {
            if (!ballObj.launched && state.launchReady) {
                ballObj.launched = true;

                const angle = (Math.random() * 90 - 45) * Math.PI / 180;
                ballObj.dx = ballObj.speed * Math.sin(angle);
                ballObj.dy = -ballObj.speed * Math.cos(angle);
            }
        });
    }

    function updatePaddlePosition() {
        elements.paddle.style.left = paddle.x + 'px';
        elements.paddleGlow.style.left = paddle.x + 'px';
    }

    function updateBallPosition(ballObj, ballElement) {
        ballElement.style.left = ballObj.x + 'px';
        ballElement.style.top = ballObj.y + 'px';
    }

    function shakeScreen(intensity = 1) {
        if (!elements.gameBoard.style.transform) {
            const shakeAmount = config.shakeIntensity * intensity;
            const startTime = Date.now();

            function shake() {
                const elapsed = Date.now() - startTime;

                if (elapsed < config.shakeDuration) {
                    const xShake = (Math.random() - 0.5) * shakeAmount;
                    const yShake = (Math.random() - 0.5) * shakeAmount;
                    elements.gameBoard.style.transform = `translate(${xShake}px, ${yShake}px)`;
                    requestAnimationFrame(shake);
                } else {
                    elements.gameBoard.style.transform = 'translate(0px, 0px)';
                }
            }

            shake();
        }
    }

    function moveBall(ballObj, ballElement) {
        if (Math.random() > 0.7) {
            addTrail(ballObj);
        }

        ballObj.x += ballObj.dx;
        ballObj.y += ballObj.dy;

        if (ballObj.x - ballObj.radius < 0 || ballObj.x + ballObj.radius > config.boardWidth) {
            ballObj.dx = -ballObj.dx;

            if (ballObj.x - ballObj.radius < 0) {
                ballObj.x = ballObj.radius;
            } else {
                ballObj.x = config.boardWidth - ballObj.radius;
            }
        }

        if (ballObj.y - ballObj.radius < 0) {
            ballObj.dy = -ballObj.dy;
            ballObj.y = ballObj.radius;
        }

        const paddleTop = config.boardHeight - config.paddleHeight - 20;

        if (ballObj.y + ballObj.radius > paddleTop &&
            ballObj.y - ballObj.radius < paddleTop + 10 &&
            ballObj.x > paddle.x - paddle.width / 2 &&
            ballObj.x < paddle.x + paddle.width / 2) {

            const hitPosition = (ballObj.x - paddle.x) / (paddle.width / 2);
            const angle = hitPosition * Math.PI / 3;

            ballObj.dx = ballObj.speed * Math.sin(angle);
            ballObj.dy = -ballObj.speed * Math.cos(angle);

            ballObj.y = paddleTop - ballObj.radius;

            if (paddle.sticky && hasEffect('stickyPaddle')) {
                ballObj.launched = false;
            }
        }

        if (ballObj.y + ballObj.radius > config.boardHeight) {
            if (ballObj === ball) {
                loseLife();
            } else {
                removeBall(ballObj);
            }
            return;
        }

        checkBrickCollisions(ballObj);
        updateBallPosition(ballObj, ballElement);
    }

    function removeBall(ballObj) {
        const index = state.balls.indexOf(ballObj);
        if (index !== -1) {
            if (ballObj.element && ballObj.element.parentNode) {
                ballObj.element.parentNode.removeChild(ballObj.element);
            }
            state.balls.splice(index, 1);
        }
    }

    function addTrail(ballObj) {
        const trail = document.createElement('div');
        trail.classList.add('ball-trail');
        trail.style.width = config.ballSize + 'px';
        trail.style.height = config.ballSize + 'px';
        trail.style.left = ballObj.x + 'px';
        trail.style.top = ballObj.y + 'px';

        if (ballObj.fireball) {
            trail.style.backgroundColor = 'rgba(255, 89, 0, 0.5)';
        }

        elements.gameBoard.appendChild(trail);

        state.trails.push({
            element: trail,
            timeCreated: Date.now()
        });
    }

    function updateTrails() {
        const currentTime = Date.now();
        const trailsToRemove = [];

        state.trails.forEach((trail, index) => {
            if (currentTime - trail.timeCreated > 500) {
                trail.element.remove();
                trailsToRemove.push(index);
            }
        });

        for (let i = trailsToRemove.length - 1; i >= 0; i--) {
            state.trails.splice(trailsToRemove[i], 1);
        }
    }

    function checkBrickCollisions(ballObj) {
        let collision = false;

        for (let i = 0; i < state.bricks.length; i++) {
            const brick = state.bricks[i];

            if (brick.hits <= 0 || brick.type === 'indestructible' && brick.hit) continue;

            if (ballObj.x + ballObj.radius > brick.x &&
                ballObj.x - ballObj.radius < brick.x + brick.width &&
                ballObj.y + ballObj.radius > brick.y &&
                ballObj.y - ballObj.radius < brick.y + brick.height) {

                if (!ballObj.fireball || brick.type === 'indestructible') {
                    const ballBottom = ballObj.y + ballObj.radius;
                    const ballTop = ballObj.y - ballObj.radius;
                    const ballRight = ballObj.x + ballObj.radius;
                    const ballLeft = ballObj.x - ballObj.radius;

                    const brickBottom = brick.y + brick.height;
                    const brickTop = brick.y;
                    const brickRight = brick.x + brick.width;
                    const brickLeft = brick.x;

                    const bottomOverlap = ballBottom - brickTop;
                    const topOverlap = brickBottom - ballTop;
                    const rightOverlap = ballRight - brickLeft;
                    const leftOverlap = brickRight - ballLeft;

                    const overlaps = [bottomOverlap, topOverlap, leftOverlap, rightOverlap];
                    const minOverlap = Math.min(...overlaps);

                    if (minOverlap === bottomOverlap || minOverlap === topOverlap) {
                        ballObj.dy = -ballObj.dy;
                    } else {
                        ballObj.dx = -ballObj.dx;
                    }
                }

                if (brick.type !== 'indestructible' || !brick.hit) {
                    collision = true;
                    hitBrick(i);
                }

                if (!ballObj.fireball || brick.type === 'indestructible') {
                    return;
                }
            }
        }

        if (!collision && ballObj.dy < 0) {
            state.combo = 1;
            updateComboDisplay();
        }
    }

    function hitBrick(index) {
        const brick = state.bricks[index];

        if (brick.type === 'indestructible') {
            brick.hit = true;
            brick.element.style.opacity = '0.5';
            return;
        }

        brick.hits--;

        if (brick.hits > 0) {
            updateBrickAppearance(brick);
        } else {
            destroyBrick(index);
        }

        updateCombo();
    }

    function updateBrickAppearance(brick) {
        const originalType = Object.keys(brickTypes).find(type => {
            return brick.originalType === type;
        });

        if (originalType === 'strong') {
            brick.element.style.backgroundColor = '#7B5FFF';
        } else if (originalType === 'ultra') {
            brick.element.style.backgroundColor = brick.hits === 2 ? '#5E2BFF' : '#7209B7';
        }

        brick.element.style.transform = 'scale(0.95)';
        setTimeout(() => {
            if (brick.element) {
                brick.element.style.transform = 'scale(1)';
            }
        }, 100);
    }

    function destroyBrick(index) {
        const brick = state.bricks[index];

        const brickType = brickTypes[brick.type];
        const points = brickType.points * (state.combo + 1);
        state.score += points;
        updateScoreDisplay();

        showFloatingText(`+${points}`, brick.x + brick.width / 2, brick.y + brick.height / 2);

        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);

        if (Math.random() < config.powerupChance) {
            dropPowerup(brick.x + brick.width / 2, brick.y + brick.height / 2);
        }

        if (brick.type === 'explosive') {
            createExplosion(brick.x + brick.width / 2, brick.y + brick.height / 2);
            explodeAdjacentBricks(index);
            shakeScreen(1.5);
        }

        brick.element.remove();
        state.bricks.splice(index, 1);

        checkLevelComplete();
    }

    function checkLevelComplete() {
        const remainingBricks = state.bricks.filter(brick =>
            brick.type !== 'indestructible' && brick.hits > 0
        ).length;

        if (remainingBricks === 0) {
            levelComplete();
        }
    }

    function levelComplete() {
        state.running = false;

        if (state.level === config.maxLevels) {
            setTimeout(() => {
                gameComplete();
            }, 1000);
        } else {
            setTimeout(() => {
                elements.levelCompleteScreen.classList.add('active');
            }, 1000);
        }
    }

    function createExplosion(x, y) {
        const explosion = document.createElement('div');
        explosion.classList.add('explosion');
        explosion.style.width = '20px';
        explosion.style.height = '20px';
        explosion.style.left = x + 'px';
        explosion.style.top = y + 'px';
        elements.gameBoard.appendChild(explosion);

        setTimeout(() => {
            explosion.remove();
        }, 500);
    }

    function explodeAdjacentBricks(brickIndex) {
        const targetBrick = state.bricks[brickIndex];
        const explosionRadius = 60;

        const affectedBricks = [];

        for (let i = 0; i < state.bricks.length; i++) {
            if (i === brickIndex) continue;

            const brick = state.bricks[i];

            const brickCenterX = brick.x + brick.width / 2;
            const brickCenterY = brick.y + brick.height / 2;
            const explosionCenterX = targetBrick.x + targetBrick.width / 2;
            const explosionCenterY = targetBrick.y + targetBrick.height / 2;

            const distance = Math.sqrt(
                Math.pow(brickCenterX - explosionCenterX, 2) +
                Math.pow(brickCenterY - explosionCenterY, 2)
            );

            if (distance < explosionRadius) {
                affectedBricks.push(i);
            }
        }

        for (let i = affectedBricks.length - 1; i >= 0; i--) {
            const index = affectedBricks[i];
            if (state.bricks[index].type !== 'indestructible') {
                destroyBrick(index);
            }
        }
    }

    function createParticles(x, y, color) {
        for (let i = 0; i < config.particleCount; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');

            const size = Math.random() * 3 + 3;
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';

            particle.style.left = x + 'px';
            particle.style.top = y + 'px';

            particle.style.backgroundColor = color;

            elements.gameBoard.appendChild(particle);

            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            state.particles.push({
                element: particle,
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                alpha: 1,
                size: size
            });
        }
    }

    function updateParticles() {
        const particlesToRemove = [];

        for (let i = 0; i < state.particles.length; i++) {
            const particle = state.particles[i];

            particle.x += particle.vx;
            particle.y += particle.vy;

            particle.vy += 0.1;

            particle.alpha -= 0.02;

            particle.element.style.left = particle.x + 'px';
            particle.element.style.top = particle.y + 'px';
            particle.element.style.opacity = particle.alpha;

            if (particle.alpha <= 0) {
                particlesToRemove.push(i);
                particle.element.remove();
            }
        }

        for (let i = particlesToRemove.length - 1; i >= 0; i--) {
            state.particles.splice(particlesToRemove[i], 1);
        }
    }

    function clearParticles() {
        for (const particle of state.particles) {
            particle.element.remove();
        }
        state.particles = [];

        for (const trail of state.trails) {
            trail.element.remove();
        }
        state.trails = [];
    }

    function dropPowerup(x, y) {
        const powerupTypes = ['paddleSize', 'extraLife', 'fireball', 'multiball', 'speedUp', 'stickyPaddle'];
        const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

        const powerup = document.createElement('div');
        powerup.classList.add('powerup');
        powerup.textContent = getPowerupSymbol(type);
        powerup.style.backgroundColor = getPowerupColor(type);
        powerup.style.left = x + 'px';
        powerup.style.top = y + 'px';

        elements.gameBoard.appendChild(powerup);

        state.powerups.push({
            element: powerup,
            x: x,
            y: y,
            type: type,
            width: 30,
            height: 30
        });
    }

    function getPowerupSymbol(type) {
        const symbols = {
            paddleSize: '📏',
            extraLife: '❤️',
            fireball: '🔥',
            multiball: '🔮',
            speedUp: '⚡',
            stickyPaddle: '🧲'
        };

        return symbols[type] || '?';
    }

    function getPowerupColor(type) {
        const colors = {
            paddleSize: '#4CC9F0',
            extraLife: '#F72585',
            fireball: '#FF9E00',
            multiball: '#7209B7',
            speedUp: '#4361EE',
            stickyPaddle: '#80ED99'
        };

        return colors[type] || '#ffffff';
    }

    function updatePowerups() {
        const powerupsToRemove = [];

        for (let i = 0; i < state.powerups.length; i++) {
            const powerup = state.powerups[i];

            powerup.y += config.powerupSpeed;
            powerup.element.style.top = powerup.y + 'px';

            if (powerup.y + powerup.height / 2 > config.boardHeight - config.paddleHeight - 20 &&
                powerup.y - powerup.height / 2 < config.boardHeight - 20 &&
                powerup.x + powerup.width / 2 > paddle.x - paddle.width / 2 &&
                powerup.x - powerup.width / 2 < paddle.x + paddle.width / 2) {
                collectPowerup(powerup.type);
                powerupsToRemove.push(i);
                powerup.element.remove();
            }

            if (powerup.y - powerup.height / 2 > config.boardHeight) {
                powerupsToRemove.push(i);
                powerup.element.remove();
            }
        }

        for (let i = powerupsToRemove.length - 1; i >= 0; i--) {
            state.powerups.splice(powerupsToRemove[i], 1);
        }
    }

    function clearPowerups() {
        for (const powerup of state.powerups) {
            powerup.element.remove();
        }
        state.powerups = [];
    }

    function collectPowerup(type) {
        showFloatingText(getPowerupSymbol(type), paddle.x, config.boardHeight - config.paddleHeight - 20);

        switch (type) {
            case 'paddleSize':
                applyPaddleSizePowerup();
                break;
            case 'extraLife':
                applyExtraLifePowerup();
                break;
            case 'fireball':
                applyFireballPowerup();
                break;
            case 'multiball':
                applyMultiballPowerup();
                break;
            case 'speedUp':
                applySpeedUpPowerup();
                break;
            case 'stickyPaddle':
                applyStickyPaddlePowerup();
                break;
        }

        addEffect(type);
    }

    function applyPaddleSizePowerup() {
        paddle.width = Math.min(paddle.width * 1.5, 200);
        elements.paddle.style.width = paddle.width + 'px';
        elements.paddleGlow.style.width = paddle.width + 'px';
    }

    function applyExtraLifePowerup() {
        state.lives++;
        updateLivesDisplay();
    }

    function applyFireballPowerup() {
        ball.fireball = true;
        elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, #FF9E00)';
        elements.ball.style.boxShadow = '0 0 15px rgba(255, 158, 0, 0.7)';

        state.balls.forEach(ballObj => {
            ballObj.fireball = true;
            ballObj.element.style.background = 'radial-gradient(circle at 30% 30%, white, #FF9E00)';
            ballObj.element.style.boxShadow = '0 0 15px rgba(255, 158, 0, 0.7)';
        });
    }

    function applyMultiballPowerup() {
        for (let i = 0; i < config.multiBallCount; i++) {
            createNewBall();
        }
    }

    function createNewBall() {
        const newBallElement = document.createElement('div');
        newBallElement.classList.add('ball');
        newBallElement.style.width = config.ballSize + 'px';
        newBallElement.style.height = config.ballSize + 'px';

        if (ball.fireball) {
            newBallElement.style.background = 'radial-gradient(circle at 30% 30%, white, #FF9E00)';
            newBallElement.style.boxShadow = '0 0 15px rgba(255, 158, 0, 0.7)';
        }

        elements.gameBoard.appendChild(newBallElement);

        const newBall = {
            x: ball.x,
            y: ball.y,
            dx: (Math.random() * 2 - 1) * ball.speed,
            dy: -ball.speed,
            speed: ball.speed,
            launched: true,
            radius: ball.radius,
            fireball: ball.fireball,
            element: newBallElement
        };

        state.balls.push(newBall);
        updateBallPosition(newBall, newBallElement);
    }

    function applySpeedUpPowerup() {
        ball.speed = Math.min(ball.speed * 1.2, config.maxBallSpeed);
        if (ball.dx !== 0 || ball.dy !== 0) {
            const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            ball.dx = (ball.dx / magnitude) * ball.speed;
            ball.dy = (ball.dy / magnitude) * ball.speed;
        }

        state.balls.forEach(ballObj => {
            ballObj.speed = Math.min(ballObj.speed * 1.2, config.maxBallSpeed);
            if (ballObj.dx !== 0 || ballObj.dy !== 0) {
                const magnitude = Math.sqrt(ballObj.dx * ballObj.dx + ballObj.dy * ballObj.dy);
                ballObj.dx = (ballObj.dx / magnitude) * ballObj.speed;
                ballObj.dy = (ballObj.dy / magnitude) * ballObj.speed;
            }
        });
    }

    function applyStickyPaddlePowerup() {
        paddle.sticky = true;
        elements.paddle.style.background = 'linear-gradient(to right, #80ED99, #57CC99)';
    }

    function addEffect(type) {
        const existingEffect = state.effects.find(effect => effect.type === type);

        if (existingEffect) {
            existingEffect.time = Date.now();
        } else {
            state.effects.push({
                type: type,
                time: Date.now()
            });

            updateEffectIndicator();
        }
    }

    function updateEffects() {
        const currentTime = Date.now();
        const effectsToRemove = [];

        for (let i = 0; i < state.effects.length; i++) {
            const effect = state.effects[i];
            const effectElement = document.querySelector(`.effect[data-type="${effect.type}"]`);

            if (effectElement) {
                const elapsed = currentTime - effect.time;
                const remaining = 1 - (elapsed / config.effectDuration);
                effectElement.querySelector('.timer').style.transform = `scaleX(${Math.max(0, remaining)})`;
            }

            if (currentTime - effect.time > config.effectDuration) {
                effectsToRemove.push(i);

                if (effectElement) {
                    effectElement.remove();
                }

                revertEffect(effect.type);
            }
        }

        for (let i = effectsToRemove.length - 1; i >= 0; i--) {
            state.effects.splice(effectsToRemove[i], 1);
        }
    }

    function revertEffect(type) {
        switch (type) {
            case 'paddleSize':
                paddle.width = config.paddleWidth;
                elements.paddle.style.width = paddle.width + 'px';
                elements.paddleGlow.style.width = paddle.width + 'px';
                break;
            case 'fireball':
                ball.fireball = false;
                elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, var(--secondary-color))';
                elements.ball.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';

                state.balls.forEach(ballObj => {
                    ballObj.fireball = false;
                    ballObj.element.style.background = 'radial-gradient(circle at 30% 30%, white, var(--secondary-color))';
                    ballObj.element.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';
                });
                break;
            case 'speedUp':
                ball.speed = config.initialBallSpeed * levelData[state.level - 1].ballSpeed;
                if (ball.dx !== 0 || ball.dy !== 0) {
                    const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    ball.dx = (ball.dx / magnitude) * ball.speed;
                    ball.dy = (ball.dy / magnitude) * ball.speed;
                }

                state.balls.forEach(ballObj => {
                    ballObj.speed = config.initialBallSpeed * levelData[state.level - 1].ballSpeed;
                    if (ballObj.dx !== 0 || ballObj.dy !== 0) {
                        const magnitude = Math.sqrt(ballObj.dx * ballObj.dx + ballObj.dy * ballObj.dy);
                        ballObj.dx = (ballObj.dx / magnitude) * ballObj.speed;
                        ballObj.dy = (ballObj.dy / magnitude) * ballObj.speed;
                    }
                });
                break;
            case 'stickyPaddle':
                paddle.sticky = false;
                elements.paddle.style.background = 'var(--paddle-color)';
                break;
        }
    }

    function updateEffectIndicator() {
        elements.effectIndicator.innerHTML = '';

        for (const effect of state.effects) {
            const effectElement = document.createElement('div');
            effectElement.classList.add('effect');
            effectElement.dataset.type = effect.type;
            effectElement.textContent = getPowerupSymbol(effect.type);
            effectElement.style.borderColor = getPowerupColor(effect.type);

            const timer = document.createElement('div');
            timer.classList.add('timer');
            timer.style.background = getPowerupColor(effect.type);
            effectElement.appendChild(timer);

            elements.effectIndicator.appendChild(effectElement);
        }
    }

    function hasEffect(type) {
        return state.effects.some(effect => effect.type === type);
    }

    function showFloatingText(text, x, y) {
        const floatingText = document.createElement('div');
        floatingText.style.position = 'absolute';
        floatingText.style.left = x + 'px';
        floatingText.style.top = y + 'px';
        floatingText.style.color = 'white';
        floatingText.style.fontSize = '18px';
        floatingText.style.fontWeight = 'bold';
        floatingText.style.pointerEvents = 'none';
        floatingText.style.textShadow = '0 0 5px rgba(0,0,0,0.5)';
        floatingText.style.zIndex = '30';
        floatingText.style.transform = 'translate(-50%, -50%)';
        floatingText.textContent = text;
        elements.gameBoard.appendChild(floatingText);

        floatingText.animate([
            { opacity: 1, transform: 'translate(-50%, -50%)' },
            { opacity: 0, transform: 'translate(-50%, -150%)' }
        ], {
            duration: 1000,
            easing: 'ease-out'
        }).onfinish = () => {
            floatingText.remove();
        };
    }

    function resetBall() {
        ball.x = paddle.x;
        ball.y = config.boardHeight - config.paddleHeight - config.ballSize / 2 - 25;
        ball.dx = 0;
        ball.dy = 0;
        ball.launched = false;
        ball.speed = config.initialBallSpeed * (state.level > 0 ? levelData[state.level - 1].ballSpeed : 1);
        ball.fireball = false;

        elements.ball.style.background = 'radial-gradient(circle at 30% 30%, white, var(--secondary-color))';
        elements.ball.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.7)';

        updateBallPosition(ball, elements.ball);
    }

    function loseLife() {
        state.lives--;
        updateLivesDisplay();

        state.combo = 0;
        updateComboDisplay();

        clearPowerups();
        clearAdditionalBalls();

        for (const effect of state.effects) {
            revertEffect(effect.type);
        }
        state.effects = [];
        elements.effectIndicator.innerHTML = '';

        if (state.lives <= 0) {
            gameOver();
        } else {
            resetBall();
        }
    }

    function updateCombo() {
        const now = Date.now();

        if (now - state.lastBrickHit < config.comboTimeout) {
            state.combo++;
        } else {
            state.combo = 0;
        }

        state.lastBrickHit = now;
        updateComboDisplay();
    }

    function checkComboTimeout() {
        const now = Date.now();
        if (state.combo > 0 && now - state.lastBrickHit > config.comboTimeout) { // Changed from > 1 to > 0
            state.combo = 0;
            updateComboDisplay();
        }
    }

    function gameOver() {
        state.running = false;
        elements.finalScore.textContent = state.score;
        elements.gameOverScreen.classList.add('active');
    }

    function clearBricks() {
        const brickElements = document.querySelectorAll('.brick');
        brickElements.forEach(brick => brick.remove());

        state.bricks = [];
    }

    function buildLevel(level) {
        if (level < 1 || level > levelData.length) {
            console.error(`Invalid level: ${level}`);
            return;
        }

        const levelConfig = levelData[level - 1];
        const brickRowCount = levelConfig.rows;
        const brickColumnCount = levelConfig.cols;

        const brickWidth = (config.boardWidth - (config.brickOffsetLeft * 2) - (config.brickPadding * (brickColumnCount - 1))) / brickColumnCount;
        const brickHeight = config.brickHeight;

        for (let r = 0; r < brickRowCount; r++) {
            for (let c = 0; c < brickColumnCount; c++) {
                let brickType = 'normal';
                if (levelConfig.bricks[r] && levelConfig.bricks[r][c]) {
                    brickType = levelConfig.bricks[r][c];
                }

                const brickTypeInfo = brickTypes[brickType];

                if (!brickTypeInfo) continue;

                const brickX = (c * (brickWidth + config.brickPadding)) + config.brickOffsetLeft;
                const brickY = (r * (brickHeight + config.brickPadding)) + config.brickOffsetTop;

                const brick = document.createElement('div');
                brick.classList.add('brick');
                brick.style.left = brickX + 'px';
                brick.style.top = brickY + 'px';
                brick.style.width = brickWidth + 'px';
                brick.style.height = brickHeight + 'px';
                brick.style.background = brickTypeInfo.color;

                elements.gameBoard.appendChild(brick);

                state.bricks.push({
                    element: brick,
                    x: brickX,
                    y: brickY,
                    width: brickWidth,
                    height: brickHeight,
                    type: brickType,
                    originalType: brickType,
                    hits: brickTypeInfo.hits,
                    color: brickTypeInfo.color
                });
            }
        }

        ball.speed = config.initialBallSpeed * levelConfig.ballSpeed;
    }

    function updateScoreDisplay() {
        elements.scoreDisplay.textContent = `Score: ${state.score}`;
    }

    function updateLivesDisplay() {
        elements.livesDisplay.textContent = `Lives: ${state.lives}`;
    }

    function updateComboDisplay() {
        elements.comboDisplay.textContent = `Combo: x${state.combo}`;
    }

    function updateLevelDisplay() {
        elements.levelDisplay.textContent = state.level;
    }

    window.addEventListener('load', init);
</script>
<script src="../sidebar.js" data-position="bottom-right"></script>
</body>
</html>