<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ” </text></svg>">
    <title>Word Search Game</title>
    <meta name="description"
          content="Play a fun and challenging word search game with a randomly generated puzzle and a variety of words to find.">
    <meta name="keywords" content="word search, puzzle, game, fun, challenge, online word search game">
    <meta name="author" content="ChatGPT prompted by Tobias MÃ¼ller">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/word_search.html">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/json5/2.2.3/index.min.js"
            integrity="sha512-44jdhc+R2TFfzBflS3/dGNEABiNUxBkkrqwO7GWTvGsj3HkQNr3GESvI9PUvAxmqxSnTosR0Ij9y3+o+6J1hig=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>:root {
        --primary: #4361ee;
        --primary-dark: #3a56d4;
        --secondary: #f72585;
        --accent: #4cc9f0;
        --light: #f8f9fa;
        --dark: #212529;
        --success: #06d6a0;
        --warning: #ffd166;
        --gray-100: #f8f9fa;
        --gray-200: #e9ecef;
        --gray-300: #dee2e6;
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --radius: 8px;
        --transition: all 0.25s ease;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: 'Segoe UI', system-ui, sans-serif;
        background-color: var(--light);
        color: var(--dark);
        padding: 10px;
        line-height: 1.5;
    }

    .container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 10px;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 10px;
    }

    .title {
        color: var(--primary);
        font-size: 1.8rem;
        margin: 0;
    }

    .btn {
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: var(--radius);
        padding: 8px 16px;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
    }

    .btn:hover {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
    }

    .btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        transform: none;
    }

    .btn-hint {
        background-color: var(--accent);
    }

    .btn-restart {
        background-color: var(--secondary);
    }

    .game-container {
        display: grid;
        grid-template-columns:1fr;
        gap: 20px;
    }

    .panel {
        background-color: white;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 15px;
        overflow: hidden;
    }

    .game-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
    }

    .info-item {
        font-size: 1rem;
        font-weight: 500;
    }

    .timer {
        font-weight: 700;
        color: var(--primary);
    }

    .progress-container {
        height: 8px;
        background-color: var(--gray-200);
        border-radius: 4px;
        margin-bottom: 20px;
    }

    .progress-bar {
        height: 100%;
        background-color: var(--success);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .game-board-wrapper {
        overflow: visible;
        margin: 0 auto;
        width: 100%;
        position: relative;
    }

    .game-board {
        display: grid;
        gap: 1px;
        margin: 0 auto;
        user-select: none;
        position: relative;
    }

    .cell {
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--gray-300);
        border-radius: 3px;
        font-weight: 600;
        text-transform: uppercase;
        transition: var(--transition);
        cursor: pointer;
        aspect-ratio: 1/1;
        position: relative;
        z-index: 1;
    }

    .cell:hover {
        background-color: var(--gray-100);
    }

    .cell.selected {
        background-color: var(--accent);
        color: white;
    }

    .cell.found {
        background-color: var(--success);
        color: white;
    }

    .cell.hint {
        background-color: var(--warning);
        animation: pulse 2s infinite;
    }

    .selection-line {
        position: absolute;
        height: 4px;
        background-color: var(--accent);
        transform-origin: left center;
        border-radius: 2px;
        z-index: 0;
        pointer-events: none;
        opacity: 0.7;
    }

    .direction-guide {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: rgba(76, 201, 240, 0.3);
        border: 2px solid var(--accent);
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 2;
        box-shadow: 0 0 0 4px rgba(76, 201, 240, 0.1);
    }

    .direction-line {
        position: absolute;
        height: 3px;
        background-color: rgba(76, 201, 240, 0.5);
        transform-origin: left center;
        border-radius: 2px;
        z-index: 1;
        pointer-events: none;
    }

    .sidebar-container {
        display: grid;
        grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
    }

    .panel-title {
        font-size: 1.2rem;
        color: var(--primary);
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 2px solid var(--gray-200);
    }

    .word-list {
        list-style: none;
        display: grid;
        grid-template-columns:repeat(auto-fill, minmax(120px, 1fr));
        gap: 8px;
    }

    .word-item {
        padding: 8px 12px;
        background-color: var(--gray-100);
        border-radius: var(--radius);
        font-weight: 500;
        transition: var(--transition);
        text-align: center;
    }

    .word-item.found {
        background-color: var(--success);
        color: white;
        text-decoration: line-through;
    }

    .settings-form {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .form-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .form-label {
        font-weight: 600;
        font-size: 0.9rem;
    }

    .form-control {
        padding: 8px;
        border-radius: var(--radius);
        border: 1px solid var(--gray-300);
        font-family: inherit;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: white;
        border-radius: var(--radius);
        padding: 25px;
        max-width: 400px;
        width: 90%;
        text-align: center;
    }

    .modal-title {
        font-size: 1.5rem;
        margin-bottom: 15px;
        color: var(--primary);
    }

    .modal-body {
        margin-bottom: 20px;
    }

    .modal-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
    }

    .spin-loader {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 3px solid white;
        width: 16px;
        height: 16px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 6px;
        vertical-align: middle;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

    @keyframes pulse {
        0% {
            opacity: 1;
        }
        50% {
            opacity: 0.6;
        }
        100% {
            opacity: 1;
        }
    }

    @keyframes pop {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.2);
        }
        100% {
            transform: scale(1);
        }
    }

    @keyframes confetti-fall {
        0% {
            transform: translateY(-10px) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100px) rotate(360deg);
            opacity: 0;
        }
    }

    .pop {
        animation: pop 0.3s ease-in-out;
    }

    .confetti {
        position: fixed;
        width: 8px;
        height: 8px;
        background-color: var(--primary);
        pointer-events: none;
        opacity: 0;
        animation: confetti-fall 2s ease-in forwards;
    }

    @media (min-width: 769px) {
        .game-container {
            grid-template-columns:minmax(0, 2fr) minmax(0, 1fr);
        }

        .sidebar-container {
            display: flex;
            flex-direction: column;
        }
    }

    @media (max-width: 1000px) {
        .cell {
            font-size: 1rem;
        }
    }

    @media (max-width: 768px) {
        .cell {
            font-size: 0.9rem;
        }

        .title {
            font-size: 1.5rem;
        }
    }

    @media (max-width: 480px) {
        .cell {
            font-size: 0.8rem;
        }

        .container {
            padding: 5px;
        }

        .panel {
            padding: 10px;
        }
    }

    @media (max-width: 360px) {
        .cell {
            font-size: 0.7rem;
        }
    }</style>
</head>
<body>
<div class="container">
    <header class="header"><h1 class="title">Word Search Puzzle</h1>
        <div class="actions">
            <button id="hintBtn" class="btn btn-hint">Hint</button>
            <button id="restartBtn" class="btn btn-restart">Restart</button>
        </div>
    </header>
    <div class="game-container">
        <div class="panel">
            <div class="game-info">
                <div class="info-item">Score: <span id="score">0</span></div>
                <div class="info-item">Time: <span id="timer" class="timer">00:00</span></div>
            </div>
            <div class="progress-container">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
            <div class="game-board-wrapper">
                <div id="gameBoard" class="game-board"></div>
            </div>
        </div>
        <div class="sidebar-container">
            <div class="panel"><h2 class="panel-title">Words to Find</h2>
                <ul id="wordList" class="word-list"></ul>
            </div>
            <div class="panel"><h2 class="panel-title">Settings</h2>
                <form id="settingsForm" class="settings-form">
                    <div class="form-group"><label class="form-label" for="difficultySelect">Difficulty</label><select
                            id="difficultySelect" class="form-control">
                        <option value="easy">Easy (10Ã—10)</option>
                        <option value="medium" selected>Medium (15Ã—15)</option>
                        <option value="hard">Hard (20Ã—20)</option>
                    </select></div>
                    <div class="form-group"><label class="form-label" for="categorySelect">Category</label><select
                            id="categorySelect" class="form-control">
                        <option value="animals">Animals</option>
                        <option value="food">Food</option>
                        <option value="sports">Sports</option>
                        <option value="programming">Programming</option>
                        <option value="geography">Geography</option>
                        <option value="movies">Movies</option>
                        <option value="music">Music</option>
                        <option value="science">Science</option>
                    </select></div>
                    <div class="form-group"><label class="form-label" for="customThemeInput">Custom Theme
                        (optional)</label><input type="text" id="customThemeInput" class="form-control"
                                                 placeholder="e.g., Star Wars, Dinosaurs..."></div>
                    <button type="submit" class="btn">Apply</button>
                </form>
            </div>
        </div>
    </div>
</div>
<div id="winModal" class="modal">
    <div class="modal-content"><h2 class="modal-title">Congratulations!</h2>
        <div class="modal-body"><p>You found all the words!</p>
            <p>Time: <span id="finalTime">00:00</span></p>
            <p>Score: <span id="finalScore">0</span></p></div>
        <div class="modal-actions">
            <button id="newGameBtn" class="btn">New Game</button>
        </div>
    </div>
</div>
<div id="restartModal" class="modal">
    <div class="modal-content"><h2 class="modal-title">Restart Game?</h2>
        <div class="modal-body"><p>Are you sure you want to restart? Your current progress will be lost.</p></div>
        <div class="modal-actions">
            <button id="cancelRestartBtn" class="btn">Cancel</button>
            <button id="confirmRestartBtn" class="btn btn-restart">Restart</button>
        </div>
    </div>
</div>
<div id="loadingModal" class="modal">
    <div class="modal-content"><h2 class="modal-title">Generating Words</h2>
        <div class="modal-body"><p><span class="spin-loader"></span> AI is crafting words for your puzzle...</p>
            <p>This might take a few seconds.</p></div>
    </div>
</div>
<script>class WordSearchGame {
    constructor() {
        this.gridSize = 15;
        this.wordCount = 8;
        this.difficulty = 'medium';
        this.category = 'animals';
        this.customTheme = '';
        this.gameBoard = [];
        this.words = [];
        this.usedWordPositions = new Set();
        this.foundWords = [];
        this.foundWordPositions = [];
        this.score = 0;
        this.startTime = null;
        this.timerInterval = null;
        this.isSelecting = false;
        this.selectedCells = [];
        this.selectedWord = '';
        this.startCell = null;
        this.currentCell = null;
        this.selectionLine = null;
        this.directionLocked = false;
        this.directionVector = null;
        this.cellPositions = new Map();
        this.cellElements = [];
        this.currentEndCell = null;
        this.cellSize = 0;
        this.hintsUsed = 0;
        this.wordLists = {
            programming: ['javascript', 'python', 'html', 'css', 'react', 'angular', 'node', 'database', 'algorithm', 'function', 'variable', 'object', 'array', 'string', 'class'],
            animals: ['dog', 'cat', 'elephant', 'tiger', 'lion', 'giraffe', 'monkey', 'zebra', 'penguin', 'bear', 'wolf', 'fox', 'rabbit', 'deer', 'eagle'],
            food: ['pizza', 'pasta', 'burger', 'chicken', 'salad', 'cheese', 'bread', 'apple', 'banana', 'orange', 'carrot', 'potato', 'tomato', 'onion', 'garlic'],
            sports: ['soccer', 'basketball', 'tennis', 'golf', 'swimming', 'running', 'cycling', 'volleyball', 'baseball', 'hockey', 'rugby', 'cricket', 'boxing', 'skiing', 'surfing'],
            geography: ['mountain', 'river', 'ocean', 'desert', 'forest', 'island', 'valley', 'plateau', 'canyon', 'glacier', 'volcano', 'waterfall', 'peninsula', 'continent', 'equator'],
            movies: ['actor', 'director', 'camera', 'scene', 'script', 'costume', 'trailer', 'premiere', 'sequel', 'Oscar', 'villain', 'studio', 'editing', 'comedy', 'drama'],
            music: ['guitar', 'piano', 'drums', 'violin', 'singer', 'concert', 'rhythm', 'melody', 'harmony', 'album', 'lyric', 'tempo', 'chorus', 'composer', 'orchestra'],
            science: ['experiment', 'hypothesis', 'molecule', 'electron', 'gravity', 'bacteria', 'telescope', 'microscope', 'quantum', 'evolution', 'biology', 'chemistry', 'physics', 'geology', 'astronomy']
        };
        this.initElements();
        this.initEventListeners();
        this.loadSavedGameOrStart();
    }

    initElements() {
        this.boardEl = document.getElementById('gameBoard');
        this.wordListEl = document.getElementById('wordList');
        this.timerEl = document.getElementById('timer');
        this.scoreEl = document.getElementById('score');
        this.progressBarEl = document.getElementById('progressBar');
        this.settingsFormEl = document.getElementById('settingsForm');
        this.difficultySelectEl = document.getElementById('difficultySelect');
        this.categorySelectEl = document.getElementById('categorySelect');
        this.customThemeInputEl = document.getElementById('customThemeInput');
        this.restartBtnEl = document.getElementById('restartBtn');
        this.hintBtnEl = document.getElementById('hintBtn');
        this.winModalEl = document.getElementById('winModal');
        this.restartModalEl = document.getElementById('restartModal');
        this.loadingModalEl = document.getElementById('loadingModal');
        this.confirmRestartBtnEl = document.getElementById('confirmRestartBtn');
        this.cancelRestartBtnEl = document.getElementById('cancelRestartBtn');
        this.newGameBtnEl = document.getElementById('newGameBtn');
        this.finalTimeEl = document.getElementById('finalTime');
        this.finalScoreEl = document.getElementById('finalScore');
    }

    initEventListeners() {
        this.settingsFormEl.addEventListener('submit', (e) => {
            e.preventDefault();
            this.updateSettings();
        });
        this.restartBtnEl.addEventListener('click', () => this.showModal(this.restartModalEl));
        this.hintBtnEl.addEventListener('click', () => this.giveHint());
        this.confirmRestartBtnEl.addEventListener('click', () => {
            this.hideModal(this.restartModalEl);
            this.restartGame();
        });
        this.cancelRestartBtnEl.addEventListener('click', () => this.hideModal(this.restartModalEl));
        this.newGameBtnEl.addEventListener('click', () => {
            this.hideModal(this.winModalEl);
            this.restartGame();
        });
        this.boardEl.addEventListener('mousedown', (e) => this.handleSelectionStart(e));
        this.boardEl.addEventListener('touchstart', (e) => this.handleSelectionStart(e), {passive: false});
        document.addEventListener('mousemove', (e) => this.handleSelectionMove(e));
        document.addEventListener('touchmove', (e) => this.handleTouchMove(e), {passive: false});
        document.addEventListener('mouseup', () => this.handleSelectionEnd());
        document.addEventListener('touchend', () => this.handleSelectionEnd());
        document.addEventListener('mouseleave', () => this.handleSelectionEnd());
    }

    updateSettings() {
        this.difficulty = this.difficultySelectEl.value;
        this.category = this.categorySelectEl.value;
        this.customTheme = this.customThemeInputEl.value.trim();
        switch (this.difficulty) {
            case'easy':
                this.gridSize = 10;
                this.wordCount = 6;
                break;
            case'medium':
                this.gridSize = 15;
                this.wordCount = 8;
                break;
            case'hard':
                this.gridSize = 20;
                this.wordCount = 12;
                break;
        }
        this.restartGame();
    }

    async loadGame() {
        this.createEmptyGameBoard();
        this.usedWordPositions = new Set();
        this.showModal(this.loadingModalEl);
        try {
            await this.fetchAIGeneratedWords();
        } catch (error) {
            console.error('Error generating AI words:', error);
            alert('There was an error generating words. Using predefined words instead.');
            await this.fetchPredefinedWords();
        }
        this.hideModal(this.loadingModalEl);
        this.preventWordOverlap();
        this.placeWordsOnGameBoard();
        this.fillEmptyCells();
        this.renderGameBoard();
        this.renderWordList();
        this.startTimer();
        this.saveGameState();
    }

    loadSavedGameOrStart() {
        if (!this.loadGameState()) {
            this.loadGame();
        }
    }

    async fetchAIGeneratedWords() {
        const theme = this.customTheme ? this.customTheme : this.category;
        const minLength = 3;
        const maxLength = this.gridSize - 2;
        const botMessage = `You are a word search puzzle API. Generate a list of ${this.wordCount + 3} words on the theme "${theme}". The words must be between ${minLength} and ${maxLength} characters long. Provide ONLY a JSON response in this exact format without additional text: {"words":["word1","word2",...]}`;
        try {
            const response = await fetch('https://chatgpt.tobiasmue91.workers.dev/', {
                method: 'POST',
                headers: {"Content-Type": "application/json", "Accept": "*/*"},
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    max_tokens: 250,
                    temperature: 0.8,
                    messages: [{role: "assistant", content: botMessage}, {
                        role: "user",
                        content: `Generate ${this.wordCount + 3} words for a word search puzzle on the theme "${theme}". Words should be between ${minLength} and ${maxLength} characters long.`
                    }],
                })
            });
            if (!response.ok) {
                throw new Error('Failed to fetch AI-generated words');
            }
            const data = await response.json();
            const responseContent = data.choices[0].message.content;
            const jsonStart = responseContent.indexOf('{');
            const jsonEnd = responseContent.lastIndexOf('}') + 1;
            const jsonStr = responseContent.substring(jsonStart, jsonEnd);
            const parsedResponse = JSON5.parse(jsonStr);
            if (Array.isArray(parsedResponse.words) && parsedResponse.words.length > 0) {
                this.words = parsedResponse.words.map(word => word.toLowerCase());
                if (this.words.length < this.wordCount) {
                    const additionalWords = this.getRandomWords(this.category, this.wordCount - this.words.length);
                    this.words = [...this.words, ...additionalWords];
                }
                this.words = this.words.filter(word => word.length > minLength && word.length < maxLength);
                if (this.words.length < this.wordCount) {
                    const additionalWords = this.getRandomWords(this.category, this.wordCount - this.words.length);
                    this.words = [...this.words, ...additionalWords];
                }
                this.words = this.words.slice(0, this.wordCount);
            } else {
                throw new Error('Invalid response format from AI');
            }
        } catch (error) {
            console.error('Error fetching AI words:', error);
            throw error;
        }
    }

    async fetchPredefinedWords() {
        this.words = this.getRandomWords(this.category);
    }

    getRandomWords(category, count = this.wordCount) {
        const words = this.wordLists[category] || this.wordLists.animals;
        return [...words].sort(() => 0.5 - Math.random()).slice(0, count);
    }

    preventWordOverlap() {
        const wordsToCheck = [...this.words];
        const filteredWords = [];
        for (const word of wordsToCheck) {
            let hasOverlap = false;
            for (const existingWord of filteredWords) {
                if (existingWord.includes(word) || word.includes(existingWord)) {
                    hasOverlap = true;
                    break;
                }
            }
            if (!hasOverlap) {
                filteredWords.push(word);
            }
        }
        if (filteredWords.length < this.wordCount) {
            const additionalWords = this.getRandomWords(this.category, this.wordCount - filteredWords.length);
            for (const word of additionalWords) {
                if (!filteredWords.some(w => w.includes(word) || word.includes(w))) {
                    filteredWords.push(word);
                    if (filteredWords.length >= this.wordCount) break;
                }
            }
        }
        this.words = filteredWords.slice(0, this.wordCount);
    }

    createEmptyGameBoard() {
        this.gameBoard = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(''));
    }

    placeWordsOnGameBoard() {
        this.foundWordPositions = [];
        for (const word of this.words) {
            let wordPlaced = false;
            let attempts = 0;
            while (!wordPlaced && attempts < 100) {
                attempts++;
                const direction = Math.floor(Math.random() * 8);
                const row = Math.floor(Math.random() * this.gridSize);
                const col = Math.floor(Math.random() * this.gridSize);
                if (this.canPlaceWord(word, row, col, direction)) {
                    this.placeWord(word, row, col, direction);
                    this.foundWordPositions.push({word, row, col, direction});
                    wordPlaced = true;
                }
            }
            if (!wordPlaced) console.warn(`Could not place word: ${word}`);
        }
    }

    canPlaceWord(word, row, col, direction) {
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        const [dr, dc] = dirs[direction];
        const len = word.length;
        for (let i = 0; i < len; i++) {
            const r = row + i * dr;
            const c = col + i * dc;
            if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) return false;
            if (this.gameBoard[r][c] !== '' && this.gameBoard[r][c] !== word[i]) return false;
        }
        const wordKey = `${word}_${row}_${col}_${direction}`;
        if (this.usedWordPositions.has(wordKey)) return false;
        for (let i = 0; i < len; i++) {
            const r = row + i * dr;
            const c = col + i * dc;
            const cellPos = `${r}_${c}`;
            if (this.checkForOverlappingWords(word, cellPos)) return false;
        }
        return true;
    }

    checkForOverlappingWords(newWord, cellPos) {
        for (const position of this.usedWordPositions) {
            const [word, row, col, direction] = position.split('_');
            if (word !== newWord && this.doesWordPassThroughCell(parseInt(row), parseInt(col), parseInt(direction), word.length, cellPos)) {
                return true;
            }
        }
        return false;
    }

    doesWordPassThroughCell(row, col, direction, length, cellPos) {
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        const [dr, dc] = dirs[direction];
        for (let i = 0; i < length; i++) {
            const r = row + i * dr;
            const c = col + i * dc;
            if (`${r}_${c}` === cellPos) return true;
        }
        return false;
    }

    placeWord(word, row, col, direction) {
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        const [dr, dc] = dirs[direction];
        for (let i = 0; i < word.length; i++) {
            const r = row + i * dr;
            const c = col + i * dc;
            this.gameBoard[r][c] = word[i];
        }
        const wordKey = `${word}_${row}_${col}_${direction}`;
        this.usedWordPositions.add(wordKey);
    }

    fillEmptyCells() {
        for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
                if (this.gameBoard[i][j] === '') {
                    this.gameBoard[i][j] = String.fromCharCode(97 + Math.floor(Math.random() * 26));
                }
            }
        }
    }

    renderGameBoard() {
        this.boardEl.innerHTML = '';
        this.cellPositions = new Map();
        this.cellElements = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
        const calculateCellSize = () => {
            const containerWidth = this.boardEl.parentElement.clientWidth;
            const availableWidth = containerWidth - 15;
            return Math.floor(availableWidth / this.gridSize);
        };
        this.cellSize = calculateCellSize();
        this.boardEl.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
        for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.textContent = this.gameBoard[i][j];
                this.cellPositions.set(cell, {row: i, col: j});
                this.cellElements[i][j] = cell;
                this.boardEl.appendChild(cell);
            }
        }
        window.addEventListener('resize', () => {
            const newCellSize = calculateCellSize();
            this.cellSize = newCellSize;
            document.querySelectorAll('.cell').forEach(cell => {
                cell.style.width = `${newCellSize}px`;
                cell.style.height = `${newCellSize}px`;
                cell.style.fontSize = `${Math.max(newCellSize * 0.5, 12)}px`;
            });
        });
        document.querySelectorAll('.cell').forEach(cell => {
            cell.style.width = `${this.cellSize}px`;
            cell.style.height = `${this.cellSize}px`;
            cell.style.fontSize = `${Math.max(this.cellSize * 0.5, 12)}px`;
        });
        this.markFoundWords();
    }

    markFoundWords() {
        if (!this.foundWords || !this.foundWords.length) return;
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        for (const foundWord of this.foundWords) {
            if (this.foundWordPositions && this.foundWordPositions.length > 0) {
                const position = this.foundWordPositions.find(pos => pos.word === foundWord);
                if (position) {
                    const {row, col, direction} = position;
                    const [dr, dc] = dirs[direction];
                    for (let i = 0; i < foundWord.length; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        if (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                            const cell = this.cellElements[r][c];
                            if (cell) cell.classList.add('found');
                        }
                    }
                } else {
                    this.findAndMarkWord(foundWord);
                }
            }
        }
        if ((!this.foundWordPositions || this.foundWordPositions.length === 0) && this.foundWords.length > 0) {
            for (const foundWord of this.foundWords) {
                this.findAndMarkWord(foundWord);
            }
        }
    }

    findAndMarkWord(word) {
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                if (this.gameBoard[row][col].toLowerCase() === word[0]) {
                    for (let dirIndex = 0; dirIndex < dirs.length; dirIndex++) {
                        const [dr, dc] = dirs[dirIndex];
                        let found = true;
                        for (let i = 0; i < word.length; i++) {
                            const r = row + i * dr;
                            const c = col + i * dc;
                            if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize || this.gameBoard[r][c].toLowerCase() !== word[i]) {
                                found = false;
                                break;
                            }
                        }
                        if (found) {
                            for (let i = 0; i < word.length; i++) {
                                const r = row + i * dr;
                                const c = col + i * dc;
                                const cell = this.cellElements[r][c];
                                if (cell) cell.classList.add('found');
                            }
                            if (!this.foundWordPositions) this.foundWordPositions = [];
                            this.foundWordPositions.push({word, row, col, direction: dirIndex});
                            return;
                        }
                    }
                }
            }
        }
        console.warn(`Could not find word on board: ${word}`);
    }

    renderWordList() {
        this.wordListEl.innerHTML = '';
        this.words.forEach(word => {
            const li = document.createElement('li');
            li.className = 'word-item';
            li.id = `word-${word}`;
            li.textContent = word;
            if (this.foundWords && this.foundWords.includes(word)) {
                li.classList.add('found');
            }
            this.wordListEl.appendChild(li);
        });
    }

    clearSelections() {
        try {
            document.querySelectorAll('.cell.selected').forEach(cell => {
                if (!cell.classList.contains('found')) {
                    cell.classList.remove('selected');
                }
            });
        } catch (e) {
            console.warn('Error clearing selections:', e);
        }
    }

    handleSelectionStart(e) {
        if (e.type === 'touchstart') e.preventDefault();
        this.clearSelections();
        const target = e.type === 'touchstart' ? document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY) : e.target;
        if (!target || !target.classList.contains('cell')) return;
        this.isSelecting = true;
        this.directionLocked = false;
        this.directionVector = null;
        this.selectedWord = '';
        this.selectedCells = [];
        this.currentEndCell = null;
        this.startCell = target;
        const pos = this.cellPositions.get(target);
        if (!pos) return;
        const rect = target.getBoundingClientRect();
        this.startPoint = {x: rect.left + rect.width / 2, y: rect.top + rect.height / 2, row: pos.row, col: pos.col};
        if (!this.selectionLine) {
            this.selectionLine = document.createElement('div');
            this.selectionLine.className = 'selection-line';
            this.boardEl.appendChild(this.selectionLine);
        }
        this.selectionLine.style.left = `${this.startPoint.x - this.boardEl.getBoundingClientRect().left}px`;
        this.selectionLine.style.top = `${this.startPoint.y - this.boardEl.getBoundingClientRect().top}px`;
        this.selectionLine.style.width = '0px';
        this.selectionLine.style.transform = 'rotate(0deg)';
        this.selectionLine.style.display = 'block';
        this.showDirectionGuides(this.startPoint);
        this.selectCell(target);
    }

    handleSelectionMove(e) {
        if (!this.isSelecting || !this.startCell) return;
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        this.updateSelection(mouseX, mouseY);
    }

    handleTouchMove(e) {
        if (!this.isSelecting || !this.startCell) return;
        e.preventDefault();
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
        this.updateSelection(touchX, touchY);
    }

    getCellFromPoint(x, y) {
        const boardRect = this.boardEl.getBoundingClientRect();
        const relX = x - boardRect.left;
        const relY = y - boardRect.top;
        if (relX < 0 || relX > boardRect.width || relY < 0 || relY > boardRect.height) {
            return this.handleOutOfBoundsPoint(x, y);
        }
        const col = Math.floor(relX / this.cellSize);
        const row = Math.floor(relY / this.cellSize);
        if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
            return this.cellElements[row][col];
        }
        return null;
    }

    handleOutOfBoundsPoint(x, y) {
        if (!this.directionVector || !this.startPoint) return null;
        const boardRect = this.boardEl.getBoundingClientRect();
        const {dr, dc} = this.directionVector;
        let row, col;
        if (x < boardRect.left) {
            col = 0;
        } else if (x > boardRect.left + boardRect.width) {
            col = this.gridSize - 1;
        } else {
            col = Math.floor((x - boardRect.left) / this.cellSize);
        }
        if (y < boardRect.top) {
            row = 0;
        } else if (y > boardRect.top + boardRect.height) {
            row = this.gridSize - 1;
        } else {
            row = Math.floor((y - boardRect.top) / this.cellSize);
        }
        if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
            return this.cellElements[row][col];
        }
        return null;
    }

    updateSelection(currentX, currentY) {
        try {
            const boardRect = this.boardEl.getBoundingClientRect();
            const startX = this.startPoint.x - boardRect.left;
            const startY = this.startPoint.y - boardRect.top;
            const currentXRel = currentX - boardRect.left;
            const currentYRel = currentY - boardRect.top;
            const dx = currentXRel - startX;
            const dy = currentYRel - startY;
            const length = Math.sqrt(dx * dx + dy * dy);
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            this.selectionLine.style.width = `${length}px`;
            this.selectionLine.style.transform = `rotate(${angle}deg)`;
            const endCell = this.getCellFromPoint(currentX, currentY);
            if (!endCell) return;
            if (!this.directionLocked && length > 25) {
                this.directionLocked = true;
                const possibleAngles = [0, 45, 90, 135, 180, -135, -90, -45];
                const closestAngle = possibleAngles.reduce((prev, curr) => Math.abs(curr - angle) < Math.abs(prev - angle) ? curr : prev);
                let dr, dc;
                switch (closestAngle) {
                    case 0:
                        dr = 0;
                        dc = 1;
                        break;
                    case 45:
                        dr = 1;
                        dc = 1;
                        break;
                    case 90:
                        dr = 1;
                        dc = 0;
                        break;
                    case 135:
                        dr = 1;
                        dc = -1;
                        break;
                    case 180:
                        dr = 0;
                        dc = -1;
                        break;
                    case-135:
                        dr = -1;
                        dc = -1;
                        break;
                    case-90:
                        dr = -1;
                        dc = 0;
                        break;
                    case-45:
                        dr = -1;
                        dc = 1;
                        break;
                }
                this.directionVector = {dr, dc};
                this.removeDirectionGuides();
                angle = closestAngle;
                this.selectionLine.style.transform = `rotate(${angle}deg)`;
            }
            if (this.directionLocked) {
                const endCellPos = this.cellPositions.get(endCell);
                if (!endCellPos) return;
                if (this.currentEndCell !== endCell && this.isValidEndCell(endCellPos.row, endCellPos.col)) {
                    this.currentEndCell = endCell;
                    this.updateCellsToEndCell(endCellPos.row, endCellPos.col);
                }
            }
        } catch (e) {
            console.error('Selection error:', e);
            this.handleSelectionEnd();
        }
    }

    isValidEndCell(row, col) {
        if (!this.directionVector) return false;
        const {dr, dc} = this.directionVector;
        const startRow = this.startPoint.row;
        const startCol = this.startPoint.col;
        if (dr === 0) {
            return col >= startCol ? dc > 0 : dc < 0;
        } else if (dc === 0) {
            return row >= startRow ? dr > 0 : dr < 0;
        } else if (dr > 0 && dc > 0) {
            return row >= startRow && col >= startCol;
        } else if (dr > 0 && dc < 0) {
            return row >= startRow && col <= startCol;
        } else if (dr < 0 && dc < 0) {
            return row <= startRow && col <= startCol;
        } else if (dr < 0 && dc > 0) {
            return row <= startRow && col >= startCol;
        }
        return false;
    }

    updateCellsToEndCell(endRow, endCol) {
        if (!this.directionVector) return;
        this.selectedCells.forEach(cell => {
            if (!cell.classList.contains('found')) {
                cell.classList.remove('selected');
            }
        });
        this.selectedCells = [this.startCell];
        this.selectedWord = this.startCell.textContent.toLowerCase();
        this.startCell.classList.add('selected');
        const {dr, dc} = this.directionVector;
        const startRow = this.startPoint.row;
        const startCol = this.startPoint.col;
        const rowDiff = endRow - startRow;
        const colDiff = endCol - startCol;
        let steps;
        if (dr === 0) {
            steps = Math.abs(colDiff);
        } else if (dc === 0) {
            steps = Math.abs(rowDiff);
        } else {
            steps = Math.min(Math.abs(rowDiff), Math.abs(colDiff));
        }
        for (let i = 1; i <= steps; i++) {
            const currentRow = startRow + i * dr;
            const currentCol = startCol + i * dc;
            if (currentRow >= 0 && currentRow < this.gridSize && currentCol >= 0 && currentCol < this.gridSize) {
                const cell = this.cellElements[currentRow][currentCol];
                if (cell) {
                    this.selectCell(cell);
                }
            }
        }
    }

    showDirectionGuides(startPoint) {
        this.removeDirectionGuides();
        try {
            const boardRect = this.boardEl.getBoundingClientRect();
            const cellSize = boardRect.width / this.gridSize;
            const centerX = startPoint.x - boardRect.left;
            const centerY = startPoint.y - boardRect.top;
            const centerDot = document.createElement('div');
            centerDot.className = 'direction-guide';
            centerDot.style.left = `${centerX}px`;
            centerDot.style.top = `${centerY}px`;
            this.boardEl.appendChild(centerDot);
            const directions = [{angle: 0, dx: 1, dy: 0}, {angle: 45, dx: 1, dy: 1}, {angle: 90, dx: 0, dy: 1}, {
                angle: 135,
                dx: -1,
                dy: 1
            }, {angle: 180, dx: -1, dy: 0}, {angle: 225, dx: -1, dy: -1}, {angle: 270, dx: 0, dy: -1}, {
                angle: 315,
                dx: 1,
                dy: -1
            }];
            directions.forEach(dir => {
                const line = document.createElement('div');
                line.className = 'direction-line';
                line.style.left = `${centerX}px`;
                line.style.top = `${centerY}px`;
                line.style.width = `${cellSize * 1.5}px`;
                line.style.transform = `rotate(${dir.angle}deg)`;
                this.boardEl.appendChild(line);
            });
        } catch (e) {
            console.warn('Error showing guides:', e);
        }
    }

    removeDirectionGuides() {
        document.querySelectorAll('.direction-guide, .direction-line').forEach(el => el.remove());
    }

    selectCell(cell) {
        if (!cell || this.selectedCells.includes(cell)) return;
        this.selectedCells.push(cell);
        cell.classList.add('selected');
        this.selectedWord += cell.textContent.toLowerCase();
    }

    handleSelectionEnd() {
        if (!this.isSelecting) return;
        this.isSelecting = false;
        this.removeDirectionGuides();
        if (this.selectionLine) {
            this.selectionLine.style.display = 'none';
        }
        this.checkSelectedWord();
        setTimeout(() => {
            document.querySelectorAll('.cell.selected').forEach(cell => {
                if (!cell.classList.contains('found')) {
                    cell.classList.remove('selected');
                }
            });
        }, 50);
        this.selectedCells = [];
        this.selectedWord = '';
        this.startCell = null;
        this.currentEndCell = null;
        this.directionLocked = false;
    }

    checkSelectedWord() {
        if (!this.selectedWord || this.selectedWord.length < 2) return;
        let matchFound = false;
        let exactMatchWord = '';
        let prefixMatch = false;
        let prefixMatchWord = '';
        let suffixMatch = false;
        let suffixMatchWord = '';
        let oneOffMatch = false;
        let oneOffMatchWord = '';
        for (const word of this.words) {
            if (this.foundWords && this.foundWords.includes(word)) continue;
            const wordLower = word.toLowerCase();
            if (this.selectedWord === wordLower) {
                matchFound = true;
                exactMatchWord = word;
                break;
            }
            if (wordLower.startsWith(this.selectedWord) && this.selectedWord.length >= wordLower.length - 1) {
                prefixMatch = true;
                prefixMatchWord = word;
            } else if (wordLower.endsWith(this.selectedWord) && this.selectedWord.length >= wordLower.length - 1) {
                suffixMatch = true;
                suffixMatchWord = word;
            } else if (this.selectedWord.length === wordLower.length - 1 || this.selectedWord.length === wordLower.length + 1 || this.selectedWord.length === wordLower.length) {
                const editDistance = this.levenshteinDistance(this.selectedWord, wordLower);
                if (editDistance <= 1) {
                    oneOffMatch = true;
                    oneOffMatchWord = word;
                }
            }
        }
        if (matchFound) {
            this.addFoundWord(exactMatchWord);
        } else if (prefixMatch) {
            this.addFoundWord(prefixMatchWord, true);
        } else if (suffixMatch) {
            this.addFoundWord(suffixMatchWord, true);
        } else if (oneOffMatch) {
            this.addFoundWord(oneOffMatchWord, true);
        }
    }

    levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
        const matrix = [];
        for (let i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
        for (let j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                }
            }
        }
        return matrix[b.length][a.length];
    }

    findWordOnBoard(word) {
        const wordLower = word.toLowerCase();
        const dirs = [[0, 1], [1, 0], [1, 1], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                if (this.gameBoard[row][col].toLowerCase() === wordLower[0]) {
                    for (let dirIndex = 0; dirIndex < dirs.length; dirIndex++) {
                        const [dr, dc] = dirs[dirIndex];
                        let found = true;
                        let cells = [];
                        for (let i = 0; i < wordLower.length; i++) {
                            const r = row + i * dr;
                            const c = col + i * dc;
                            if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize || this.gameBoard[r][c].toLowerCase() !== wordLower[i]) {
                                found = false;
                                break;
                            }
                            if (this.cellElements[r][c]) {
                                cells.push(this.cellElements[r][c]);
                            }
                        }
                        if (found && cells.length === wordLower.length) {
                            return {cells, row, col, direction: dirIndex};
                        }
                    }
                }
            }
        }
        return null;
    }

    addFoundWord(word, withTolerance = false) {
        if (!word || this.foundWords.includes(word)) return;
        const result = this.findWordOnBoard(word);
        if (result) {
            const {cells, row, col, direction} = result;
            if (!this.foundWords) this.foundWords = [];
            this.foundWords.push(word);
            cells.forEach(cell => {
                cell.classList.add('found');
                cell.classList.add('pop');
                setTimeout(() => cell.classList.remove('pop'), 300);
            });
            if (!this.foundWordPositions) this.foundWordPositions = [];
            this.foundWordPositions.push({word, row, col, direction});
            const wordEl = document.getElementById(`word-${word}`);
            if (wordEl) wordEl.classList.add('found');
            this.updateScore(word);
            this.updateProgress();
            this.createFoundAnimation();
            this.checkGameCompletion();
            this.saveGameState();
        }
    }

    updateScore(word) {
        const multiplier = this.difficulty === 'easy' ? 1 : this.difficulty === 'medium' ? 1.5 : 2;
        const points = Math.round(word.length * 10 * multiplier);
        this.score += points;
        this.scoreEl.textContent = this.score;
    }

    updateProgress() {
        if (!this.foundWords || !this.words) return;
        const progress = (this.foundWords.length / this.words.length) * 100;
        this.progressBarEl.style.width = `${progress}%`;
    }

    createFoundAnimation() {
        for (let i = 0; i < 20; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 80%, 60%)`;
            confetti.style.left = `${Math.random() * 100}%`;
            confetti.style.top = `${Math.random() * 100}%`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 2000);
        }
    }

    checkGameCompletion() {
        if (!this.foundWords || !this.words) return;
        if (this.foundWords.length === this.words.length) {
            clearInterval(this.timerInterval);
            this.finalTimeEl.textContent = this.timerEl.textContent;
            this.finalScoreEl.textContent = this.score;
            setTimeout(() => this.showModal(this.winModalEl), 500);
            localStorage.removeItem('wordSearchGameState');
        }
    }

    giveHint() {
        if (!this.words || !this.foundWords) return;
        const unfoundWords = this.words.filter(word => !this.foundWords.includes(word));
        if (unfoundWords.length === 0) return;
        const word = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];
        const result = this.findWordOnBoard(word);
        if (result) {
            const {row, col} = result;
            const cell = this.cellElements[row][col];
            if (cell) {
                cell.classList.add('hint');
                setTimeout(() => cell.classList.remove('hint'), 2000);
                if (this.score >= 10) {
                    this.score -= 10;
                    this.scoreEl.textContent = this.score;
                }
            }
        }
    }

    startTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        this.startTime = Date.now();
        this.timerInterval = setInterval(() => {
            const elapsed = Date.now() - this.startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            this.timerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
    }

    showModal(modal) {
        modal.style.display = 'flex';
    }

    hideModal(modal) {
        modal.style.display = 'none';
    }

    restartGame() {
        clearInterval(this.timerInterval);
        this.foundWords = [];
        this.foundWordPositions = [];
        this.score = 0;
        this.scoreEl.textContent = '0';
        this.progressBarEl.style.width = '0%';
        this.loadGame();
    }

    saveGameState() {
        try {
            const state = {
                gridSize: this.gridSize,
                difficulty: this.difficulty,
                category: this.category,
                customTheme: this.customTheme,
                gameBoard: this.gameBoard,
                words: this.words,
                foundWords: this.foundWords,
                foundWordPositions: this.foundWordPositions,
                score: this.score,
                startTime: Date.now() - (this.startTime ? Date.now() - this.startTime : 0)
            };
            localStorage.setItem('wordSearchGameState', JSON.stringify(state));
        } catch (e) {
            console.error('Error saving game:', e);
        }
    }

    loadGameState() {
        try {
            const saved = localStorage.getItem('wordSearchGameState');
            if (!saved) return false;
            const state = JSON.parse(saved);
            this.gridSize = state.gridSize;
            this.difficulty = state.difficulty;
            this.category = state.category;
            this.customTheme = state.customTheme || '';
            this.gameBoard = state.gameBoard;
            this.words = state.words;
            this.foundWords = state.foundWords || [];
            this.foundWordPositions = state.foundWordPositions || [];
            this.score = state.score;
            this.startTime = Date.now() - (Date.now() - state.startTime);
            this.difficultySelectEl.value = this.difficulty;
            this.categorySelectEl.value = this.category;
            this.customThemeInputEl.value = this.customTheme;
            this.scoreEl.textContent = this.score;
            this.updateProgress();
            this.renderGameBoard();
            this.renderWordList();
            this.startTimer();
            return true;
        } catch (error) {
            console.error('Error loading game:', error);
            return false;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => new WordSearchGame());</script>
<script src="../logo.js"></script>
</body>
</html>