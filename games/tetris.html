<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ§©</text></svg>">
    <meta charset="UTF-8">
    <title>Tetris</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
          integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="description"
          content="Play Tetris online for free. A classic arcade game that tests your skills and strategy.">
    <meta name="keywords" content="Tetris, arcade game, free online game, online tetris, tetris online game">
    <style>:root {
        --primary: #2c3e50;
        --secondary: #3498db;
        --accent: #e74c3c;
        --bg: #ecf0f1;
        --text: #2c3e50;
        --panel: rgba(255, 255, 255, 0.9);
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1)
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 25%, #ffd3b6 50%, #ffaaa5 75%, #ff8b94 100%);
        overflow: hidden
    }

    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        min-height: 100vh;
        width: 100%;
        padding: 10px 10px 20px 10px;
        position: relative;
        overflow-y: auto
    }

    #header-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        background: var(--panel);
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 10px;
        box-shadow: var(--shadow)
    }

    #game-area {
        flex-grow: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 5px 0;
        position: relative;
        overflow: hidden;
        max-height: 60vh
    }

    #tetris-board {
        border: 2px solid var(--primary);
        border-radius: 5px;
        max-height: 100%;
        width: auto;
        margin: 0 auto;
        display: block
    }

    #controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        background: var(--panel);
        border-radius: 8px;
        padding: 15px 10px;
        margin-top: 15px;
        margin-bottom: 10px;
        box-shadow: var(--shadow);
        position: relative;
        z-index: 100;
        min-height: 70px
    }

    .info-block {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 10px
    }

    .info-label {
        font-size: 12px;
        font-weight: bold;
        color: var(--primary)
    }

    .info-value {
        font-size: 16px;
        font-weight: bold;
        color: var(--accent)
    }

    #preview-area {
        display: flex;
        justify-content: space-between;
        width: 100%
    }

    .preview-block {
        background: var(--panel);
        border-radius: 8px;
        padding: 5px;
        width: 48%;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        align-items: center
    }

    .preview-label {
        font-size: 12px;
        font-weight: bold;
        color: var(--primary);
        margin-bottom: 5px
    }

    .controls-group {
        display: flex
    }

    .control-btn {
        background: var(--secondary);
        color: white;
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        margin: 0 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow);
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation
    }

    .control-btn:active {
        transform: scale(0.9);
        background: var(--primary)
    }

    .control-btn i {
        font-size: 18px
    }

    #game-ui {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        background: rgba(0, 0, 0, 0.5)
    }

    .ui-panel {
        background: var(--panel);
        border-radius: 10px;
        padding: 20px;
        box-shadow: var(--shadow);
        text-align: center;
        width: 90%;
        max-width: 400px
    }

    .ui-title {
        font-size: 28px;
        margin-bottom: 15px;
        color: var(--primary)
    }

    .ui-text {
        margin-bottom: 15px;
        line-height: 1.4;
        font-size: 14px
    }

    .ui-btn {
        background: var(--secondary);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.2s;
        margin: 5px;
        min-width: 100px
    }

    .ui-btn:hover {
        background: var(--primary)
    }

    #options-btn {
        position: absolute;
        top: 66px;
        right: 10px;
        background: var(--panel);
        border: none;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow);
        z-index: 100
    }

    #options-menu {
        position: absolute;
        top: 50px;
        right: 10px;
        background: var(--panel);
        border-radius: 5px;
        padding: 15px;
        box-shadow: var(--shadow);
        display: none;
        z-index: 150
    }

    .option-item {
        margin-bottom: 10px
    }

    .option-label {
        display: block;
        margin-bottom: 5px;
        font-size: 14px
    }

    @media (min-width: 768px) {
        #preview-area {
            width: 120px;
            flex-direction: column;
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%)
        }

        .preview-block {
            width: 100%;
            margin-bottom: 15px
        }

        #tetris-board {
            max-height: 80vh
        }
    }</style>
</head>
<body>
<audio id="tetris-song" src="sfx/tetris.mp3" type="audio/mp3" loop></audio>
<audio id="tetris-song-b" src="sfx/tetris_b.mp3" type="audio/mp3" loop></audio>
<div id="game-container">
    <div id="header-info">
        <div class="info-block">
            <div class="info-label">SCORE</div>
            <div class="info-value" id="score">0</div>
        </div>
        <div class="info-block">
            <div class="info-label">LEVEL</div>
            <div class="info-value" id="level">0</div>
        </div>
        <div class="info-block">
            <div class="info-label">LINES</div>
            <div class="info-value" id="lines">0</div>
        </div>
        <div class="info-block">
            <div class="info-label">HIGH</div>
            <div class="info-value" id="high-score">0</div>
        </div>
    </div>
    <div id="preview-area">
        <div class="preview-block">
            <div class="preview-label">HOLD</div>
            <canvas id="hold-piece-board"></canvas>
        </div>
        <div class="preview-block">
            <div class="preview-label">NEXT</div>
            <canvas id="next-piece-board"></canvas>
        </div>
    </div>
    <div id="game-area">
        <canvas id="tetris-board"></canvas>
    </div>
    <div id="controls">
        <div class="controls-group">
            <button class="control-btn" id="hold-btn"><i class="fas fa-hand-paper"></i></button>
            <button class="control-btn" id="left-btn"><i class="fas fa-arrow-left"></i></button>
            <button class="control-btn" id="down-btn"><i class="fas fa-arrow-down"></i></button>
            <button class="control-btn" id="right-btn"><i class="fas fa-arrow-right"></i></button>
        </div>
        <div class="controls-group">
            <button class="control-btn" id="rotate-btn"><i class="fas fa-redo"></i></button>
            <button class="control-btn" id="drop-btn"><i class="fas fa-arrow-up"></i></button>
            <button class="control-btn" id="pause-btn"><i class="fas fa-pause"></i></button>
        </div>
    </div>
    <button id="options-btn"><i class="fas fa-cog"></i></button>
    <div id="options-menu">
        <div class="option-item"><label class="option-label" for="volume-slider">Volume</label><input type="range"
                                                                                                      id="volume-slider"
                                                                                                      min="0" max="1"
                                                                                                      step="0.1"
                                                                                                      value="0.5"></div>
        <div class="option-item"><label class="option-label"><input type="checkbox" id="mute-checkbox"> Mute</label>
        </div>
    </div>
    <div id="game-ui">
        <div class="ui-panel" id="start-screen"><h1 class="ui-title">TETRIS</h1>
            <p class="ui-text">Use buttons or keyboard to play:<br>Arrow keys - Move/Rotate<br>Space - Hard drop<br>H -
                Hold piece</p>
            <button class="ui-btn" id="start-btn">Start Game</button>
        </div>
        <div class="ui-panel" id="pause-screen" style="display:none;"><h1 class="ui-title">PAUSED</h1>
            <button class="ui-btn" id="resume-btn">Resume</button>
            <button class="ui-btn" id="restart-btn">Restart</button>
        </div>
        <div class="ui-panel" id="game-over-screen" style="display:none;"><h1 class="ui-title">GAME OVER</h1>
            <p class="ui-text">Score: <span id="final-score">0</span><br>High Score: <span
                    id="final-high-score">0</span></p>
            <button class="ui-btn" id="play-again-btn">Play Again</button>
        </div>
    </div>
</div>
<script>const canvas = document.getElementById('tetris-board');
const ctx = canvas.getContext('2d');
const nextPieceCanvas = document.getElementById('next-piece-board');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const holdPieceCanvas = document.getElementById('hold-piece-board');
const holdPieceCtx = holdPieceCanvas.getContext('2d');
const scoreElement = document.getElementById('score');
const levelElement = document.getElementById('level');
const linesElement = document.getElementById('lines');
const highScoreElement = document.getElementById('high-score');
const finalScoreElement = document.getElementById('final-score');
const finalHighScoreElement = document.getElementById('final-high-score');
const gameUI = document.getElementById('game-ui');
const startScreen = document.getElementById('start-screen');
const pauseScreen = document.getElementById('pause-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const tetrisSong = document.getElementById('tetris-song');
const tetrisSongB = document.getElementById('tetris-song-b');
let isMuted = false;
let volume = 0.5;
const ROW = 20;
const COLUMN = 10;
let BLOCK_SIZE = 30;
let PREVIEW_SIZE = 15;
tetrisSong.volume = volume;
tetrisSongB.volume = volume;

function resizeGame() {
    const gameArea = document.getElementById('game-area');
    const headerHeight = document.getElementById('header-info').offsetHeight;
    const controlsHeight = document.getElementById('controls').offsetHeight;
    const containerPadding = 40;
    const availableHeight = window.innerHeight - headerHeight - controlsHeight - containerPadding;
    const maxGameHeight = Math.min(availableHeight, window.innerHeight * 0.6);
    const availableWidth = Math.min(window.innerWidth - 30, maxGameHeight / 2);
    const minBlockSize = 15;
    const maxBlockHeight = Math.floor(maxGameHeight / ROW);
    const maxBlockWidth = Math.floor(availableWidth / COLUMN);
    BLOCK_SIZE = Math.max(minBlockSize, Math.min(maxBlockWidth, maxBlockHeight));
    canvas.width = COLUMN * BLOCK_SIZE;
    canvas.height = ROW * BLOCK_SIZE;
    PREVIEW_SIZE = Math.max(10, Math.floor(BLOCK_SIZE / 2));
    nextPieceCanvas.width = 4 * PREVIEW_SIZE;
    nextPieceCanvas.height = 4 * PREVIEW_SIZE;
    holdPieceCanvas.width = 4 * PREVIEW_SIZE;
    holdPieceCanvas.height = 4 * PREVIEW_SIZE;
    if (piece) drawBoard();
    drawNextPiece();
    drawHeldPiece()
}

const PIECES = [[[0, 1, 0], [1, 1, 1], [0, 0, 0]], [[0, 0, 1], [1, 1, 1], [0, 0, 0]], [[1, 0, 0], [1, 1, 1], [0, 0, 0]], [[1, 1], [1, 1]], [[0, 1, 1], [1, 1, 0], [0, 0, 0]], [[1, 1, 0], [0, 1, 1], [0, 0, 0]], [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]];
const COLORS = ["#9b59b6", "#f39c12", "#3498db", "#f1c40f", "#2ecc71", "#e74c3c", "#1abc9c"];
let board = [];
let piece, nextPiece;
let heldPiece = null;
let canHold = true;
let score = 0;
let level = 0;
let lines = 0;
let highScore = localStorage.getItem('tetris-high-score') || 0;
let gameLoop;
let gameState = 'start';

function initBoard() {
    board = Array(ROW).fill().map(() => Array(COLUMN).fill(0))
}

function getRandomPiece() {
    const idx = Math.floor(Math.random() * PIECES.length);
    return {
        x: Math.floor(COLUMN / 2) - Math.floor(PIECES[idx][0].length / 2),
        y: 0,
        shape: PIECES[idx],
        color: COLORS[idx],
        index: idx
    }
}

function drawBlock(x, y, color, ctx, size = BLOCK_SIZE) {
    ctx.fillStyle = color;
    ctx.fillRect(x * size, y * size, size, size);
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.strokeRect(x * size, y * size, size, size);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(x * size, y * size, size, size / 4);
    ctx.fillRect(x * size, y * size, size / 4, size)
}

function drawNextPiece() {
    nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    if (!nextPiece) return;
    const shape = nextPiece.shape;
    const offsetX = (nextPieceCanvas.width / PREVIEW_SIZE - shape[0].length) / 2;
    const offsetY = (nextPieceCanvas.height / PREVIEW_SIZE - shape.length) / 2;
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                drawBlock(col + offsetX, row + offsetY, nextPiece.color, nextPieceCtx, PREVIEW_SIZE)
            }
        }
    }
}

function drawHeldPiece() {
    holdPieceCtx.clearRect(0, 0, holdPieceCanvas.width, holdPieceCanvas.height);
    if (heldPiece === null) return;
    const shape = PIECES[heldPiece];
    const offsetX = (holdPieceCanvas.width / PREVIEW_SIZE - shape[0].length) / 2;
    const offsetY = (holdPieceCanvas.height / PREVIEW_SIZE - shape.length) / 2;
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                drawBlock(col + offsetX, row + offsetY, COLORS[heldPiece], holdPieceCtx, PREVIEW_SIZE)
            }
        }
    }
}

function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 0.05;
    for (let row = 0; row < ROW; row++) {
        for (let col = 0; col < COLUMN; col++) {
            ctx.fillStyle = '#000';
            ctx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.strokeRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
        }
    }
    ctx.globalAlpha = 1;
    for (let row = 0; row < ROW; row++) {
        for (let col = 0; col < COLUMN; col++) {
            if (board[row][col]) {
                drawBlock(col, row, COLORS[board[row][col] - 1], ctx)
            }
        }
    }
    if (piece) {
        let ghostY = piece.y;
        while (!isCollision(piece.x, ghostY + 1, piece.shape)) {
            ghostY++
        }
        if (ghostY !== piece.y) {
            ctx.globalAlpha = 0.3;
            const shape = piece.shape;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        drawBlock(piece.x + col, ghostY + row, piece.color, ctx)
                    }
                }
            }
            ctx.globalAlpha = 1
        }
        const shape = piece.shape;
        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col]) {
                    drawBlock(piece.x + col, piece.y + row, piece.color, ctx)
                }
            }
        }
    }
}

function isCollision(x, y, shape) {
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                const boardRow = y + row;
                const boardCol = x + col;
                if (boardCol < 0 || boardCol >= COLUMN || boardRow >= ROW || (boardRow >= 0 && board[boardRow][boardCol])) {
                    return true
                }
            }
        }
    }
    return false
}

function rotatePiece() {
    const oldShape = piece.shape;
    const newShape = [];
    for (let col = 0; col < oldShape[0].length; col++) {
        newShape.push([]);
        for (let row = oldShape.length - 1; row >= 0; row--) {
            newShape[col].push(oldShape[row][col])
        }
    }
    const oldX = piece.x;
    piece.shape = newShape;
    if (isCollision(piece.x, piece.y, piece.shape)) {
        const kickOffsets = [-1, 1, -2, 2];
        let validRotation = false;
        for (const offset of kickOffsets) {
            if (!isCollision(piece.x + offset, piece.y, piece.shape)) {
                piece.x += offset;
                validRotation = true;
                break
            }
        }
        if (!validRotation) {
            piece.shape = oldShape;
            piece.x = oldX;
            return false
        }
    }
    return true
}

function movePiece(direction) {
    if (gameState !== 'playing') return false;
    let moved = false;
    if (direction === 'left') {
        piece.x--;
        if (isCollision(piece.x, piece.y, piece.shape)) {
            piece.x++
        } else {
            moved = true
        }
    } else if (direction === 'right') {
        piece.x++;
        if (isCollision(piece.x, piece.y, piece.shape)) {
            piece.x--
        } else {
            moved = true
        }
    } else if (direction === 'down') {
        piece.y++;
        if (isCollision(piece.x, piece.y, piece.shape)) {
            piece.y--;
            lockPiece()
        } else {
            moved = true
        }
    } else if (direction === 'rotate') {
        moved = rotatePiece()
    } else if (direction === 'drop') {
        while (!isCollision(piece.x, piece.y + 1, piece.shape)) {
            piece.y++;
            score += 2
        }
        updateScore();
        lockPiece();
        moved = true
    }
    if (moved) {
        drawBoard()
    }
    return moved
}

function lockPiece() {
    const shape = piece.shape;
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                const boardRow = piece.y + row;
                const boardCol = piece.x + col;
                if (boardRow < 0) {
                    gameOver();
                    return
                }
                board[boardRow][boardCol] = piece.index + 1
            }
        }
    }
    clearLines();
    piece = nextPiece;
    nextPiece = getRandomPiece();
    drawNextPiece();
    canHold = true;
    if (isCollision(piece.x, piece.y, piece.shape)) {
        gameOver()
    }
}

function clearLines() {
    let linesCleared = 0;
    for (let row = ROW - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
            for (let col = 0; col < COLUMN; col++) {
                ctx.fillStyle = 'white';
                ctx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
            }
            board.splice(row, 1);
            board.unshift(Array(COLUMN).fill(0));
            row++;
            linesCleared++
        }
    }
    if (linesCleared > 0) {
        const scoreMultiplier = [0, 40, 100, 300, 1200];
        score += scoreMultiplier[linesCleared] * (level + 1);
        lines += linesCleared;
        level = Math.floor(lines / 10);
        updateScore();
        updateGameSpeed()
    }
}

function holdPiece() {
    if (!canHold || gameState !== 'playing') return;
    if (heldPiece === null) {
        heldPiece = piece.index;
        piece = nextPiece;
        nextPiece = getRandomPiece();
        drawNextPiece()
    } else {
        const temp = piece.index;
        piece = {
            x: Math.floor(COLUMN / 2) - Math.floor(PIECES[heldPiece][0].length / 2),
            y: 0,
            shape: PIECES[heldPiece],
            color: COLORS[heldPiece],
            index: heldPiece
        };
        heldPiece = temp
    }
    canHold = false;
    drawHeldPiece();
    drawBoard()
}

function updateScore() {
    scoreElement.textContent = score;
    levelElement.textContent = level;
    linesElement.textContent = lines;
    if (score > highScore) {
        highScore = score;
        highScoreElement.textContent = highScore;
        localStorage.setItem('tetris-high-score', highScore)
    }
}

function updateGameSpeed() {
    clearInterval(gameLoop);
    const baseSpeed = 1000;
    const speed = Math.max(baseSpeed - (level * 50), 100);
    startGameLoop(speed);
    if (level >= 10 && !isMuted) {
        tetrisSong.pause();
        tetrisSongB.play()
    }
}

function gameOver() {
    gameState = 'over';
    clearInterval(gameLoop);
    finalScoreElement.textContent = score;
    finalHighScoreElement.textContent = highScore;
    gameUI.style.display = 'flex';
    pauseScreen.style.display = 'none';
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'block';
    tetrisSong.pause();
    tetrisSongB.pause()
}

function startGame() {
    initBoard();
    score = 0;
    level = 0;
    lines = 0;
    heldPiece = null;
    canHold = true;
    gameState = 'playing';
    updateScore();
    highScoreElement.textContent = highScore;
    gameUI.style.display = 'none';
    piece = getRandomPiece();
    nextPiece = getRandomPiece();
    drawBoard();
    drawNextPiece();
    drawHeldPiece();
    updateGameSpeed();
    if (!isMuted) {
        tetrisSong.currentTime = 0;
        tetrisSongB.currentTime = 0;
        tetrisSong.volume = volume;
        tetrisSongB.volume = volume;
        tetrisSong.play()
    }
}

function pauseGame() {
    if (gameState === 'playing') {
        gameState = 'paused';
        clearInterval(gameLoop);
        gameUI.style.display = 'flex';
        pauseScreen.style.display = 'block';
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        tetrisSong.pause();
        tetrisSongB.pause()
    } else if (gameState === 'paused') {
        resumeGame()
    }
}

function resumeGame() {
    if (gameState === 'paused') {
        gameState = 'playing';
        updateGameSpeed();
        gameUI.style.display = 'none';
        if (!isMuted) {
            if (level >= 10) {
                tetrisSongB.play()
            } else {
                tetrisSong.play()
            }
        }
    }
}

function startGameLoop(speed) {
    gameLoop = setInterval(() => {
        movePiece('down')
    }, speed)
}

window.addEventListener('load', () => {
    highScoreElement.textContent = highScore;
    initBoard();
    resizeGame();
    drawBoard();
    const volumeSlider = document.getElementById('volume-slider');
    volumeSlider.value = volume;
    tetrisSong.volume = volume;
    tetrisSongB.volume = volume
});
window.addEventListener('resize', resizeGame);
window.addEventListener('orientationchange', function () {
    setTimeout(resizeGame, 100)
});
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') {
        movePiece('left')
    } else if (e.key === 'ArrowRight' || e.key === 'd') {
        movePiece('right')
    } else if (e.key === 'ArrowDown' || e.key === 's') {
        movePiece('down')
    } else if (e.key === 'ArrowUp' || e.key === 'w') {
        movePiece('rotate')
    } else if (e.key === ' ') {
        movePiece('drop')
    } else if (e.key === 'h' || e.key === 'c') {
        holdPiece()
    } else if (e.key === 'p' || e.key === 'Escape') {
        if (gameState === 'playing' || gameState === 'paused') {
            pauseGame()
        }
    }
});
document.getElementById('left-btn').addEventListener('click', () => movePiece('left'));
document.getElementById('right-btn').addEventListener('click', () => movePiece('right'));
document.getElementById('down-btn').addEventListener('click', () => movePiece('down'));
document.getElementById('rotate-btn').addEventListener('click', () => movePiece('rotate'));
document.getElementById('drop-btn').addEventListener('click', () => movePiece('drop'));
document.getElementById('hold-btn').addEventListener('click', () => holdPiece());
document.getElementById('pause-btn').addEventListener('click', () => pauseGame());
document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('contextmenu', e => e.preventDefault());
    btn.addEventListener('touchstart', e => e.preventDefault())
});
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('resume-btn').addEventListener('click', resumeGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('play-again-btn').addEventListener('click', startGame);
const optionsBtn = document.getElementById('options-btn');
const optionsMenu = document.getElementById('options-menu');
const volumeSlider = document.getElementById('volume-slider');
const muteCheckbox = document.getElementById('mute-checkbox');
optionsBtn.addEventListener('click', () => {
    optionsMenu.style.display = optionsMenu.style.display === 'block' ? 'none' : 'block'
});
volumeSlider.addEventListener('input', (e) => {
    volume = parseFloat(e.target.value);
    tetrisSong.volume = volume;
    tetrisSongB.volume = volume
});
muteCheckbox.addEventListener('change', (e) => {
    isMuted = e.target.checked;
    if (isMuted) {
        tetrisSong.pause();
        tetrisSongB.pause()
    } else if (gameState === 'playing') {
        if (level >= 10) {
            tetrisSongB.play()
        } else {
            tetrisSong.play()
        }
    }
});
document.addEventListener('click', (e) => {
    if (!optionsMenu.contains(e.target) && e.target !== optionsBtn) {
        optionsMenu.style.display = 'none'
    }
});
window.addEventListener('keydown', (e) => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].indexOf(e.key) > -1) {
        e.preventDefault()
    }
});</script>
</body>
</html>