<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Ball Pool Game Online - Free Billiards Game | GPT Games</title>
    <meta name="description"
          content="Play 8-Ball Pool online for free! Realistic physics, smooth controls, and classic billiards gameplay. Challenge yourself in this browser-based pool game with no downloads required.">
    <meta name="keywords"
          content="8-ball pool, pool game, billiards, online pool, free pool game, browser game, HTML5 game, snooker, cue sports">
    <meta name="author" content="Claude 4.1 Opus prompted by Tobias MÃ¼ller">
    <link rel="canonical" href="https://gptgames.dev/games/8-ball.html">
    <meta property="og:title" content="8-Ball Pool - Free Online Billiards Game">
    <meta property="og:description"
          content="Play the classic 8-Ball Pool game online with realistic physics and smooth controls. No download needed!">
    <meta property="og:image" content="https://gptgames.dev/screenshots/screenshot_215.webp">
    <meta property="og:url" content="https://gptgames.dev/games/8-ball.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="8-Ball Pool - Free Online Game">
    <meta name="twitter:description" content="Enjoy classic 8-ball pool with realistic physics in your browser!">
    <meta name="twitter:image" content="https://gptgames.dev/screenshots/screenshot_215.webp">
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "VideoGame",
            "name": "8-Ball Pool Online",
            "description": "Free online 8-ball pool game with realistic physics and smooth gameplay",
            "url": "https://gptgames.dev/games/8-ball.html",
            "image": "https://gptgames.dev/screenshots/screenshot_215.webp",
            "genre": "Sports",
            "gamePlatform": "Web Browser",
            "operatingSystem": "Any",
            "playMode": "SinglePlayer",
            "applicationCategory": "Game"
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            background: #0a0a0a;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        #ui {
            color: white;
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .player-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            position: relative;
            min-width: 140px;
        }

        .player-info.active {
            background: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
            }
            50% {
                box-shadow: 0 0 30px rgba(76, 175, 80, 0.8);
            }
        }

        .ball-group {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 10px;
            vertical-align: middle;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .solid {
            background: linear-gradient(135deg, #ff6b6b, #c92a2a);
        }

        .stripe {
            background: repeating-linear-gradient(45deg, #4dabf7, #4dabf7 5px, white 5px, white 10px);
        }

        .ball-count {
            display: block;
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.8;
        }

        #powerMeter {
            width: 200px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #powerBar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #ffeb3b, #ff5722);
            width: 0%;
            transition: width 0.1s;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #message {
            text-align: center;
            color: #ffd43b;
            font-size: 18px;
            min-height: 30px;
            margin-top: 10px;
            font-weight: 500;
        }

        button {
            background: #4a5568;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            background: #5a6578;
        }

        button:active {
            transform: translateY(0);
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }

        #instructions h3 {
            margin-bottom: 10px;
            color: #ffd43b;
        }

        #instructions p {
            margin: 5px 0;
            font-size: 14px;
        }

        .turn-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 10px;
            height: 10px;
            background: #4caf50;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }
    </style>
</head>
<body>
<div id="instructions">
    <h3>ðŸŽ± How to Play</h3>
    <p>â€¢ Click and drag to aim</p>
    <p>â€¢ Pull back for power</p>
    <p>â€¢ Release to shoot</p>
    <p>â€¢ Pocket your group (solids/stripes)</p>
    <p>â€¢ Pocket 8-ball last to win</p>
    <p>â€¢ Avoid scratching the cue ball!</p>
</div>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div class="player-info" id="player1">
            Player 1 <span class="ball-group" id="p1Group"></span>
            <span class="ball-count" id="p1Count"></span>
            <div class="turn-indicator" id="p1Turn" style="display: none;"></div>
        </div>
        <div id="powerMeter">
            <div id="powerBar"></div>
        </div>
        <div class="player-info" id="player2">
            Player 2 <span class="ball-group" id="p2Group"></span>
            <span class="ball-count" id="p2Count"></span>
            <div class="turn-indicator" id="p2Turn" style="display: none;"></div>
        </div>
    </div>
    <div id="message">Break to start!</div>
    <div style="text-align: center; margin-top: 10px;">
        <button onclick="resetGame()">New Game</button>
    </div>
</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 900;
    canvas.height = 450;

    const Engine = Matter.Engine,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Body = Matter.Body,
        Events = Matter.Events,
        Vector = Matter.Vector;

    const engine = Engine.create();
    engine.world.gravity.y = 0;
    engine.timing.timeScale = 1;

    const BALL_RADIUS = 12;
    const TABLE_WIDTH = canvas.width - 100;
    const TABLE_HEIGHT = canvas.height - 50;
    const TABLE_X = 50;
    const TABLE_Y = 25;
    const POCKET_RADIUS = 25;
    const MAX_POWER = 20;

    let gameState = {
        currentPlayer: 1,
        player1Group: null,
        player2Group: null,
        ballsMoving: false,
        gameOver: false,
        firstHit: null,
        pocketedThisTurn: [],
        validShot: false,
        breakShot: true,
        consecutiveFouls: {1: 0, 2: 0}
    };

    let mousePos = {x: 0, y: 0};
    let isDragging = false;
    let dragStart = {x: 0, y: 0};
    let shotPower = 0;

    const balls = [];
    let cueBall;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(frequency, duration, type = 'sine', volume = 0.1) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }

    function createTable() {
        const walls = [
            Bodies.rectangle(canvas.width / 2, 10, TABLE_WIDTH, 20, {isStatic: true, label: 'wall'}),
            Bodies.rectangle(canvas.width / 2, canvas.height - 10, TABLE_WIDTH, 20, {isStatic: true, label: 'wall'}),
            Bodies.rectangle(40, canvas.height / 2, 20, TABLE_HEIGHT, {isStatic: true, label: 'wall'}),
            Bodies.rectangle(canvas.width - 40, canvas.height / 2, 20, TABLE_HEIGHT, {isStatic: true, label: 'wall'})
        ];

        const pockets = [
            Bodies.circle(TABLE_X, TABLE_Y, POCKET_RADIUS, {isStatic: true, isSensor: true, label: 'pocket'}),
            Bodies.circle(canvas.width / 2, TABLE_Y - 5, POCKET_RADIUS, {
                isStatic: true,
                isSensor: true,
                label: 'pocket'
            }),
            Bodies.circle(TABLE_X + TABLE_WIDTH, TABLE_Y, POCKET_RADIUS, {
                isStatic: true,
                isSensor: true,
                label: 'pocket'
            }),
            Bodies.circle(TABLE_X, TABLE_Y + TABLE_HEIGHT, POCKET_RADIUS, {
                isStatic: true,
                isSensor: true,
                label: 'pocket'
            }),
            Bodies.circle(canvas.width / 2, TABLE_Y + TABLE_HEIGHT + 5, POCKET_RADIUS, {
                isStatic: true,
                isSensor: true,
                label: 'pocket'
            }),
            Bodies.circle(TABLE_X + TABLE_WIDTH, TABLE_Y + TABLE_HEIGHT, POCKET_RADIUS, {
                isStatic: true,
                isSensor: true,
                label: 'pocket'
            })
        ];

        World.add(engine.world, [...walls, ...pockets]);
    }

    function createBalls() {
        balls.length = 0;
        World.clear(engine.world);
        Engine.clear(engine);

        createTable();

        cueBall = Bodies.circle(250, canvas.height / 2, BALL_RADIUS, {
            restitution: 0.95,
            friction: 0.005,
            frictionAir: 0.008,
            density: 0.001,
            label: 'cueBall',
            render: {fillStyle: '#ffffff'}
        });
        balls.push(cueBall);

        const ballConfig = [
            {num: 1, color: '#FFD700', type: 'solid'},
            {num: 2, color: '#0066CC', type: 'solid'},
            {num: 3, color: '#FF0000', type: 'solid'},
            {num: 4, color: '#800080', type: 'solid'},
            {num: 5, color: '#FF6600', type: 'solid'},
            {num: 6, color: '#006600', type: 'solid'},
            {num: 7, color: '#8B4513', type: 'solid'},
            {num: 8, color: '#000000', type: '8ball'},
            {num: 9, color: '#FFD700', type: 'stripe'},
            {num: 10, color: '#0066CC', type: 'stripe'},
            {num: 11, color: '#FF0000', type: 'stripe'},
            {num: 12, color: '#800080', type: 'stripe'},
            {num: 13, color: '#FF6600', type: 'stripe'},
            {num: 14, color: '#006600', type: 'stripe'},
            {num: 15, color: '#8B4513', type: 'stripe'}
        ];

        const startX = 600;
        const startY = canvas.height / 2;
        const spacing = BALL_RADIUS * 2.1;
        let row = 0, col = 0;

        for (let i = 0; i < 5; i++) {
            for (let j = 0; j <= i; j++) {
                const index = row + j;
                if (index < ballConfig.length) {
                    const x = startX + i * spacing * 0.866;
                    const y = startY + (j - i / 2) * spacing;

                    const ball = Bodies.circle(x, y, BALL_RADIUS, {
                        restitution: 0.95,
                        friction: 0.005,
                        frictionAir: 0.008,
                        density: 0.001,
                        label: `ball-${ballConfig[index].num}`,
                        ballNumber: ballConfig[index].num,
                        ballType: ballConfig[index].type,
                        render: {fillStyle: ballConfig[index].color}
                    });
                    balls.push(ball);
                }
            }
            row += i + 1;
        }

        World.add(engine.world, balls);
    }

    function drawTable() {
        ctx.fillStyle = '#0d5016';
        ctx.fillRect(TABLE_X, TABLE_Y, TABLE_WIDTH, TABLE_HEIGHT);

        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 10;
        ctx.strokeRect(TABLE_X - 5, TABLE_Y - 5, TABLE_WIDTH + 10, TABLE_HEIGHT + 10);

        const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, 400);
        gradient.addColorStop(0, 'rgba(255,255,255,0.02)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
        ctx.fillStyle = gradient;
        ctx.fillRect(TABLE_X, TABLE_Y, TABLE_WIDTH, TABLE_HEIGHT);

        const pocketPositions = [
            [TABLE_X, TABLE_Y],
            [canvas.width / 2, TABLE_Y],
            [TABLE_X + TABLE_WIDTH, TABLE_Y],
            [TABLE_X, TABLE_Y + TABLE_HEIGHT],
            [canvas.width / 2, TABLE_Y + TABLE_HEIGHT],
            [TABLE_X + TABLE_WIDTH, TABLE_Y + TABLE_HEIGHT]
        ];

        pocketPositions.forEach(pos => {
            const pocketGradient = ctx.createRadialGradient(pos[0], pos[1], 0, pos[0], pos[1], POCKET_RADIUS);
            pocketGradient.addColorStop(0, '#000000');
            pocketGradient.addColorStop(0.7, '#1a1a1a');
            pocketGradient.addColorStop(1, '#333333');
            ctx.fillStyle = pocketGradient;
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], POCKET_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
    }

    function drawBalls() {
        balls.forEach(ball => {
            if (!ball.isSleeping && ball.position.x > 0) {
                ctx.save();
                ctx.translate(ball.position.x, ball.position.y);

                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                if (ball.label === 'cueBall') {
                    const gradient = ctx.createRadialGradient(-3, -3, 0, 0, 0, BALL_RADIUS);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.7, '#f0f0f0');
                    gradient.addColorStop(1, '#d0d0d0');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, BALL_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    const gradient = ctx.createRadialGradient(-3, -3, 0, 0, 0, BALL_RADIUS);
                    const color = ball.render.fillStyle;
                    gradient.addColorStop(0, lightenColor(color, 40));
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, darkenColor(color, 30));
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, BALL_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    if (ball.ballType === 'stripe') {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(0, 0, BALL_RADIUS, 0, Math.PI * 2);
                        ctx.clip();

                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-BALL_RADIUS, -BALL_RADIUS / 2, BALL_RADIUS * 2, BALL_RADIUS);

                        const stripeGradient = ctx.createLinearGradient(0, -BALL_RADIUS / 3, 0, BALL_RADIUS / 3);
                        stripeGradient.addColorStop(0, lightenColor(color, 20));
                        stripeGradient.addColorStop(0.5, color);
                        stripeGradient.addColorStop(1, lightenColor(color, 20));
                        ctx.fillStyle = stripeGradient;
                        ctx.fillRect(-BALL_RADIUS, -BALL_RADIUS / 3, BALL_RADIUS * 2, BALL_RADIUS * 2 / 3);
                        ctx.restore();
                    }

                    const circleGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, BALL_RADIUS / 2);
                    circleGradient.addColorStop(0, '#ffffff');
                    circleGradient.addColorStop(0.8, '#f5f5f5');
                    circleGradient.addColorStop(1, '#e0e0e0');
                    ctx.fillStyle = circleGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, BALL_RADIUS / 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'transparent';
                    ctx.fillText(ball.ballNumber, 0, 0);
                }

                ctx.shadowColor = 'transparent';
                const highlight = ctx.createRadialGradient(-4, -4, 0, -4, -4, 6);
                highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
                highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.arc(-4, -4, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        });
    }

    function lightenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    function darkenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return "#" + (0x1000000 + (R > 0 ? R : 0) * 0x10000 + (G > 0 ? G : 0) * 0x100 + (B > 0 ? B : 0)).toString(16).slice(1);
    }

    function drawCue() {
        if (!isDragging || gameState.ballsMoving) return;

        const dx = mousePos.x - cueBall.position.x;
        const dy = mousePos.y - cueBall.position.y;
        const angle = Math.atan2(dy, dx);
        const distance = Math.min(Math.sqrt(dx * dx + dy * dy), 150);

        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.setLineDash([10, 10]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cueBall.position.x, cueBall.position.y);
        ctx.lineTo(cueBall.position.x + Math.cos(angle) * 250, cueBall.position.y + Math.sin(angle) * 250);
        ctx.stroke();
        ctx.setLineDash([]);

        const ghostBallX = cueBall.position.x + Math.cos(angle) * 50;
        const ghostBallY = cueBall.position.y + Math.sin(angle) * 50;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(ghostBallX, ghostBallY, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        const cueDistance = 30 + shotPower * 3;
        const cueX = cueBall.position.x - Math.cos(angle) * cueDistance;
        const cueY = cueBall.position.y - Math.sin(angle) * cueDistance;

        const cueGradient = ctx.createLinearGradient(cueX, cueY, cueX - Math.cos(angle) * 200, cueY - Math.sin(angle) * 200);
        cueGradient.addColorStop(0, '#8B4513');
        cueGradient.addColorStop(0.5, '#654321');
        cueGradient.addColorStop(1, '#4B0000');

        ctx.strokeStyle = cueGradient;
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(cueX, cueY);
        ctx.lineTo(cueX - Math.cos(angle) * 200, cueY - Math.sin(angle) * 200);
        ctx.stroke();

        ctx.strokeStyle = '#2B0000';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(cueX, cueY);
        ctx.lineTo(cueX - Math.cos(angle) * 200, cueY - Math.sin(angle) * 200);
        ctx.stroke();

        ctx.restore();
    }

    function checkBallsMoving() {
        return balls.some(ball => {
            const speed = Math.sqrt(ball.velocity.x ** 2 + ball.velocity.y ** 2);
            return speed > 0.1;
        });
    }

    function shoot() {
        if (shotPower > 0 && !gameState.ballsMoving) {
            const dx = mousePos.x - cueBall.position.x;
            const dy = mousePos.y - cueBall.position.y;
            const angle = Math.atan2(dy, dx);

            const force = Math.min(shotPower / 10, MAX_POWER) * 0.012;
            Body.applyForce(cueBall, cueBall.position, {
                x: Math.cos(angle) * force,
                y: Math.sin(angle) * force
            });

            playSound(150 + shotPower * 10, 0.1, 'triangle', 0.15);
            gameState.ballsMoving = true;
            gameState.firstHit = null;
            gameState.pocketedThisTurn = [];
            gameState.validShot = false;
        }
    }

    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(pair => {
            const {bodyA, bodyB} = pair;

            if ((bodyA.label.includes('ball') && bodyB.label.includes('ball')) ||
                (bodyA.label === 'cueBall' && bodyB.label.includes('ball')) ||
                (bodyB.label === 'cueBall' && bodyA.label.includes('ball'))) {
                const speed = Math.sqrt(pair.collision.tangent.x ** 2 + pair.collision.tangent.y ** 2);
                playSound(600 + speed * 100, 0.05, 'sine', Math.min(0.2, speed * 0.05));

                if (!gameState.firstHit && (bodyA.label === 'cueBall' || bodyB.label === 'cueBall')) {
                    const otherBall = bodyA.label === 'cueBall' ? bodyB : bodyA;
                    if (otherBall.label !== 'cueBall') {
                        gameState.firstHit = otherBall;
                    }
                }
            }

            if (bodyA.label === 'pocket' || bodyB.label === 'pocket') {
                const ball = bodyA.label === 'pocket' ? bodyB : bodyA;
                if (ball.label.includes('ball') || ball.label === 'cueBall') {
                    handlePocket(ball);
                    playSound(300, 0.3, 'sawtooth', 0.2);
                }
            }
        });
    });

    function handlePocket(ball) {
        if (ball.label === 'cueBall') {
            setTimeout(() => {
                Body.setPosition(ball, {x: 250, y: canvas.height / 2});
                Body.setVelocity(ball, {x: 0, y: 0});
            }, 500);
            gameState.validShot = false;
            document.getElementById('message').textContent = 'âŒ Scratch! Other player\'s turn';
        } else if (ball.label === 'ball-8') {
            const playerGroup = gameState[`player${gameState.currentPlayer}Group`];
            if (playerGroup && !hasBallsRemaining(gameState.currentPlayer)) {
                gameState.gameOver = true;
                document.getElementById('message').textContent = `ðŸŽ‰ Player ${gameState.currentPlayer} Wins!`;
                playSound(800, 0.5, 'square', 0.3);
            } else {
                gameState.gameOver = true;
                document.getElementById('message').textContent = `ðŸ’€ Player ${gameState.currentPlayer === 1 ? 2 : 1} Wins!`;
                playSound(200, 0.5, 'sawtooth', 0.3);
            }
            World.remove(engine.world, ball);
        } else {
            const ballType = ball.ballType;
            gameState.pocketedThisTurn.push(ballType);

            if (!gameState.player1Group && !gameState.player2Group && !gameState.breakShot) {
                gameState.player1Group = gameState.currentPlayer === 1 ? ballType : (ballType === 'solid' ? 'stripe' : 'solid');
                gameState.player2Group = gameState.player1Group === 'solid' ? 'stripe' : 'solid';
                updateGroupDisplay();
            }

            if (gameState[`player${gameState.currentPlayer}Group`] === ballType) {
                gameState.validShot = true;
                document.getElementById('message').textContent = 'âœ… Nice shot! Continue playing';
            }

            World.remove(engine.world, ball);
            balls.splice(balls.indexOf(ball), 1);
        }
        updateBallCount();
    }

    function hasBallsRemaining(player) {
        const group = gameState[`player${player}Group`];
        return balls.some(ball => ball.ballType === group);
    }

    function updateBallCount() {
        if (gameState.player1Group) {
            const p1Balls = balls.filter(b => b.ballType === gameState.player1Group).length;
            const p2Balls = balls.filter(b => b.ballType === gameState.player2Group).length;
            document.getElementById('p1Count').textContent = `${p1Balls} balls left`;
            document.getElementById('p2Count').textContent = `${p2Balls} balls left`;
        }
    }

    function endTurn() {
        if (gameState.gameOver) return;

        gameState.breakShot = false;

        if (!gameState.validShot && gameState.pocketedThisTurn.length === 0) {
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            document.getElementById('message').textContent = `Player ${gameState.currentPlayer}'s turn`;
        } else if (gameState.validShot) {
            document.getElementById('message').textContent = `Player ${gameState.currentPlayer} continues`;
        } else {
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            document.getElementById('message').textContent = `Player ${gameState.currentPlayer}'s turn`;
        }

        updatePlayerDisplay();
        gameState.ballsMoving = false;
    }

    function updateGroupDisplay() {
        document.getElementById('p1Group').className = `ball-group ${gameState.player1Group}`;
        document.getElementById('p2Group').className = `ball-group ${gameState.player2Group}`;
        updateBallCount();
    }

    function updatePlayerDisplay() {
        document.getElementById('player1').classList.toggle('active', gameState.currentPlayer === 1);
        document.getElementById('player2').classList.toggle('active', gameState.currentPlayer === 2);
        document.getElementById('p1Turn').style.display = gameState.currentPlayer === 1 ? 'block' : 'none';
        document.getElementById('p2Turn').style.display = gameState.currentPlayer === 2 ? 'block' : 'none';
    }

    canvas.addEventListener('mousedown', (e) => {
        if (gameState.ballsMoving || gameState.gameOver) return;
        const rect = canvas.getBoundingClientRect();
        dragStart.x = e.clientX - rect.left;
        dragStart.y = e.clientY - rect.top;
        isDragging = true;
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;

        if (isDragging && !gameState.ballsMoving) {
            const dx = dragStart.x - mousePos.x;
            const dy = dragStart.y - mousePos.y;
            shotPower = Math.min(Math.sqrt(dx * dx + dy * dy) / 8, MAX_POWER);
            document.getElementById('powerBar').style.width = (shotPower / MAX_POWER * 100) + '%';
        }
    });

    function handleMouseUp() {
        if (isDragging && !gameState.ballsMoving && !gameState.gameOver) {
            shoot();
            isDragging = false;
            shotPower = 0;
            document.getElementById('powerBar').style.width = '0%';
        }
    }

    canvas.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('mouseup', handleMouseUp);

    canvas.addEventListener('mouseleave', (e) => {
        if (isDragging) {
            handleMouseUp();
        }
    });

    function gameLoop() {
        Engine.update(engine, 1000 / 60);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTable();
        drawBalls();
        drawCue();

        if (gameState.ballsMoving && !checkBallsMoving()) {
            endTurn();
        }

        requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        gameState = {
            currentPlayer: 1,
            player1Group: null,
            player2Group: null,
            ballsMoving: false,
            gameOver: false,
            firstHit: null,
            pocketedThisTurn: [],
            validShot: false,
            breakShot: true,
            consecutiveFouls: {1: 0, 2: 0}
        };

        document.getElementById('message').textContent = 'Break to start!';
        document.getElementById('p1Group').className = 'ball-group';
        document.getElementById('p2Group').className = 'ball-group';
        document.getElementById('p1Count').textContent = '';
        document.getElementById('p2Count').textContent = '';

        createBalls();
        updatePlayerDisplay();
    }

    createBalls();
    updatePlayerDisplay();
    gameLoop();
</script>
<script src="../logo.js"></script>
</body>
</html>