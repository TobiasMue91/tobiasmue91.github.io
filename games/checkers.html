<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>">
    <title>Professional Checkers Game - Play Online Free | GPTGames.dev</title>
    <meta name="description" content="Play checkers online free. Professional checkers game with smooth animations, move history, and sound effects. Challenge a friend in this classic strategy board game.">
    <meta name="keywords" content="checkers game, online checkers, play checkers, draughts, board game, strategy game">
    <meta property="og:title" content="Professional Checkers Game - Play Online Free">
    <meta property="og:description" content="Play checkers online free with smooth animations and professional features. Challenge a friend now!">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_59.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/checkers.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.47/vue.global.min.js" integrity="sha512-DJ2+sosWB5FnZAIeCWAHu2gxQ7Gi438oOZLcBQSOrW8gD0s7LIXDv/5RW76B3FcljF40BXnfqNIo6Dhp7dFHJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;background:#2c3e50;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px;color:#1f2937}
        #app{width:100%;max-width:1200px}
        .game-container{display:grid;grid-template-columns:1fr auto 1fr;gap:30px;align-items:start}
        @media (max-width:1024px){.game-container{grid-template-columns:1fr;justify-items:center}}
        .header{text-align:center;margin-bottom:30px}
        .header h1{font-size:3rem;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,.3);margin-bottom:10px}
        .header p{color:rgba(255,255,255,.9);font-size:1.1rem}
        .card{background:#fff;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.2);padding:24px}
        .info-panel{min-width:280px}
        .board-container{display:inline-block}
        .checkerboard{display:inline-block;border:4px solid #2c3e50;border-radius:12px;box-shadow:0 15px 50px rgba(0,0,0,.4);padding:8px;background:#34495e;position:relative}
        .row{display:flex}
        .square{width:60px;height:60px;display:flex;align-items:center;justify-content:center;position:relative;transition:background .2s}
        .square.light{background:#f5f5dc}
        .square.dark{background:#8b4513}
        .square.valid-move::after{content:'';position:absolute;width:20px;height:20px;border-radius:50%;background:rgba(34,197,94,.5);border:2px solid rgba(34,197,94,.8);animation:pulse 1.5s infinite}
        .square.last-move{background:#fbbf24!important}
        @keyframes pulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.2);opacity:.7}}
        .piece{width:50px;height:50px;border-radius:50%;cursor:pointer;transition:all .25s cubic-bezier(.4,0,.2,1);position:relative;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 6px rgba(0,0,0,.3)}
        .piece.red{background:#dc2626;border:3px solid #991b1b}
        .piece.black{background:#1f2937;border:3px solid #000}
        .piece:hover{transform:scale(1.1) translateY(-3px);box-shadow:0 8px 12px rgba(0,0,0,.4)}
        .piece.selected{box-shadow:0 0 0 4px #fbbf24,0 8px 16px rgba(0,0,0,.4);transform:scale(1.15)}
        .piece.king::before{content:'‚ôö';font-size:32px;color:#ffd700;text-shadow:0 2px 4px rgba(0,0,0,.5)}
        .turn-display{text-align:center;padding:20px;background:#3b82f6;border-radius:12px;color:#fff;margin-bottom:20px}
        .turn-display.ai-thinking{background:#f59e0b;animation:thinking-pulse 1.5s infinite}
        @keyframes thinking-pulse{0%,100%{opacity:1}50%{opacity:.7}}
        .turn-display h2{font-size:1.5rem;margin-bottom:8px}
        .turn-display .status{font-size:1.1rem;opacity:.95}
        .stats{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px}
        .stat-box{background:#f3f4f6;padding:16px;border-radius:10px;text-align:center}
        .stat-box .label{font-size:.875rem;color:#6b7280;margin-bottom:4px;text-transform:uppercase;letter-spacing:.5px}
        .stat-box .value{font-size:2rem;font-weight:700;color:#1f2937}
        .stat-box.red .value{color:#dc2626}
        .stat-box.black .value{color:#1f2937}
        .controls{display:flex;flex-direction:column;gap:12px}
        .btn{padding:12px 20px;border:none;border-radius:8px;font-size:1rem;font-weight:600;cursor:pointer;transition:all .2s;text-align:center;box-shadow:0 2px 4px rgba(0,0,0,.1)}
        .btn:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.2)}
        .btn:active{transform:translateY(0)}
        .btn-primary{background:#3b82f6;color:#fff}
        .btn-primary:hover{background:#2563eb}
        .btn-secondary{background:#6b7280;color:#fff}
        .btn-secondary:hover{background:#4b5563}
        .btn-success{background:#22c55e;color:#fff}
        .btn-success:hover{background:#16a34a}
        .btn-danger{background:#ef4444;color:#fff}
        .btn-danger:hover{background:#dc2626}
        .btn:disabled{opacity:.5;cursor:not-allowed;transform:none!important}
        .move-history{margin-top:20px}
        .move-history h3{font-size:1.1rem;margin-bottom:12px;color:#1f2937}
        .move-list{max-height:200px;overflow-y:auto;background:#f9fafb;border-radius:8px;padding:12px}
        .move-item{padding:8px;margin-bottom:4px;background:#fff;border-radius:6px;font-family:monospace;font-size:.9rem;display:flex;justify-content:space-between;align-items:center}
        .move-item .move-number{color:#6b7280;font-weight:600}
        .move-item .move-notation{color:#1f2937}
        .settings{margin-top:20px;padding:16px;background:#f3f4f6;border-radius:12px}
        .settings h3{font-size:1.1rem;margin-bottom:12px;color:#1f2937}
        .setting-item{display:flex;align-items:center;justify-content:space-between;padding:8px 0}
        .setting-item label{font-size:.95rem;color:#4b5563}
        .toggle{position:relative;display:inline-block;width:50px;height:26px}
        .toggle input{opacity:0;width:0;height:0}
        .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#cbd5e1;border-radius:26px;transition:.3s}
        .slider:before{position:absolute;content:"";height:20px;width:20px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:.3s}
        input:checked+.slider{background:#3b82f6}
        input:checked+.slider:before{transform:translateX(24px)}
        .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:1000}
        .modal-content{background:#fff;padding:40px;border-radius:20px;text-align:center;max-width:500px;box-shadow:0 20px 60px rgba(0,0,0,.3)}
        .modal-content h2{font-size:2.5rem;margin-bottom:16px;color:#1f2937}
        .modal-content .winner{font-size:1.5rem;color:#3b82f6;margin-bottom:24px}
        .modal-content .final-stats{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:24px;text-align:left}
        .modal-content .stat{padding:12px;background:#f9fafb;border-radius:8px}
        .modal-content .stat-label{font-size:.875rem;color:#6b7280;margin-bottom:4px}
        .modal-content .stat-value{font-size:1.5rem;font-weight:700;color:#1f2937}
        .setup-modal .modal-content{max-width:400px}
        .mode-selector{display:flex;flex-direction:column;gap:12px;margin-bottom:24px}
        .mode-btn{padding:16px;border:3px solid #e5e7eb;border-radius:12px;background:#fff;cursor:pointer;transition:all .2s;font-size:1.1rem;font-weight:600}
        .mode-btn:hover{border-color:#3b82f6;background:#eff6ff}
        .mode-btn.selected{border-color:#3b82f6;background:#3b82f6;color:#fff}
        .difficulty-selector{margin-top:20px}
        .difficulty-selector h3{font-size:1.2rem;margin-bottom:12px;color:#1f2937}
        .difficulty-buttons{display:flex;gap:8px}
        .difficulty-btn{flex:1;padding:12px;border:2px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer;transition:all .2s;font-size:.95rem;font-weight:600}
        .difficulty-btn:hover{border-color:#3b82f6}
        .difficulty-btn.selected{border-color:#3b82f6;background:#3b82f6;color:#fff}
        .color-selector{margin-top:20px}
        .color-selector h3{font-size:1.2rem;margin-bottom:12px;color:#1f2937}
        .color-buttons{display:flex;gap:12px}
        .color-btn{flex:1;padding:16px;border:2px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer;transition:all .2s;font-weight:600;display:flex;align-items:center;justify-content:center;gap:8px}
        .color-btn:hover{border-color:#3b82f6}
        .color-btn.selected{border-color:#3b82f6;background:#eff6ff}
        @media (max-width:768px){
            .square{width:45px;height:45px}
            .piece{width:38px;height:38px}
            .piece.king::before{font-size:24px}
            .header h1{font-size:2rem}
            .info-panel{width:100%}
        }
    </style>
</head>
<body>
<div id="app">
    <div class="header">
        <h1>üéØ Professional Checkers</h1>
        <p>Challenge your opponent in this classic strategy game</p>
    </div>
    <div class="game-container">
        <div class="info-panel card">
            <div class="turn-display" :class="{'ai-thinking':aiThinking}">
                <h2 v-if="!gameOver">{{player==='black'?'‚ö´':'üî¥'}} {{player==='black'?'Black':'Red'}}'s Turn</h2>
                <div class="status" v-if="!gameOver&&!aiThinking">Move {{moveCount}}</div>
                <div class="status" v-if="aiThinking">ü§ñ AI Thinking...</div>
            </div>
            <div class="stats">
                <div class="stat-box red">
                    <div class="label">Red Captured</div>
                    <div class="value">{{blackScore}}</div>
                </div>
                <div class="stat-box black">
                    <div class="label">Black Captured</div>
                    <div class="value">{{redScore}}</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-secondary" @click="undoMove" :disabled="!canUndo||gameMode==='ai'">‚Ü∂ Undo Move</button>
                <button class="btn btn-primary" @click="showSetup">üîÑ New Game</button>
            </div>
            <div class="move-history">
                <h3>üìã Move History</h3>
                <div class="move-list">
                    <div v-for="(move,idx) in moveHistory.slice(-10).reverse()" :key="idx" class="move-item">
                        <span class="move-number">#{{moveHistory.length-idx}}</span>
                        <span class="move-notation">{{move}}</span>
                    </div>
                    <div v-if="moveHistory.length===0" style="text-align:center;color:#9ca3af;padding:20px">No moves yet</div>
                </div>
            </div>
            <div class="settings">
                <h3>‚öôÔ∏è Settings</h3>
                <div class="setting-item">
                    <label>Sound Effects</label>
                    <label class="toggle"><input type="checkbox" v-model="soundEnabled"><span class="slider"></span></label>
                </div>
                <div class="setting-item" v-if="gameMode==='ai'">
                    <label>Game Mode</label>
                    <span style="font-size:.85rem;color:#6b7280">vs AI ({{aiDifficulty}})</span>
                </div>
            </div>
        </div>
        <div class="board-container card">
            <div class="checkerboard">
                <div class="row" v-for="(row,rowIndex) in grid" :key="rowIndex">
                    <div class="square" :class="[getSquareClass(rowIndex,colIndex),{'valid-move':isValidMove(rowIndex,colIndex)&&!aiThinking,'last-move':isLastMove(rowIndex,colIndex)}]" v-for="(square,colIndex) in row" :key="colIndex" @click="handleSquareClick(rowIndex,colIndex)">
                        <div v-if="square" class="piece" :class="getPieceClass(square,rowIndex,colIndex)"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="info-panel card">
            <div style="text-align:center;padding:20px">
                <h3 style="margin-bottom:16px">üéÆ How to Play</h3>
                <p style="color:#6b7280;line-height:1.6;text-align:left">‚Ä¢ Click a piece to select it<br>‚Ä¢ Valid moves will be highlighted<br>‚Ä¢ Click a highlighted square to move<br>‚Ä¢ Jump over opponents to capture<br>‚Ä¢ Reach the opposite end to become a king<br>‚Ä¢ Kings can move backwards<br>‚Ä¢ Capture all opponent pieces to win!</p>
            </div>
        </div>
    </div>
    <div v-if="setupModal" class="modal-overlay setup-modal" @click.self="setupModal=false">
        <div class="modal-content">
            <h2>üéÆ Game Setup</h2>
            <div class="mode-selector">
                <button class="mode-btn" :class="{selected:selectedMode==='pvp'}" @click="selectedMode='pvp'">üë• Player vs Player</button>
                <button class="mode-btn" :class="{selected:selectedMode==='ai'}" @click="selectedMode='ai'">ü§ñ Player vs AI</button>
            </div>
            <div v-if="selectedMode==='ai'" class="difficulty-selector">
                <h3>Difficulty</h3>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" :class="{selected:selectedDifficulty==='easy'}" @click="selectedDifficulty='easy'">Easy</button>
                    <button class="difficulty-btn" :class="{selected:selectedDifficulty==='medium'}" @click="selectedDifficulty='medium'">Medium</button>
                    <button class="difficulty-btn" :class="{selected:selectedDifficulty==='hard'}" @click="selectedDifficulty='hard'">Hard</button>
                </div>
            </div>
            <div v-if="selectedMode==='ai'" class="color-selector">
                <h3>Play As</h3>
                <div class="color-buttons">
                    <button class="color-btn" :class="{selected:selectedColor==='black'}" @click="selectedColor='black'">‚ö´ Black (First)</button>
                    <button class="color-btn" :class="{selected:selectedColor==='red'}" @click="selectedColor='red'">üî¥ Red (Second)</button>
                </div>
            </div>
            <button class="btn btn-success" @click="startGame" style="margin-top:24px;width:100%">Start Game</button>
        </div>
    </div>
    <div v-if="gameOver" class="modal-overlay" @click.self="gameOver=false">
        <div class="modal-content">
            <h2>üéâ Game Over!</h2>
            <div class="winner">{{winner}} Wins!</div>
            <div class="final-stats">
                <div class="stat">
                    <div class="stat-label">Total Moves</div>
                    <div class="stat-value">{{moveCount}}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Captures</div>
                    <div class="stat-value">{{redScore+blackScore}}</div>
                </div>
            </div>
            <button class="btn btn-success" @click="showSetup">Play Again</button>
        </div>
    </div>
</div>
<script>
    const {createApp}=Vue;
    createApp({
        data(){
            return{
                player:'black',
                redScore:0,
                blackScore:0,
                moveCount:0,
                grid:this.createInitialGrid(),
                selectedPiece:null,
                possibleMoves:[],
                gameOver:false,
                winner:'',
                soundEnabled:true,
                audioContext:null,
                moveHistory:[],
                lastMove:null,
                previousState:null,
                canUndo:false,
                gameMode:'pvp',
                aiDifficulty:'medium',
                aiPlayer:'red',
                aiThinking:false,
                setupModal:true,
                selectedMode:'pvp',
                selectedDifficulty:'medium',
                selectedColor:'black'
            }
        },
        computed:{
            currentPlayerPieces(){
                return this.grid.flatMap((row,rowIndex)=>row.reduce((pieces,piece,colIndex)=>{
                    if(piece&&piece.startsWith(this.player)){
                        pieces.push({type:piece,row:rowIndex,col:colIndex})
                    }
                    return pieces
                },[]))
            }
        },
        methods:{
            createInitialGrid(){
                return[['red',null,'red',null,'red',null,'red',null],[null,'red',null,'red',null,'red',null,'red'],['red',null,'red',null,'red',null,'red',null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,'black',null,'black',null,'black',null,'black'],['black',null,'black',null,'black',null,'black',null],[null,'black',null,'black',null,'black',null,'black']]
            },
            initAudio(){
                if(!this.audioContext){
                    this.audioContext=new(window.AudioContext||window.webkitAudioContext)()
                }
            },
            playSound(type){
                if(!this.soundEnabled)return;
                this.initAudio();
                const ctx=this.audioContext;
                const osc=ctx.createOscillator();
                const gain=ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                const now=ctx.currentTime;
                switch(type){
                    case'move':
                        osc.frequency.value=400;
                        gain.gain.setValueAtTime(.1,now);
                        gain.gain.exponentialRampToValueAtTime(.01,now+.1);
                        osc.start(now);
                        osc.stop(now+.1);
                        break;
                    case'capture':
                        osc.frequency.value=300;
                        gain.gain.setValueAtTime(.15,now);
                        gain.gain.exponentialRampToValueAtTime(.01,now+.15);
                        osc.start(now);
                        osc.stop(now+.15);
                        break;
                    case'king':
                        osc.frequency.value=600;
                        gain.gain.setValueAtTime(.12,now);
                        gain.gain.exponentialRampToValueAtTime(.01,now+.2);
                        osc.start(now);
                        osc.stop(now+.2);
                        break;
                    case'gameover':
                        osc.frequency.value=500;
                        gain.gain.setValueAtTime(.15,now);
                        gain.gain.exponentialRampToValueAtTime(.01,now+.3);
                        osc.start(now);
                        osc.stop(now+.3);
                        break
                }
            },
            showSetup(){
                this.setupModal=true;
                this.gameOver=false
            },
            startGame(){
                this.gameMode=this.selectedMode;
                this.aiDifficulty=this.selectedDifficulty;
                this.aiPlayer=this.selectedColor==='black'?'red':'black';
                this.setupModal=false;
                this.reset();
                if(this.gameMode==='ai'&&this.player===this.aiPlayer){
                    setTimeout(()=>this.makeAIMove(),800)
                }
            },
            getSquareClass(row,col){
                return(row+col)%2===0?'light':'dark'
            },
            getPieceClass(piece,row,col){
                const classes=[piece.includes('red')?'red':'black'];
                if(piece.endsWith('K'))classes.push('king');
                if(this.selectedPiece&&this.selectedPiece.row===row&&this.selectedPiece.col===col)classes.push('selected');
                return classes.join(' ')
            },
            isValidMove(row,col){
                return this.possibleMoves.some(m=>m[2]===row&&m[3]===col)
            },
            isLastMove(row,col){
                if(!this.lastMove)return false;
                return(this.lastMove.from.row===row&&this.lastMove.from.col===col)||(this.lastMove.to.row===row&&this.lastMove.to.col===col)
            },
            handleSquareClick(row,col){
                if(this.aiThinking)return;
                if(this.gameMode==='ai'&&this.player===this.aiPlayer)return;
                if(this.selectedPiece){
                    const move=this.possibleMoves.find(m=>m[0]===this.selectedPiece.row&&m[1]===this.selectedPiece.col&&m[2]===row&&m[3]===col);
                    if(move){
                        this.makeMove(row,col)
                    }else{
                        this.selectPiece(row,col)
                    }
                }else{
                    this.selectPiece(row,col)
                }
            },
            makeMove(row,col){
                if(this.gameMode!=='ai'){
                    this.saveState()
                }
                const notation=this.getNotation(this.selectedPiece.row,this.selectedPiece.col,row,col);
                this.grid[row][col]=this.selectedPiece.type;
                this.grid[this.selectedPiece.row][this.selectedPiece.col]=null;
                this.lastMove={from:{row:this.selectedPiece.row,col:this.selectedPiece.col},to:{row,col}};
                const wasKing=this.selectedPiece.type.endsWith('K');
                this.promoteToKing(row,col);
                const isNowKing=this.grid[row][col].endsWith('K');
                const captured=this.checkForCaptures(row,col);
                if(captured){
                    this.playSound('capture');
                    const captureRow=Math.floor((row+this.selectedPiece.row)/2);
                    const captureCol=Math.floor((col+this.selectedPiece.col)/2);
                    this.grid[captureRow][captureCol]=null;
                    this.possibleMoves=this.findPossibleMoves(row,col);
                    const hasMoreCaptures=this.possibleMoves.some(m=>Math.abs(m[2]-row)===2);
                    if(hasMoreCaptures){
                        this.selectedPiece={type:this.grid[row][col],row,col};
                        return
                    }
                }else{
                    this.playSound('move')
                }
                if(!wasKing&&isNowKing){
                    this.playSound('king')
                }
                this.moveHistory.push(notation);
                this.moveCount++;
                this.switchTurns();
                this.checkGameOver();
                if(!this.gameOver&&this.gameMode==='ai'&&this.player===this.aiPlayer){
                    setTimeout(()=>this.makeAIMove(),600)
                }
            },
            saveState(){
                this.previousState={
                    grid:this.grid.map(row=>[...row]),
                    player:this.player,
                    redScore:this.redScore,
                    blackScore:this.blackScore,
                    moveCount:this.moveCount,
                    moveHistory:[...this.moveHistory],
                    lastMove:this.lastMove?{...this.lastMove}:null
                };
                this.canUndo=true
            },
            undoMove(){
                if(!this.previousState)return;
                this.grid=this.previousState.grid;
                this.player=this.previousState.player;
                this.redScore=this.previousState.redScore;
                this.blackScore=this.previousState.blackScore;
                this.moveCount=this.previousState.moveCount;
                this.moveHistory=this.previousState.moveHistory;
                this.lastMove=this.previousState.lastMove;
                this.selectedPiece=null;
                this.possibleMoves=[];
                this.previousState=null;
                this.canUndo=false;
                this.playSound('move')
            },
            getNotation(fromRow,fromCol,toRow,toCol){
                const from=this.getSquareNumber(fromRow,fromCol);
                const to=this.getSquareNumber(toRow,toCol);
                const isCapture=Math.abs(toRow-fromRow)===2;
                return`${from}${isCapture?'x':'-'}${to}`
            },
            getSquareNumber(row,col){
                const darkSquaresPerRow=4;
                const darkSquareInRow=Math.floor(col/2)+1;
                return(row*darkSquaresPerRow)+darkSquareInRow
            },
            selectPiece(row,col){
                const piece=this.grid[row][col];
                if(piece&&piece.startsWith(this.player)){
                    this.selectedPiece={type:piece,row,col};
                    this.possibleMoves=this.findPossibleMoves(row,col)
                }else{
                    this.selectedPiece=null;
                    this.possibleMoves=[]
                }
            },
            findPossibleMoves(row,col){
                const moves=[];
                const captures=[];
                const isKing=this.grid[row][col].endsWith('K');
                const directions=isKing?[-1,1]:this.player==='red'?[1]:[-1];
                for(const rowDir of directions){
                    for(const colDir of[-1,1]){
                        const newRow=row+rowDir;
                        const newCol=col+colDir;
                        if(this.isInBounds(newRow,newCol)&&!this.grid[newRow][newCol]){
                            moves.push([row,col,newRow,newCol])
                        }else{
                            const captureRow=newRow+rowDir;
                            const captureCol=newCol+colDir;
                            if(this.isInBounds(captureRow,captureCol)&&this.grid[newRow][newCol]&&this.grid[newRow][newCol].startsWith(this.opponent())&&!this.grid[captureRow][captureCol]){
                                captures.push([row,col,captureRow,captureCol])
                            }
                        }
                    }
                }
                return captures.length>0?captures:moves
            },
            checkForCaptures(row,col){
                const rowDiff=row-this.selectedPiece.row;
                const colDiff=col-this.selectedPiece.col;
                if(Math.abs(rowDiff)===2&&Math.abs(colDiff)===2){
                    const capturedRow=this.selectedPiece.row+rowDiff/2;
                    const capturedCol=this.selectedPiece.col+colDiff/2;
                    const capturedPiece=this.grid[capturedRow][capturedCol];
                    if(capturedPiece){
                        if(capturedPiece.startsWith('red')){
                            this.redScore++
                        }else{
                            this.blackScore++
                        }
                        return capturedPiece
                    }
                }
                return null
            },
            switchTurns(){
                this.selectedPiece=null;
                this.possibleMoves=[];
                this.player=this.player==='red'?'black':'red'
            },
            isInBounds(row,col){
                return row>=0&&row<8&&col>=0&&col<8
            },
            opponent(){
                return this.player==='red'?'black':'red'
            },
            promoteToKing(row,col){
                if((this.player==='red'&&row===7)||(this.player==='black'&&row===0)){
                    if(!this.grid[row][col].endsWith('K')){
                        this.grid[row][col]+='K'
                    }
                }
            },
            checkGameOver(){
                if(this.currentPlayerPieces.length===0){
                    this.gameOver=true;
                    this.winner=this.opponent()==='red'?'Red':'Black';
                    this.playSound('gameover')
                }
            },
            reset(){
                Object.assign(this.$data,{
                    player:'black',
                    redScore:0,
                    blackScore:0,
                    moveCount:0,
                    grid:this.createInitialGrid(),
                    selectedPiece:null,
                    possibleMoves:[],
                    gameOver:false,
                    winner:'',
                    moveHistory:[],
                    lastMove:null,
                    previousState:null,
                    canUndo:false,
                    aiThinking:false,
                    gameMode:this.gameMode,
                    aiDifficulty:this.aiDifficulty,
                    aiPlayer:this.aiPlayer,
                    setupModal:false,
                    soundEnabled:this.soundEnabled,
                    selectedMode:this.selectedMode,
                    selectedDifficulty:this.selectedDifficulty,
                    selectedColor:this.selectedColor
                })
            },
            makeAIMove(){
                this.aiThinking=true;
                setTimeout(()=>{
                    const move=this.getAIMove();
                    if(move){
                        this.selectedPiece={type:this.grid[move[0]][move[1]],row:move[0],col:move[1]};
                        this.possibleMoves=this.findPossibleMoves(move[0],move[1]);
                        setTimeout(()=>{
                            this.makeMove(move[2],move[3]);
                            this.aiThinking=false
                        },300)
                    }else{
                        this.aiThinking=false
                    }
                },400)
            },
            getAIMove(){
                const allMoves=this.getAllPossibleMovesForPlayer(this.player);
                if(allMoves.length===0)return null;
                if(this.aiDifficulty==='easy'){
                    return allMoves[Math.floor(Math.random()*allMoves.length)]
                }else if(this.aiDifficulty==='medium'){
                    return this.getMediumMove(allMoves)
                }else{
                    return this.getHardMove()
                }
            },
            getAllPossibleMovesForPlayer(player){
                const moves=[];
                const captures=[];
                this.grid.forEach((row,rowIndex)=>{
                    row.forEach((piece,colIndex)=>{
                        if(piece&&piece.startsWith(player)){
                            const pieceMoves=this.findPossibleMoves(rowIndex,colIndex);
                            pieceMoves.forEach(move=>{
                                if(Math.abs(move[2]-move[0])===2){
                                    captures.push(move)
                                }else{
                                    moves.push(move)
                                }
                            })
                        }
                    })
                });
                return captures.length>0?captures:moves
            },
            getMediumMove(allMoves){
                const captures=allMoves.filter(m=>Math.abs(m[2]-m[0])===2);
                if(captures.length>0){
                    return captures[Math.floor(Math.random()*captures.length)]
                }
                let bestMove=null;
                let bestScore=-Infinity;
                allMoves.forEach(move=>{
                    let score=0;
                    const piece=this.grid[move[0]][move[1]];
                    const isKing=piece.endsWith('K');
                    if(isKing){
                        score+=5
                    }
                    const toRow=move[2];
                    if(this.player==='red'&&toRow===7){
                        score+=15
                    }else if(this.player==='black'&&toRow===0){
                        score+=15
                    }
                    const centerDist=Math.abs(3.5-move[3])+Math.abs(3.5-move[2]);
                    score+=10-centerDist;
                    if(this.player==='red'){
                        score+=move[2]-move[0]
                    }else{
                        score+=move[0]-move[2]
                    }
                    score+=Math.random()*3;
                    if(score>bestScore){
                        bestScore=score;
                        bestMove=move
                    }
                });
                return bestMove
            },
            getHardMove(){
                let bestMove=null;
                let bestScore=-Infinity;
                const alpha=-Infinity;
                const beta=Infinity;
                const allMoves=this.getAllPossibleMovesForPlayer(this.player);
                allMoves.forEach(move=>{
                    const tempGrid=this.grid.map(row=>[...row]);
                    const captured=this.simulateMove(move,tempGrid);
                    const score=this.minimax(tempGrid,4,false,alpha,beta,captured);
                    if(score>bestScore){
                        bestScore=score;
                        bestMove=move
                    }
                });
                return bestMove||allMoves[0]
            },
            simulateMove(move,grid){
                let captured=false;
                grid[move[2]][move[3]]=grid[move[0]][move[1]];
                grid[move[0]][move[1]]=null;
                if(Math.abs(move[2]-move[0])===2){
                    const captureRow=Math.floor((move[0]+move[2])/2);
                    const captureCol=Math.floor((move[1]+move[3])/2);
                    grid[captureRow][captureCol]=null;
                    captured=true
                }
                if((this.player==='red'&&move[2]===7&&!grid[move[2]][move[3]].endsWith('K'))||(this.player==='black'&&move[2]===0&&!grid[move[2]][move[3]].endsWith('K'))){
                    grid[move[2]][move[3]]+='K'
                }
                return captured
            },
            minimax(grid,depth,isMaximizing,alpha,beta,lastWasCapture){
                if(depth===0){
                    return this.evaluateBoard(grid)
                }
                const player=isMaximizing?this.aiPlayer:this.opponent();
                const moves=this.getAllMovesForPlayerOnGrid(grid,player);
                if(moves.length===0){
                    return isMaximizing?-10000:10000
                }
                if(isMaximizing){
                    let maxScore=-Infinity;
                    for(const move of moves){
                        const tempGrid=grid.map(row=>[...row]);
                        const captured=this.simulateMoveForPlayer(move,tempGrid,player);
                        const score=this.minimax(tempGrid,depth-1,false,alpha,beta,captured);
                        maxScore=Math.max(maxScore,score);
                        alpha=Math.max(alpha,score);
                        if(beta<=alpha)break
                    }
                    return maxScore
                }else{
                    let minScore=Infinity;
                    for(const move of moves){
                        const tempGrid=grid.map(row=>[...row]);
                        const captured=this.simulateMoveForPlayer(move,tempGrid,player);
                        const score=this.minimax(tempGrid,depth-1,true,alpha,beta,captured);
                        minScore=Math.min(minScore,score);
                        beta=Math.min(beta,score);
                        if(beta<=alpha)break
                    }
                    return minScore
                }
            },
            getAllMovesForPlayerOnGrid(grid,player){
                const moves=[];
                const captures=[];
                grid.forEach((row,rowIndex)=>{
                    row.forEach((piece,colIndex)=>{
                        if(piece&&piece.startsWith(player)){
                            const pieceMoves=this.findPossibleMovesOnGrid(grid,rowIndex,colIndex,player);
                            pieceMoves.forEach(move=>{
                                if(Math.abs(move[2]-move[0])===2){
                                    captures.push(move)
                                }else{
                                    moves.push(move)
                                }
                            })
                        }
                    })
                });
                return captures.length>0?captures:moves
            },
            findPossibleMovesOnGrid(grid,row,col,player){
                const moves=[];
                const captures=[];
                const piece=grid[row][col];
                const isKing=piece.endsWith('K');
                const directions=isKing?[-1,1]:player==='red'?[1]:[-1];
                const opponent=player==='red'?'black':'red';
                for(const rowDir of directions){
                    for(const colDir of[-1,1]){
                        const newRow=row+rowDir;
                        const newCol=col+colDir;
                        if(this.isInBounds(newRow,newCol)&&!grid[newRow][newCol]){
                            moves.push([row,col,newRow,newCol])
                        }else{
                            const captureRow=newRow+rowDir;
                            const captureCol=newCol+colDir;
                            if(this.isInBounds(captureRow,captureCol)&&grid[newRow][newCol]&&grid[newRow][newCol].startsWith(opponent)&&!grid[captureRow][captureCol]){
                                captures.push([row,col,captureRow,captureCol])
                            }
                        }
                    }
                }
                return captures.length>0?captures:moves
            },
            simulateMoveForPlayer(move,grid,player){
                let captured=false;
                grid[move[2]][move[3]]=grid[move[0]][move[1]];
                grid[move[0]][move[1]]=null;
                if(Math.abs(move[2]-move[0])===2){
                    const captureRow=Math.floor((move[0]+move[2])/2);
                    const captureCol=Math.floor((move[1]+move[3])/2);
                    grid[captureRow][captureCol]=null;
                    captured=true
                }
                if((player==='red'&&move[2]===7&&!grid[move[2]][move[3]].endsWith('K'))||(player==='black'&&move[2]===0&&!grid[move[2]][move[3]].endsWith('K'))){
                    grid[move[2]][move[3]]+='K'
                }
                return captured
            },
            evaluateBoard(grid){
                let score=0;
                const aiPlayer=this.aiPlayer;
                const opponent=this.opponent();
                grid.forEach((row,rowIndex)=>{
                    row.forEach((piece,colIndex)=>{
                        if(!piece)return;
                        const isAI=piece.startsWith(aiPlayer);
                        const isKing=piece.endsWith('K');
                        const pieceValue=isKing?30:10;
                        const multiplier=isAI?1:-1;
                        score+=pieceValue*multiplier;
                        if(!isKing){
                            if(aiPlayer==='red'){
                                score+=(isAI?rowIndex:(7-rowIndex))*multiplier*0.5
                            }else{
                                score+=(isAI?(7-rowIndex):rowIndex)*multiplier*0.5
                            }
                        }
                        const centerDist=Math.abs(3.5-colIndex)+Math.abs(3.5-rowIndex);
                        score+=(7-centerDist)*0.3*multiplier;
                        if((aiPlayer==='red'&&isAI&&rowIndex===7)||(aiPlayer==='black'&&isAI&&rowIndex===0)){
                            score+=20
                        }
                        if((aiPlayer==='red'&&!isAI&&rowIndex===0)||(aiPlayer==='black'&&!isAI&&rowIndex===7)){
                            score-=20
                        }
                    })
                });
                return score
            }
        }
    }).mount('#app');
</script>
<script src="../logo.js"></script>
</body>
</html>