<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta name="keywords"
          content="nonogram, picross, griddlers, logic puzzle, picture puzzle, brain game, puzzle game, online game, free game">
    <meta name="author" content="Claude Sonnet 4.5 prompted by Tobias MÃ¼ller">
    <meta property="og:title" content="Nonogram - Logic Puzzle Game">
    <meta property="og:description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_228.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/nonogram.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Nonogram - Logic Puzzle Game">
    <meta name="twitter:description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_228.webp">
    <link rel="canonical" href="https://www.gptgames.dev/games/nonogram.html">
    <title>Nonogram Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game {
            max-width: 900px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.8em;
            color: #4ecdc4;
            margin-bottom: 5px;
            font-weight: 300;
            letter-spacing: 3px;
        }

        .subtitle {
            color: #7a7a7a;
            font-size: 0.95em;
            margin-bottom: 20px;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            outline: none;
        }

        .btn-primary {
            background: #4ecdc4;
            color: #0a0e27;
        }

        .btn-primary:hover {
            background: #45b8b0;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary {
            background: #2d3561;
            color: #4ecdc4;
            border: 2px solid #4ecdc4;
        }

        .btn-secondary:hover {
            background: #3d4575;
        }

        .btn:active {
            transform: translateY(0);
        }

        .difficulty {
            display: flex;
            gap: 8px;
            background: #16213e;
            padding: 4px;
            border-radius: 6px;
        }

        .difficulty button {
            background: transparent;
            color: #7a7a7a;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .difficulty button.active {
            background: #4ecdc4;
            color: #0a0e27;
        }

        .game-area {
            background: #16213e;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        .puzzle-container {
            display: inline-block;
            position: relative;
        }

        .grid-container {
            display: grid;
            gap: 0;
            position: relative;
        }

        .col-clues {
            display: grid;
            margin-bottom: 8px;
            gap: 1px;
        }

        .col-clue {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 4px 2px;
            font-size: 0.7em;
            color: #4ecdc4;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .col-clue div {
            padding: 1px 0;
        }

        .row-container {
            display: flex;
            align-items: center;
        }

        .row-clue {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 4px 8px;
            gap: 4px;
            font-size: 0.7em;
            color: #4ecdc4;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            min-width: 70px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: #0f3460;
            padding: 1px;
            border-radius: 4px;
        }

        .cell {
            background: #1a2744;
            cursor: crosshair;
            border: 1px solid #0f3460;
            transition: all 0.1s;
            position: relative;
            user-select: none;
        }

        .cell:hover {
            background: #243251;
            border-color: #4ecdc4;
        }

        .cell.filled {
            background: #4ecdc4;
        }

        .cell.marked {
            background: #1a2744;
        }

        .cell.marked::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 2px solid #ff6b6b;
            border-radius: 2px;
        }

        .cell.marked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            transform: translate(-50%, -50%) rotate(-45deg);
            border: 2px solid #ff6b6b;
            border-radius: 2px;
        }

        .cell.highlight {
            background: #2d4a6f;
        }

        .cell.error-flash {
            animation: errorFlash 0.4s;
        }

        @keyframes errorFlash {
            0%, 100% {
                background: #1a2744;
            }
            50% {
                background: #ff6b6b;
            }
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #16213e;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7a7a7a;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            color: #4ecdc4;
            font-weight: 600;
        }

        .instructions {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #4ecdc4;
        }

        .instructions h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .instructions p {
            color: #a0a0a0;
            line-height: 1.6;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .instructions strong {
            color: #e0e0e0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(78, 205, 196, 0.3);
            animation: modalSlide 0.3s;
            max-width: 500px;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal h2 {
            color: #4ecdc4;
            font-size: 2.5em;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .modal .emoji-big {
            font-size: 6em;
            margin: 20px 0;
            animation: emojiSpin 0.6s;
        }

        @keyframes emojiSpin {
            from {
                transform: scale(0) rotate(-180deg);
            }
            to {
                transform: scale(1) rotate(0);
            }
        }

        .modal p {
            color: #a0a0a0;
            font-size: 1.1em;
            margin-bottom: 30px;
        }

        .modal .time {
            color: #4ecdc4;
            font-size: 1.5em;
            font-weight: 600;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            background: #16213e;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .mode-selector label {
            color: #a0a0a0;
            font-size: 0.85em;
            margin-right: 5px;
        }

        .mode-btn {
            background: #2d3561;
            color: #a0a0a0;
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: #4ecdc4;
            color: #0a0e27;
            font-weight: 600;
        }

        .generation-status {
            text-align: center;
            color: #4ecdc4;
            font-size: 0.9em;
            margin-top: 10px;
            min-height: 20px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            .game-area {
                padding: 15px;
            }

            .modal-content {
                padding: 30px;
            }
        }
    </style>
</head>
<body>
<div class="game">
    <div class="header">
        <h1>NONOGRAM</h1>
        <p class="subtitle">Solve the logic puzzle by filling the grid</p>
    </div>
    <div class="toolbar">
        <button class="btn btn-primary" id="newGame">New Game</button>
        <div class="difficulty">
            <button class="diff-btn" data-size="10">Easy</button>
            <button class="diff-btn active" data-size="15">Medium</button>
            <button class="diff-btn" data-size="20">Hard</button>
        </div>
        <button class="btn btn-secondary" id="checkBtn">Validate</button>
        <button class="btn btn-secondary" id="hintBtn">Hint</button>
    </div>
    <div class="mode-selector">
        <label>Draw Mode:</label>
        <button class="mode-btn active" data-mode="fill">Fill</button>
        <button class="mode-btn" data-mode="mark">Mark X</button>
    </div>
    <div class="generation-status" id="genStatus"></div>
    <div class="game-area">
        <div style="display:flex;justify-content:center;">
            <div class="puzzle-container" id="puzzleContainer"></div>
        </div>
    </div>
    <div class="stats">
        <div class="stat-box">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="timer">00:00</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Progress</div>
            <div class="stat-value" id="progress">0%</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Errors</div>
            <div class="stat-value" id="errors">0</div>
        </div>
    </div>
    <div class="instructions">
        <h3>ðŸ“– How to Play</h3>
        <p><strong>Goal:</strong> Fill cells to reveal a hidden picture using number clues.</p>
        <p><strong>Controls:</strong> Click or drag to fill cells. Switch modes to mark cells with X (cells you know are
            empty).</p>
        <p><strong>Clues:</strong> Numbers show consecutive filled cells in each row/column. Multiple numbers mean
            separate groups with at least one empty cell between them.</p>
        <p><strong>Example:</strong> "3 1 2" means: 3 filled, gap, 1 filled, gap, 2 filled.</p>
        <p><strong>Guaranteed:</strong> Every puzzle is verified to be logically solvable without guessing!</p>
    </div>
</div>
<div class="modal" id="winModal">
    <div class="modal-content">
        <h2>ðŸŽ‰ Solved!</h2>
        <div class="emoji-big" id="solvedEmoji"></div>
        <p>Completed in <span class="time" id="finalTime"></span></p>
        <button class="btn btn-primary" id="playAgain">Play Again</button>
    </div>
</div>
<script>
    const EMOJI_POOL = ['ðŸŽ®', 'ðŸŽ¯', 'ðŸŽ¨', 'ðŸŽ­', 'ðŸŽª', 'ðŸŽ¸', 'ðŸŽ¹', 'ðŸŽº', 'ðŸŽ»', 'ðŸŽ²', 'ðŸŽ°', 'ðŸŽ³', 'ðŸ€', 'âš½', 'ðŸˆ', 'âš¾', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸŽ±', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥Š', 'ðŸ¥‹', 'â›³', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¥…', 'â›·ï¸', 'ðŸ‚', 'ðŸ„', 'ðŸš´', 'ðŸŠ', 'ðŸ¤¸', 'ðŸ§—', 'ðŸ¤º', 'ðŸ‡', 'â›¹ï¸', 'ðŸ‹ï¸', 'ðŸ¤¾', 'ðŸš£', 'ðŸŒ', 'ðŸ§˜', 'ðŸƒ', 'ðŸš¶', 'ðŸ’ƒ', 'ðŸ•º', 'ðŸ¤³', 'ðŸ’ª', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ‘‹', 'ðŸ¤', 'ðŸ‘', 'ðŸ‘Š', 'âœŠ', 'ðŸ¤›', 'ðŸ¤œ', 'ðŸ‘Œ', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ‘‡', 'â˜ï¸', 'âœ‹', 'ðŸ¤š', 'ðŸ–ï¸', 'ðŸ––', 'ðŸ‘‹', 'ðŸ¤™', 'ðŸ’…', 'ðŸ¦¾', 'ðŸ¦¿', 'ðŸ¦µ', 'ðŸ¦¶', 'ðŸ‘‚', 'ðŸ¦»', 'ðŸ‘ƒ', 'ðŸ§ ', 'ðŸ¦·', 'ðŸ¦´', 'ðŸ‘€', 'ðŸ‘ï¸', 'ðŸ‘…', 'ðŸ‘„', 'ðŸ‘‹', 'ðŸ©¸', 'ðŸŽ‚', 'ðŸ°', 'ðŸ§', 'ðŸª', 'ðŸ©', 'ðŸ«', 'ðŸ¬', 'ðŸ­', 'ðŸ®', 'ðŸ¯', 'ðŸ¼', 'ðŸ¥›', 'â˜•', 'ðŸµ', 'ðŸ¶', 'ðŸ¾', 'ðŸ·', 'ðŸ¸', 'ðŸ¹', 'ðŸº', 'ðŸ»', 'ðŸ¥‚', 'ðŸ¥ƒ', 'ðŸ¥¤', 'ðŸ§ƒ', 'ðŸ§‰', 'ðŸ§Š', 'ðŸ¥¢', 'ðŸ´', 'ðŸ¥„', 'ðŸ”ª', 'ðŸº', 'ðŸŒ', 'ðŸŒŽ', 'ðŸŒ', 'ðŸŒ', 'ðŸ—ºï¸', 'ðŸ—¾', 'ðŸ§­', 'ðŸ”ï¸', 'â›°ï¸', 'ðŸŒ‹', 'ðŸ—»', 'ðŸ•ï¸', 'ðŸ–ï¸', 'ðŸœï¸', 'ðŸï¸', 'ðŸžï¸', 'ðŸŸï¸', 'ðŸ›ï¸', 'ðŸ—ï¸', 'ðŸ§±', 'ðŸ˜ï¸', 'ðŸšï¸', 'ðŸ ', 'ðŸ¡', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸ©', 'ðŸª', 'ðŸ«', 'ðŸ¬', 'ðŸ­', 'ðŸ¯', 'ðŸ°', 'ðŸ—¼', 'ðŸ—½', 'â›ª', 'ðŸ•Œ', 'ðŸ›•', 'ðŸ•', 'â›©ï¸', 'ðŸ•‹', 'â›²', 'â›º', 'ðŸŒ', 'ðŸŒƒ', 'ðŸ™ï¸', 'ðŸŒ„', 'ðŸŒ…', 'ðŸŒ†', 'ðŸŒ‡', 'ðŸŒ‰', 'â™¨ï¸', 'ðŸŽ ', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸ’ˆ', 'ðŸŽª', 'ðŸš‚', 'ðŸšƒ', 'ðŸš„', 'ðŸš…', 'ðŸš†', 'ðŸš‡', 'ðŸšˆ', 'ðŸš‰', 'ðŸšŠ', 'ðŸš', 'ðŸšž', 'ðŸš‹', 'ðŸšŒ', 'ðŸš', 'ðŸšŽ', 'ðŸš', 'ðŸš‘', 'ðŸš’', 'ðŸš“', 'ðŸš”', 'ðŸš•', 'ðŸš–', 'ðŸš—', 'ðŸš˜', 'ðŸš™', 'ðŸšš', 'ðŸš›', 'ðŸšœ', 'ðŸŽï¸', 'ðŸï¸', 'ðŸ›µ', 'ðŸ¦½', 'ðŸ¦¼', 'ðŸ›º', 'ðŸš²', 'ðŸ›´', 'ðŸ›¹', 'ðŸš', 'ðŸ›£ï¸', 'ðŸ›¤ï¸', 'ðŸ›¢ï¸', 'â›½', 'ðŸš¨', 'ðŸš¥', 'ðŸš¦', 'ðŸ›‘', 'ðŸš§', 'âš“', 'â›µ', 'ðŸ›¶', 'ðŸš¤', 'ðŸ›³ï¸', 'â›´ï¸', 'ðŸ›¥ï¸', 'ðŸš¢', 'âœˆï¸', 'ðŸ›©ï¸', 'ðŸ›«', 'ðŸ›¬', 'ðŸª‚', 'ðŸ’º', 'ðŸš', 'ðŸšŸ', 'ðŸš ', 'ðŸš¡', 'ðŸ›°ï¸', 'ðŸš€', 'ðŸ›¸', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸŽˆ', 'ðŸŽ‰', 'ðŸŽŠ', 'ðŸŽ‹', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘', 'ðŸ§§', 'ðŸŽ€', 'ðŸŽ', 'ðŸŽ—ï¸', 'ðŸŽŸï¸', 'ðŸŽ«', 'ðŸ”®', 'ðŸ§¿', 'ðŸ•¹ï¸', 'ðŸ–¼ï¸', 'ðŸŽ¨', 'ðŸ§µ', 'ðŸ§¶', 'ðŸ“¸', 'ðŸ“·', 'ðŸ“¹', 'ðŸŽ¥', 'ðŸ“½ï¸', 'ðŸŽžï¸', 'ðŸ“ž', 'â˜Žï¸', 'ðŸ“Ÿ', 'ðŸ“ ', 'ðŸ“º', 'ðŸ“»', 'ðŸŽ™ï¸', 'ðŸŽšï¸', 'ðŸŽ›ï¸', 'ðŸ§­', 'â±ï¸', 'â²ï¸', 'â°', 'ðŸ•°ï¸', 'âŒ›', 'â³', 'ðŸ“¡', 'ðŸ”‹', 'ðŸ”Œ', 'ðŸ’¡', 'ðŸ”¦', 'ðŸ•¯ï¸', 'ðŸª”', 'ðŸ§¯', 'ðŸ›¢ï¸', 'ðŸ’¸', 'ðŸ’µ', 'ðŸ’´', 'ðŸ’¶', 'ðŸ’·', 'ðŸ’°', 'ðŸ’³', 'ðŸ’Ž', 'âš–ï¸', 'ðŸ§°', 'ðŸ”§', 'ðŸ”¨', 'âš’ï¸', 'ðŸ› ï¸', 'â›ï¸', 'ðŸ”©', 'âš™ï¸', 'ðŸ§±', 'â›“ï¸', 'ðŸ§²', 'ðŸ”«', 'ðŸ’£', 'ðŸ§¨', 'ðŸ”ª', 'ðŸ—¡ï¸', 'âš”ï¸', 'ðŸ›¡ï¸', 'ðŸš¬', 'âš°ï¸', 'âš±ï¸', 'ðŸº', 'ðŸ”®', 'ðŸ“¿', 'ðŸ§¿', 'ðŸ’ˆ', 'âš—ï¸', 'ðŸ”­', 'ðŸ”¬', 'ðŸ•³ï¸', 'ðŸ’Š', 'ðŸ’‰', 'ðŸ©¹', 'ðŸ©º', 'ðŸŒ¡ï¸', 'ðŸ§¬', 'ðŸ¦ ', 'ðŸ§«', 'ðŸ§ª', 'ðŸŒ‚', 'â˜‚ï¸', 'â˜”', 'â›±ï¸', 'âš¡', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'â˜„ï¸', 'ðŸ”¥', 'ðŸ’§', 'ðŸŒŠ', 'ðŸŽƒ', 'ðŸŽ„', 'ðŸŽ†', 'ðŸŽ‡', 'ðŸ§¨', 'âœ¨', 'ðŸŽˆ', 'ðŸŽ‰', 'ðŸŽŠ', 'ðŸŽ‹', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘', 'ðŸ§§', 'ðŸŽ€', 'ðŸŽ', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±', 'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸ¥…', 'â›³', 'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸŽ½', 'ðŸ›¹', 'ðŸ›·', 'â›¸ï¸', 'ðŸ¥Œ', 'ðŸŽ¿', 'â›·ï¸', 'ðŸ‚'];

    class NonogramSolver {
        constructor(rowClues, colClues) {
            this.rowClues = rowClues;
            this.colClues = colClues;
            this.size = rowClues.length;
            this.grid = Array(this.size).fill().map(() => Array(this.size).fill(-1));
        }

        solve() {
            const maxIterations = 100;
            let iteration = 0;
            let changed = true;

            while (changed && iteration < maxIterations) {
                changed = false;
                iteration++;

                for (let y = 0; y < this.size; y++) {
                    const line = this.grid[y];
                    const newLine = this.solveLine(line, this.rowClues[y]);
                    if (this.updateLine(this.grid[y], newLine)) {
                        changed = true;
                    }
                }

                for (let x = 0; x < this.size; x++) {
                    const line = this.grid.map(row => row[x]);
                    const newLine = this.solveLine(line, this.colClues[x]);
                    if (newLine) {
                        for (let y = 0; y < this.size; y++) {
                            if (this.grid[y][x] === -1 && newLine[y] !== -1) {
                                this.grid[y][x] = newLine[y];
                                changed = true;
                            }
                        }
                    }
                }
            }

            return this.isComplete();
        }

        solveLine(line, clues) {
            const size = line.length;
            const possibilities = this.generatePossibilities(size, clues);
            const validPossibilities = possibilities.filter(poss =>
                this.isCompatible(line, poss)
            );

            if (validPossibilities.length === 0) return null;

            const result = [...line];
            for (let i = 0; i < size; i++) {
                if (result[i] === -1) {
                    const allFilled = validPossibilities.every(poss => poss[i] === 1);
                    const allEmpty = validPossibilities.every(poss => poss[i] === 0);

                    if (allFilled) result[i] = 1;
                    else if (allEmpty) result[i] = 0;
                }
            }

            return result;
        }

        generatePossibilities(size, clues) {
            const possibilities = [];

            function generate(pos, clueIdx, current) {
                if (clueIdx === clues.length) {
                    possibilities.push([...current, ...Array(size - pos).fill(0)]);
                    return;
                }

                const clue = clues[clueIdx];
                const remainingClues = clues.slice(clueIdx + 1);
                const minSpaceNeeded = remainingClues.reduce((sum, c) => sum + c, 0) + remainingClues.length;

                for (let start = pos; start <= size - clue - minSpaceNeeded; start++) {
                    const newCurrent = [
                        ...current,
                        ...Array(start - pos).fill(0),
                        ...Array(clue).fill(1)
                    ];

                    if (clueIdx < clues.length - 1) {
                        newCurrent.push(0);
                        generate(start + clue + 1, clueIdx + 1, newCurrent);
                    } else {
                        generate(start + clue, clueIdx + 1, newCurrent);
                    }
                }
            }

            if (clues.length === 1 && clues[0] === 0) {
                return [Array(size).fill(0)];
            }

            generate(0, 0, []);
            return possibilities;
        }

        isCompatible(line, possibility) {
            for (let i = 0; i < line.length; i++) {
                if (line[i] !== -1 && line[i] !== possibility[i]) {
                    return false;
                }
            }
            return true;
        }

        updateLine(original, newLine) {
            if (!newLine) return false;
            let changed = false;
            for (let i = 0; i < original.length; i++) {
                if (original[i] === -1 && newLine[i] !== -1) {
                    original[i] = newLine[i];
                    changed = true;
                }
            }
            return changed;
        }

        isComplete() {
            return this.grid.every(row => row.every(cell => cell !== -1));
        }

        getGrid() {
            return this.grid;
        }
    }

    class NonogramGame {
        constructor() {
            this.difficultySize = 15;
            this.size = 15;
            this.solution = [];
            this.playerGrid = [];
            this.rowClues = [];
            this.colClues = [];
            this.timer = null;
            this.startTime = 0;
            this.drawMode = 'fill';
            this.isDrawing = false;
            this.lastDrawState = null;
            this.currentEmoji = '';
            this.audio = new (window.AudioContext || window.webkitAudioContext)();
            this.init();
        }

        init() {
            this.bindEvents();
            this.newGame();
        }

        bindEvents() {
            document.getElementById('newGame').onclick = () => this.newGame();
            document.getElementById('checkBtn').onclick = () => this.checkSolution();
            document.getElementById('hintBtn').onclick = () => this.showHint();
            document.getElementById('playAgain').onclick = () => {
                document.getElementById('winModal').classList.remove('show');
                this.newGame();
            };
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.difficultySize = parseInt(btn.dataset.size);
                    this.newGame();
                };
            });
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.drawMode = btn.dataset.mode;
                };
            });
        }

        updateStatus(message) {
            document.getElementById('genStatus').textContent = message;
        }

        async newGame() {
            this.size = this.difficultySize;
            this.updateStatus('Generating puzzle...');

            await new Promise(resolve => setTimeout(resolve, 50));

            let attempts = 0;
            const maxAttempts = 50;
            let solvable = false;

            while (!solvable && attempts < maxAttempts) {
                attempts++;
                this.updateStatus(`Generating puzzle... (attempt ${attempts})`);

                this.size = this.difficultySize;
                this.currentEmoji = EMOJI_POOL[Math.floor(Math.random() * EMOJI_POOL.length)];
                await this.generateSolutionFromEmoji();
                this.trimEmptyBorders();
                this.calculateClues();

                const solver = new NonogramSolver(this.rowClues, this.colClues);
                solvable = solver.solve();

                if (solvable) {
                    const solverGrid = solver.getGrid();
                    let matches = true;
                    for (let y = 0; y < this.size; y++) {
                        for (let x = 0; x < this.size; x++) {
                            if (solverGrid[y][x] !== this.solution[y][x]) {
                                matches = false;
                                break;
                            }
                        }
                        if (!matches) break;
                    }

                    if (!matches) {
                        solvable = false;
                    }
                }

                if (!solvable && attempts % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            if (!solvable) {
                this.updateStatus('Failed to generate solvable puzzle. Using simpler pattern...');
                await new Promise(resolve => setTimeout(resolve, 500));
                this.size = this.difficultySize;
                this.generateSimplePattern();
                this.trimEmptyBorders();
                this.calculateClues();
            } else {
                this.updateStatus(`âœ“ Verified solvable! (${attempts} ${attempts === 1 ? 'attempt' : 'attempts'})`);
                setTimeout(() => this.updateStatus(''), 2000);
            }

            this.playerGrid = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.startTimer();
            this.render();
            this.updateStats();
        }

        async generateSolutionFromEmoji() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scale = 2;
            canvas.width = this.size * scale;
            canvas.height = this.size * scale;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${this.size * scale * 0.75}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(this.currentEmoji, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            this.solution = Array(this.size).fill().map(() => Array(this.size).fill(0));

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    const px = ((y * scale) * canvas.width + (x * scale)) * 4;
                    const brightness = imageData.data[px] + imageData.data[px + 1] + imageData.data[px + 2];
                    this.solution[y][x] = brightness > 100 ? 1 : 0;
                }
            }
        }

        trimEmptyBorders() {
            let topTrim = 0;
            for (let y = 0; y < this.size; y++) {
                if (this.solution[y].some(cell => cell === 1)) break;
                topTrim++;
            }

            let bottomTrim = 0;
            for (let y = this.size - 1; y >= 0; y--) {
                if (this.solution[y].some(cell => cell === 1)) break;
                bottomTrim++;
            }

            let leftTrim = 0;
            for (let x = 0; x < this.size; x++) {
                if (this.solution.some(row => row[x] === 1)) break;
                leftTrim++;
            }

            let rightTrim = 0;
            for (let x = this.size - 1; x >= 0; x--) {
                if (this.solution.some(row => row[x] === 1)) break;
                rightTrim++;
            }

            if (topTrim > 0 || bottomTrim > 0 || leftTrim > 0 || rightTrim > 0) {
                const newHeight = this.size - topTrim - bottomTrim;
                const newWidth = this.size - leftTrim - rightTrim;

                const newSolution = [];
                for (let y = topTrim; y < this.size - bottomTrim; y++) {
                    newSolution.push(this.solution[y].slice(leftTrim, this.size - rightTrim));
                }

                this.solution = newSolution;
                this.size = Math.max(newHeight, newWidth);

                while (this.solution.length < this.size) {
                    this.solution.push(Array(this.solution[0].length).fill(0));
                }

                if (this.solution[0].length < this.size) {
                    for (let y = 0; y < this.solution.length; y++) {
                        while (this.solution[y].length < this.size) {
                            this.solution[y].push(0);
                        }
                    }
                }
            }
        }

        generateSimplePattern() {
            this.solution = Array(this.size).fill().map(() => Array(this.size).fill(0));
            const center = Math.floor(this.size / 2);
            const radius = Math.floor(this.size / 3);

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    const distance = Math.abs(x - center) + Math.abs(y - center);
                    if (distance <= radius) {
                        this.solution[y][x] = 1;
                    }
                }
            }

            this.currentEmoji = 'ðŸ’Ž';
        }

        calculateClues() {
            this.rowClues = [];
            this.colClues = [];

            for (let y = 0; y < this.size; y++) {
                const clue = [];
                let count = 0;
                for (let x = 0; x < this.size; x++) {
                    if (this.solution[y][x] === 1) {
                        count++;
                    } else if (count > 0) {
                        clue.push(count);
                        count = 0;
                    }
                }
                if (count > 0) clue.push(count);
                this.rowClues.push(clue.length ? clue : [0]);
            }

            for (let x = 0; x < this.size; x++) {
                const clue = [];
                let count = 0;
                for (let y = 0; y < this.size; y++) {
                    if (this.solution[y][x] === 1) {
                        count++;
                    } else if (count > 0) {
                        clue.push(count);
                        count = 0;
                    }
                }
                if (count > 0) clue.push(count);
                this.colClues.push(clue.length ? clue : [0]);
            }
        }

        render() {
            const container = document.getElementById('puzzleContainer');
            container.innerHTML = '';

            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';

            const colClues = document.createElement('div');
            colClues.className = 'col-clues';
            colClues.style.marginLeft = '70px';

            const cellSize = Math.max(22, Math.min(35, 450 / this.size));

            for (let x = 0; x < this.size; x++) {
                const colClue = document.createElement('div');
                colClue.className = 'col-clue';
                colClue.style.width = `${cellSize}px`;
                this.colClues[x].forEach(num => {
                    const div = document.createElement('div');
                    div.textContent = num;
                    colClue.appendChild(div);
                });
                colClues.appendChild(colClue);
            }
            gridContainer.appendChild(colClues);

            for (let y = 0; y < this.size; y++) {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'row-container';

                const rowClue = document.createElement('div');
                rowClue.className = 'row-clue';
                this.rowClues[y].forEach(num => {
                    const span = document.createElement('span');
                    span.textContent = num;
                    rowClue.appendChild(span);
                });
                rowContainer.appendChild(rowClue);

                const grid = document.createElement('div');
                grid.className = 'grid';
                grid.style.gridTemplateColumns = `repeat(${this.size},${cellSize}px)`;
                colClues.style.gridTemplateColumns = `repeat(${this.size}, ${cellSize}px)`;

                for (let x = 0; x < this.size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    this.updateCellView(cell, x, y);

                    cell.onmousedown = (e) => {
                        e.preventDefault();
                        this.startDrawing(x, y, e.button);
                    };
                    cell.onmouseenter = () => {
                        if (this.isDrawing) this.continuDrawing(x, y);
                    };
                    cell.onmouseup = () => this.stopDrawing();
                    cell.oncontextmenu = e => e.preventDefault();

                    grid.appendChild(cell);
                }
                rowContainer.appendChild(grid);
                gridContainer.appendChild(rowContainer);
            }
            container.appendChild(gridContainer);

            document.addEventListener('mouseup', () => this.stopDrawing());
        }

        startDrawing(x, y, button) {
            this.isDrawing = true;
            const currentState = this.playerGrid[y][x];

            if (button === 0) {
                if (this.drawMode === 'fill') {
                    this.lastDrawState = currentState === 1 ? 0 : 1;
                } else {
                    this.lastDrawState = currentState === 2 ? 0 : 2;
                }
            } else if (button === 2) {
                this.lastDrawState = currentState === 2 ? 0 : 2;
            }

            this.applyDraw(x, y);
            this.playSound('click', 200);
        }

        continuDrawing(x, y) {
            if (this.isDrawing) {
                this.applyDraw(x, y);
            }
        }

        stopDrawing() {
            this.isDrawing = false;
            this.lastDrawState = null;
        }

        applyDraw(x, y) {
            if (this.lastDrawState !== null) {
                this.playerGrid[y][x] = this.lastDrawState;
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                this.updateCellView(cell, x, y);
                this.updateStats();
            }
        }

        updateCellView(cell, x, y) {
            cell.className = 'cell';
            if (this.playerGrid[y][x] === 1) {
                cell.classList.add('filled');
            } else if (this.playerGrid[y][x] === 2) {
                cell.classList.add('marked');
            }
        }

        updateStats() {
            const filled = this.playerGrid.flat().filter(c => c === 1).length;
            const total = this.solution.flat().filter(c => c === 1).length;
            const progress = total > 0 ? Math.min(100, Math.round((filled / total) * 100)) : 0;
            document.getElementById('progress').textContent = `${progress}%`;

            let errorCount = 0;
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.playerGrid[y][x] === 1 && this.solution[y][x] !== 1) {
                        errorCount++;
                    }
                }
            }
            document.getElementById('errors').textContent = errorCount;
        }

        checkSolution() {
            let correct = true;
            const errorCells = [];

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.playerGrid[y][x] === 1 && this.solution[y][x] !== 1) {
                        correct = false;
                        errorCells.push({x, y});
                    } else if (this.playerGrid[y][x] !== 1 && this.solution[y][x] === 1) {
                        correct = false;
                    }
                }
            }

            if (!correct) {
                errorCells.forEach(({x, y}) => {
                    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    cell.classList.add('error-flash');
                    setTimeout(() => cell.classList.remove('error-flash'), 400);
                });
                this.playSound('error', 150);
            } else {
                this.playSound('win', 523);
                this.stopTimer();
                this.showWin();
            }
        }

        showHint() {
            const emptyCells = [];
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.solution[y][x] === 1 && this.playerGrid[y][x] !== 1) {
                        emptyCells.push({x, y});
                    }
                }
            }

            if (emptyCells.length > 0) {
                const hint = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                this.playerGrid[hint.y][hint.x] = 1;
                const cell = document.querySelector(`[data-x="${hint.x}"][data-y="${hint.y}"]`);
                this.updateCellView(cell, hint.x, hint.y);
                this.updateStats();
                this.playSound('click', 400);
            }
        }

        showWin() {
            document.getElementById('solvedEmoji').textContent = this.currentEmoji;
            document.getElementById('finalTime').textContent = document.getElementById('timer').textContent;
            document.getElementById('winModal').classList.add('show');
        }

        startTimer() {
            this.stopTimer();
            this.startTime = Date.now();
            this.timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const secs = String(elapsed % 60).padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            }, 1000);
        }

        stopTimer() {
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
        }

        playSound(type, freq) {
            const osc = this.audio.createOscillator();
            const gain = this.audio.createGain();
            osc.connect(gain);
            gain.connect(this.audio.destination);
            osc.frequency.value = freq;
            gain.gain.value = 0.08;

            if (type === 'win') {
                [523, 659, 784, 1047].forEach((f, i) => {
                    const o = this.audio.createOscillator();
                    const g = this.audio.createGain();
                    o.connect(g);
                    g.connect(this.audio.destination);
                    o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, this.audio.currentTime + i * 0.1);
                    g.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + i * 0.1 + 0.3);
                    o.start(this.audio.currentTime + i * 0.1);
                    o.stop(this.audio.currentTime + i * 0.1 + 0.3);
                });
            } else {
                osc.start();
                osc.stop(this.audio.currentTime + 0.05);
            }
        }
    }

    new NonogramGame();
</script>
<script src="../logo.js"></script>
</body>
</html>