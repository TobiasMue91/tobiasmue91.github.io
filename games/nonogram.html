<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta name="keywords"
          content="nonogram, picross, griddlers, logic puzzle, picture puzzle, brain game, puzzle game, online game, free game">
    <meta name="author" content="Claude Sonnet 4.5 prompted by Tobias MÃ¼ller">
    <meta property="og:title" content="Nonogram - Logic Puzzle Game">
    <meta property="og:description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_228.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/nonogram.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Nonogram - Logic Puzzle Game">
    <meta name="twitter:description"
          content="Play Nonogram puzzle game online! Solve logic puzzles by filling grids to reveal hidden emoji pictures. Features auto-generated puzzles, drag-to-draw controls, and multiple difficulty levels.">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_228.webp">
    <link rel="canonical" href="https://www.gptgames.dev/games/nonogram.html">
    <title>Nonogram Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game {
            max-width: 900px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.8em;
            color: #4ecdc4;
            margin-bottom: 5px;
            font-weight: 300;
            letter-spacing: 3px;
        }

        .subtitle {
            color: #7a7a7a;
            font-size: 0.95em;
            margin-bottom: 20px;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            outline: none;
        }

        .btn-primary {
            background: #4ecdc4;
            color: #0a0e27;
        }

        .btn-primary:hover {
            background: #45b8b0;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary {
            background: #2d3561;
            color: #4ecdc4;
            border: 2px solid #4ecdc4;
        }

        .btn-secondary:hover {
            background: #3d4575;
        }

        .btn:active {
            transform: translateY(0);
        }

        .difficulty {
            display: flex;
            gap: 8px;
            background: #16213e;
            padding: 4px;
            border-radius: 6px;
        }

        .difficulty button {
            background: transparent;
            color: #7a7a7a;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .difficulty button.active {
            background: #4ecdc4;
            color: #0a0e27;
        }

        .game-area {
            background: #16213e;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        .puzzle-container {
            display: inline-block;
            position: relative;
        }

        .grid-container {
            display: grid;
            gap: 0;
            position: relative;
        }

        .col-clues {
            display: grid;
            margin-bottom: 8px;
            gap: 1px;
        }

        .col-clue {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 4px 2px;
            font-size: 0.7em;
            color: #4ecdc4;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .col-clue div {
            padding: 1px 0;
        }

        .row-container {
            display: flex;
            align-items: center;
        }

        .row-clue {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 4px 8px;
            gap: 4px;
            font-size: 0.7em;
            color: #4ecdc4;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            min-width: 70px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: #0f3460;
            padding: 1px;
            border-radius: 4px;
        }

        .cell {
            background: #1a2744;
            cursor: crosshair;
            border: 1px solid #0f3460;
            transition: all 0.1s;
            position: relative;
            user-select: none;
        }

        .cell:hover {
            background: #243251;
            border-color: #4ecdc4;
        }

        .cell.filled {
            background: #4ecdc4;
        }

        .cell.marked {
            background: #1a2744;
        }

        .cell.marked::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 2px solid #ff6b6b;
            border-radius: 2px;
        }

        .cell.marked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            transform: translate(-50%, -50%) rotate(-45deg);
            border: 2px solid #ff6b6b;
            border-radius: 2px;
        }

        .cell.highlight {
            background: #2d4a6f;
        }

        .cell.error-flash {
            animation: errorFlash 0.4s;
        }

        @keyframes errorFlash {
            0%, 100% {
                background: #1a2744;
            }
            50% {
                background: #ff6b6b;
            }
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #16213e;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7a7a7a;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            color: #4ecdc4;
            font-weight: 600;
        }

        .instructions {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #4ecdc4;
        }

        .instructions h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .instructions p {
            color: #a0a0a0;
            line-height: 1.6;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .instructions strong {
            color: #e0e0e0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(78, 205, 196, 0.3);
            animation: modalSlide 0.3s;
            max-width: 500px;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal h2 {
            color: #4ecdc4;
            font-size: 2.5em;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .modal .emoji-big {
            font-size: 6em;
            margin: 20px 0;
            animation: emojiSpin 0.6s;
        }

        @keyframes emojiSpin {
            from {
                transform: scale(0) rotate(-180deg);
            }
            to {
                transform: scale(1) rotate(0);
            }
        }

        .modal p {
            color: #a0a0a0;
            font-size: 1.1em;
            margin-bottom: 30px;
        }

        .modal .time {
            color: #4ecdc4;
            font-size: 1.5em;
            font-weight: 600;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            background: #16213e;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .mode-selector label {
            color: #a0a0a0;
            font-size: 0.85em;
            margin-right: 5px;
        }

        .mode-btn {
            background: #2d3561;
            color: #a0a0a0;
            border: none;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: #4ecdc4;
            color: #0a0e27;
            font-weight: 600;
        }

        .generation-status {
            text-align: center;
            color: #4ecdc4;
            font-size: 0.9em;
            margin-top: 10px;
            min-height: 20px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            .game-area {
                padding: 15px;
            }

            .modal-content {
                padding: 30px;
            }
        }
    </style>
</head>
<body>
<div class="game">
    <div class="header">
        <h1>NONOGRAM</h1>
        <p class="subtitle">Solve the logic puzzle by filling the grid</p>
    </div>
    <div class="toolbar">
        <button class="btn btn-primary" id="newGame">New Game</button>
        <div class="difficulty">
            <button class="diff-btn" data-size="10">Easy</button>
            <button class="diff-btn active" data-size="15">Medium</button>
            <button class="diff-btn" data-size="20">Hard</button>
        </div>
        <button class="btn btn-secondary" id="checkBtn">Validate</button>
        <button class="btn btn-secondary" id="hintBtn">Hint</button>
    </div>
    <div class="mode-selector">
        <label>Draw Mode:</label>
        <button class="mode-btn active" data-mode="fill">Fill</button>
        <button class="mode-btn" data-mode="mark">Mark X</button>
    </div>
    <div class="generation-status" id="genStatus"></div>
    <div class="game-area">
        <div style="display:flex;justify-content:center;">
            <div class="puzzle-container" id="puzzleContainer"></div>
        </div>
    </div>
    <div class="stats">
        <div class="stat-box">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="timer">00:00</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Progress</div>
            <div class="stat-value" id="progress">0%</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Errors</div>
            <div class="stat-value" id="errors">0</div>
        </div>
    </div>
    <div class="instructions">
        <h3>ð How to Play</h3>
        <p><strong>Goal:</strong> Fill cells to reveal a hidden picture using number clues.</p>
        <p><strong>Controls:</strong> Click or drag to fill cells. Switch modes to mark cells with X (cells you know are
            empty).</p>
        <p><strong>Clues:</strong> Numbers show consecutive filled cells in each row/column. Multiple numbers mean
            separate groups with at least one empty cell between them.</p>
        <p><strong>Example:</strong> "3 1 2" means: 3 filled, gap, 1 filled, gap, 2 filled.</p>
        <p><strong>Guaranteed:</strong> Every puzzle is verified to be logically solvable without guessing!</p>
    </div>
</div>
<div class="modal" id="winModal">
    <div class="modal-content">
        <h2>ð Solved!</h2>
        <div class="emoji-big" id="solvedEmoji"></div>
        <p>Completed in <span class="time" id="finalTime"></span></p>
        <button class="btn btn-primary" id="playAgain">Play Again</button>
    </div>
</div>
<script>
    const EMOJI_POOL = ['ð®', 'ð¯', 'ð¨', 'ð­', 'ðª', 'ð¸', 'ð¹', 'ðº', 'ð»', 'ð²', 'ð°', 'ð³', 'ð', 'â½', 'ð', 'â¾', 'ð¾', 'ð', 'ð', 'ð±', 'ð', 'ð¸', 'ð', 'ð', 'ð¥', 'ð¥', 'â³', 'ð¹', 'ð£', 'ð¥', 'â·ï¸', 'ð', 'ð', 'ð´', 'ð', 'ð¤¸', 'ð§', 'ð¤º', 'ð', 'â¹ï¸', 'ðï¸', 'ð¤¾', 'ð£', 'ð', 'ð§', 'ð', 'ð¶', 'ð', 'ðº', 'ð¤³', 'ðª', 'ð', 'ð', 'ð', 'ð¤', 'ð', 'ð', 'â', 'ð¤', 'ð¤', 'ð', 'âï¸', 'ð¤', 'ð¤', 'ð¤', 'ð', 'ð', 'ð', 'ð', 'âï¸', 'â', 'ð¤', 'ðï¸', 'ð', 'ð', 'ð¤', 'ð', 'ð¦¾', 'ð¦¿', 'ð¦µ', 'ð¦¶', 'ð', 'ð¦»', 'ð', 'ð§ ', 'ð¦·', 'ð¦´', 'ð', 'ðï¸', 'ð', 'ð', 'ð', 'ð©¸', 'ð', 'ð°', 'ð§', 'ðª', 'ð©', 'ð«', 'ð¬', 'ð­', 'ð®', 'ð¯', 'ð¼', 'ð¥', 'â', 'ðµ', 'ð¶', 'ð¾', 'ð·', 'ð¸', 'ð¹', 'ðº', 'ð»', 'ð¥', 'ð¥', 'ð¥¤', 'ð§', 'ð§', 'ð§', 'ð¥¢', 'ð´', 'ð¥', 'ðª', 'ðº', 'ð', 'ð', 'ð', 'ð', 'ðºï¸', 'ð¾', 'ð§­', 'ðï¸', 'â°ï¸', 'ð', 'ð»', 'ðï¸', 'ðï¸', 'ðï¸', 'ðï¸', 'ðï¸', 'ðï¸', 'ðï¸', 'ðï¸', 'ð§±', 'ðï¸', 'ðï¸', 'ð ', 'ð¡', 'ð¢', 'ð£', 'ð¤', 'ð¥', 'ð¦', 'ð¨', 'ð©', 'ðª', 'ð«', 'ð¬', 'ð­', 'ð¯', 'ð°', 'ð¼', 'ð½', 'âª', 'ð', 'ð', 'ð', 'â©ï¸', 'ð', 'â²', 'âº', 'ð', 'ð', 'ðï¸', 'ð', 'ð', 'ð', 'ð', 'ð', 'â¨ï¸', 'ð ', 'ð¡', 'ð¢', 'ð', 'ðª', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ðï¸', 'ðï¸', 'ðµ', 'ð¦½', 'ð¦¼', 'ðº', 'ð²', 'ð´', 'ð¹', 'ð', 'ð£ï¸', 'ð¤ï¸', 'ð¢ï¸', 'â½', 'ð¨', 'ð¥', 'ð¦', 'ð', 'ð§', 'â', 'âµ', 'ð¶', 'ð¤', 'ð³ï¸', 'â´ï¸', 'ð¥ï¸', 'ð¢', 'âï¸', 'ð©ï¸', 'ð«', 'ð¬', 'ðª', 'ðº', 'ð', 'ð', 'ð ', 'ð¡', 'ð°ï¸', 'ð', 'ð¸', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð§§', 'ð', 'ð', 'ðï¸', 'ðï¸', 'ð«', 'ð®', 'ð§¿', 'ð¹ï¸', 'ð¼ï¸', 'ð¨', 'ð§µ', 'ð§¶', 'ð¸', 'ð·', 'ð¹', 'ð¥', 'ð½ï¸', 'ðï¸', 'ð', 'âï¸', 'ð', 'ð ', 'ðº', 'ð»', 'ðï¸', 'ðï¸', 'ðï¸', 'ð§­', 'â±ï¸', 'â²ï¸', 'â°', 'ð°ï¸', 'â', 'â³', 'ð¡', 'ð', 'ð', 'ð¡', 'ð¦', 'ð¯ï¸', 'ðª', 'ð§¯', 'ð¢ï¸', 'ð¸', 'ðµ', 'ð´', 'ð¶', 'ð·', 'ð°', 'ð³', 'ð', 'âï¸', 'ð§°', 'ð§', 'ð¨', 'âï¸', 'ð ï¸', 'âï¸', 'ð©', 'âï¸', 'ð§±', 'âï¸', 'ð§²', 'ð«', 'ð£', 'ð§¨', 'ðª', 'ð¡ï¸', 'âï¸', 'ð¡ï¸', 'ð¬', 'â°ï¸', 'â±ï¸', 'ðº', 'ð®', 'ð¿', 'ð§¿', 'ð', 'âï¸', 'ð­', 'ð¬', 'ð³ï¸', 'ð', 'ð', 'ð©¹', 'ð©º', 'ð¡ï¸', 'ð§¬', 'ð¦ ', 'ð§«', 'ð§ª', 'ð', 'âï¸', 'â', 'â±ï¸', 'â¡', 'âï¸', 'âï¸', 'â', 'âï¸', 'ð¥', 'ð§', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð§¨', 'â¨', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð§§', 'ð', 'ð', 'ð', 'ð¥', 'ð¥', 'ð¥', 'â½', 'ð', 'ð', 'â¾', 'ð¥', 'ð¾', 'ð', 'ð', 'ð¥', 'ð±', 'ðª', 'ð', 'ð¸', 'ð', 'ð', 'ð¥', 'ð', 'ð¥', 'â³', 'ðª', 'ð¹', 'ð£', 'ð¤¿', 'ð¥', 'ð¥', 'ð½', 'ð¹', 'ð·', 'â¸ï¸', 'ð¥', 'ð¿', 'â·ï¸', 'ð'];

    class NonogramSolver {
        constructor(rowClues, colClues) {
            this.rowClues = rowClues;
            this.colClues = colClues;
            this.size = rowClues.length;
            this.grid = Array(this.size).fill().map(() => Array(this.size).fill(-1));
        }

        solve() {
            const maxIterations = 100;
            let iteration = 0;
            let changed = true;

            while (changed && iteration < maxIterations) {
                changed = false;
                iteration++;

                for (let y = 0; y < this.size; y++) {
                    const line = this.grid[y];
                    const newLine = this.solveLine(line, this.rowClues[y]);
                    if (this.updateLine(this.grid[y], newLine)) {
                        changed = true;
                    }
                }

                for (let x = 0; x < this.size; x++) {
                    const line = this.grid.map(row => row[x]);
                    const newLine = this.solveLine(line, this.colClues[x]);
                    if (newLine) {
                        for (let y = 0; y < this.size; y++) {
                            if (this.grid[y][x] === -1 && newLine[y] !== -1) {
                                this.grid[y][x] = newLine[y];
                                changed = true;
                            }
                        }
                    }
                }
            }

            return this.isComplete();
        }

        solveLine(line, clues) {
            const size = line.length;
            const possibilities = this.generatePossibilities(size, clues);
            const validPossibilities = possibilities.filter(poss =>
                this.isCompatible(line, poss)
            );

            if (validPossibilities.length === 0) return null;

            const result = [...line];
            for (let i = 0; i < size; i++) {
                if (result[i] === -1) {
                    const allFilled = validPossibilities.every(poss => poss[i] === 1);
                    const allEmpty = validPossibilities.every(poss => poss[i] === 0);

                    if (allFilled) result[i] = 1;
                    else if (allEmpty) result[i] = 0;
                }
            }

            return result;
        }

        generatePossibilities(size, clues) {
            const possibilities = [];

            function generate(pos, clueIdx, current) {
                if (clueIdx === clues.length) {
                    possibilities.push([...current, ...Array(size - pos).fill(0)]);
                    return;
                }

                const clue = clues[clueIdx];
                const remainingClues = clues.slice(clueIdx + 1);
                const minSpaceNeeded = remainingClues.reduce((sum, c) => sum + c, 0) + remainingClues.length;

                for (let start = pos; start <= size - clue - minSpaceNeeded; start++) {
                    const newCurrent = [
                        ...current,
                        ...Array(start - pos).fill(0),
                        ...Array(clue).fill(1)
                    ];

                    if (clueIdx < clues.length - 1) {
                        newCurrent.push(0);
                        generate(start + clue + 1, clueIdx + 1, newCurrent);
                    } else {
                        generate(start + clue, clueIdx + 1, newCurrent);
                    }
                }
            }

            if (clues.length === 1 && clues[0] === 0) {
                return [Array(size).fill(0)];
            }

            generate(0, 0, []);
            return possibilities;
        }

        isCompatible(line, possibility) {
            for (let i = 0; i < line.length; i++) {
                if (line[i] !== -1 && line[i] !== possibility[i]) {
                    return false;
                }
            }
            return true;
        }

        updateLine(original, newLine) {
            if (!newLine) return false;
            let changed = false;
            for (let i = 0; i < original.length; i++) {
                if (original[i] === -1 && newLine[i] !== -1) {
                    original[i] = newLine[i];
                    changed = true;
                }
            }
            return changed;
        }

        isComplete() {
            return this.grid.every(row => row.every(cell => cell !== -1));
        }

        getGrid() {
            return this.grid;
        }
    }

    class NonogramGame {
        constructor() {
            this.difficultySize = 15;
            this.size = 15;
            this.solution = [];
            this.playerGrid = [];
            this.rowClues = [];
            this.colClues = [];
            this.timer = null;
            this.startTime = 0;
            this.drawMode = 'fill';
            this.isDrawing = false;
            this.lastDrawState = null;
            this.currentEmoji = '';
            this.audio = new (window.AudioContext || window.webkitAudioContext)();
            this.init();
        }

        init() {
            this.bindEvents();
            this.newGame();
        }

        bindEvents() {
            document.getElementById('newGame').onclick = () => this.newGame();
            document.getElementById('checkBtn').onclick = () => this.checkSolution();
            document.getElementById('hintBtn').onclick = () => this.showHint();
            document.getElementById('playAgain').onclick = () => {
                document.getElementById('winModal').classList.remove('show');
                this.newGame();
            };
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.difficultySize = parseInt(btn.dataset.size);
                    this.newGame();
                };
            });
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.drawMode = btn.dataset.mode;
                };
            });
        }

        updateStatus(message) {
            document.getElementById('genStatus').textContent = message;
        }

        async newGame() {
            this.size = this.difficultySize;
            this.updateStatus('Generating puzzle...');

            await new Promise(resolve => setTimeout(resolve, 50));

            let attempts = 0;
            const maxAttempts = 50;
            let solvable = false;

            while (!solvable && attempts < maxAttempts) {
                attempts++;
                this.updateStatus(`Generating puzzle... (attempt ${attempts})`);

                this.size = this.difficultySize;
                this.currentEmoji = EMOJI_POOL[Math.floor(Math.random() * EMOJI_POOL.length)];
                await this.generateSolutionFromEmoji();
                this.trimEmptyBorders();
                this.calculateClues();

                const solver = new NonogramSolver(this.rowClues, this.colClues);
                solvable = solver.solve();

                if (solvable) {
                    const solverGrid = solver.getGrid();
                    let matches = true;
                    for (let y = 0; y < this.size; y++) {
                        for (let x = 0; x < this.size; x++) {
                            if (solverGrid[y][x] !== this.solution[y][x]) {
                                matches = false;
                                break;
                            }
                        }
                        if (!matches) break;
                    }

                    if (!matches) {
                        solvable = false;
                    }
                }

                if (!solvable && attempts % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            if (!solvable) {
                this.updateStatus('Failed to generate solvable puzzle. Using simpler pattern...');
                await new Promise(resolve => setTimeout(resolve, 500));
                this.size = this.difficultySize;
                this.generateSimplePattern();
                this.trimEmptyBorders();
                this.calculateClues();
            } else {
                this.updateStatus(`â Verified solvable! (${attempts} ${attempts === 1 ? 'attempt' : 'attempts'})`);
                setTimeout(() => this.updateStatus(''), 2000);
            }

            this.playerGrid = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.startTimer();
            this.render();
            this.updateStats();
        }

        async generateSolutionFromEmoji() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scale = 2;
            canvas.width = this.size * scale;
            canvas.height = this.size * scale;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${this.size * scale * 0.75}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(this.currentEmoji, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            this.solution = Array(this.size).fill().map(() => Array(this.size).fill(0));

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    const px = ((y * scale) * canvas.width + (x * scale)) * 4;
                    const brightness = imageData.data[px] + imageData.data[px + 1] + imageData.data[px + 2];
                    this.solution[y][x] = brightness > 100 ? 1 : 0;
                }
            }
        }

        trimEmptyBorders() {
            let topTrim = 0;
            for (let y = 0; y < this.size; y++) {
                if (this.solution[y].some(cell => cell === 1)) break;
                topTrim++;
            }

            let bottomTrim = 0;
            for (let y = this.size - 1; y >= 0; y--) {
                if (this.solution[y].some(cell => cell === 1)) break;
                bottomTrim++;
            }

            let leftTrim = 0;
            for (let x = 0; x < this.size; x++) {
                if (this.solution.some(row => row[x] === 1)) break;
                leftTrim++;
            }

            let rightTrim = 0;
            for (let x = this.size - 1; x >= 0; x--) {
                if (this.solution.some(row => row[x] === 1)) break;
                rightTrim++;
            }

            if (topTrim > 0 || bottomTrim > 0 || leftTrim > 0 || rightTrim > 0) {
                const newHeight = this.size - topTrim - bottomTrim;
                const newWidth = this.size - leftTrim - rightTrim;

                const newSolution = [];
                for (let y = topTrim; y < this.size - bottomTrim; y++) {
                    newSolution.push(this.solution[y].slice(leftTrim, this.size - rightTrim));
                }

                this.solution = newSolution;
                this.size = Math.max(newHeight, newWidth);

                while (this.solution.length < this.size) {
                    this.solution.push(Array(this.solution[0].length).fill(0));
                }

                if (this.solution[0].length < this.size) {
                    for (let y = 0; y < this.solution.length; y++) {
                        while (this.solution[y].length < this.size) {
                            this.solution[y].push(0);
                        }
                    }
                }
            }
        }

        generateSimplePattern() {
            this.solution = Array(this.size).fill().map(() => Array(this.size).fill(0));
            const center = Math.floor(this.size / 2);
            const radius = Math.floor(this.size / 3);

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    const distance = Math.abs(x - center) + Math.abs(y - center);
                    if (distance <= radius) {
                        this.solution[y][x] = 1;
                    }
                }
            }

            this.currentEmoji = 'ð';
        }

        calculateClues() {
            this.rowClues = [];
            this.colClues = [];

            for (let y = 0; y < this.size; y++) {
                const clue = [];
                let count = 0;
                for (let x = 0; x < this.size; x++) {
                    if (this.solution[y][x] === 1) {
                        count++;
                    } else if (count > 0) {
                        clue.push(count);
                        count = 0;
                    }
                }
                if (count > 0) clue.push(count);
                this.rowClues.push(clue.length ? clue : [0]);
            }

            for (let x = 0; x < this.size; x++) {
                const clue = [];
                let count = 0;
                for (let y = 0; y < this.size; y++) {
                    if (this.solution[y][x] === 1) {
                        count++;
                    } else if (count > 0) {
                        clue.push(count);
                        count = 0;
                    }
                }
                if (count > 0) clue.push(count);
                this.colClues.push(clue.length ? clue : [0]);
            }
        }

        render() {
            const container = document.getElementById('puzzleContainer');
            container.innerHTML = '';

            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';

            const colClues = document.createElement('div');
            colClues.className = 'col-clues';
            colClues.style.marginLeft = '70px';

            const cellSize = Math.max(22, Math.min(35, 450 / this.size));

            for (let x = 0; x < this.size; x++) {
                const colClue = document.createElement('div');
                colClue.className = 'col-clue';
                colClue.style.width = `${cellSize}px`;
                this.colClues[x].forEach(num => {
                    const div = document.createElement('div');
                    div.textContent = num;
                    colClue.appendChild(div);
                });
                colClues.appendChild(colClue);
            }
            gridContainer.appendChild(colClues);

            for (let y = 0; y < this.size; y++) {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'row-container';

                const rowClue = document.createElement('div');
                rowClue.className = 'row-clue';
                this.rowClues[y].forEach(num => {
                    const span = document.createElement('span');
                    span.textContent = num;
                    rowClue.appendChild(span);
                });
                rowContainer.appendChild(rowClue);

                const grid = document.createElement('div');
                grid.className = 'grid';
                grid.style.gridTemplateColumns = `repeat(${this.size},${cellSize}px)`;
                colClues.style.gridTemplateColumns = `repeat(${this.size}, ${cellSize}px)`;

                for (let x = 0; x < this.size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    this.updateCellView(cell, x, y);

                    cell.onmousedown = (e) => {
                        e.preventDefault();
                        this.startDrawing(x, y, e.button);
                    };
                    cell.onmouseenter = () => {
                        if (this.isDrawing) this.continuDrawing(x, y);
                    };
                    cell.onmouseup = () => this.stopDrawing();
                    cell.oncontextmenu = e => e.preventDefault();

                    grid.appendChild(cell);
                }
                rowContainer.appendChild(grid);
                gridContainer.appendChild(rowContainer);
            }
            container.appendChild(gridContainer);

            document.addEventListener('mouseup', () => this.stopDrawing());
        }

        startDrawing(x, y, button) {
            this.isDrawing = true;
            const currentState = this.playerGrid[y][x];

            if (button === 0) {
                if (this.drawMode === 'fill') {
                    this.lastDrawState = currentState === 1 ? 0 : 1;
                } else {
                    this.lastDrawState = currentState === 2 ? 0 : 2;
                }
            } else if (button === 2) {
                this.lastDrawState = currentState === 2 ? 0 : 2;
            }

            this.applyDraw(x, y);
            this.playSound('click', 200);
        }

        continuDrawing(x, y) {
            if (this.isDrawing) {
                this.applyDraw(x, y);
            }
        }

        stopDrawing() {
            this.isDrawing = false;
            this.lastDrawState = null;
        }

        applyDraw(x, y) {
            if (this.lastDrawState !== null) {
                this.playerGrid[y][x] = this.lastDrawState;
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                this.updateCellView(cell, x, y);
                this.updateStats();
            }
        }

        updateCellView(cell, x, y) {
            cell.className = 'cell';
            if (this.playerGrid[y][x] === 1) {
                cell.classList.add('filled');
            } else if (this.playerGrid[y][x] === 2) {
                cell.classList.add('marked');
            }
        }

        updateStats() {
            const filled = this.playerGrid.flat().filter(c => c === 1).length;
            const total = this.solution.flat().filter(c => c === 1).length;
            const progress = total > 0 ? Math.min(100, Math.round((filled / total) * 100)) : 0;
            document.getElementById('progress').textContent = `${progress}%`;

            let errorCount = 0;
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.playerGrid[y][x] === 1 && this.solution[y][x] !== 1) {
                        errorCount++;
                    }
                }
            }
            document.getElementById('errors').textContent = errorCount;
        }

        checkSolution() {
            let correct = true;
            const errorCells = [];

            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.playerGrid[y][x] === 1 && this.solution[y][x] !== 1) {
                        correct = false;
                        errorCells.push({x, y});
                    } else if (this.playerGrid[y][x] !== 1 && this.solution[y][x] === 1) {
                        correct = false;
                    }
                }
            }

            if (!correct) {
                errorCells.forEach(({x, y}) => {
                    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    cell.classList.add('error-flash');
                    setTimeout(() => cell.classList.remove('error-flash'), 400);
                });
                this.playSound('error', 150);
            } else {
                this.playSound('win', 523);
                this.stopTimer();
                this.showWin();
            }
        }

        showHint() {
            const emptyCells = [];
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.solution[y][x] === 1 && this.playerGrid[y][x] !== 1) {
                        emptyCells.push({x, y});
                    }
                }
            }

            if (emptyCells.length > 0) {
                const hint = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                this.playerGrid[hint.y][hint.x] = 1;
                const cell = document.querySelector(`[data-x="${hint.x}"][data-y="${hint.y}"]`);
                this.updateCellView(cell, hint.x, hint.y);
                this.updateStats();
                this.playSound('click', 400);
            }
        }

        showWin() {
            document.getElementById('solvedEmoji').textContent = this.currentEmoji;
            document.getElementById('finalTime').textContent = document.getElementById('timer').textContent;
            document.getElementById('winModal').classList.add('show');
        }

        startTimer() {
            this.stopTimer();
            this.startTime = Date.now();
            this.timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const secs = String(elapsed % 60).padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            }, 1000);
        }

        stopTimer() {
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
        }

        playSound(type, freq) {
            const osc = this.audio.createOscillator();
            const gain = this.audio.createGain();
            osc.connect(gain);
            gain.connect(this.audio.destination);
            osc.frequency.value = freq;
            gain.gain.value = 0.08;

            if (type === 'win') {
                [523, 659, 784, 1047].forEach((f, i) => {
                    const o = this.audio.createOscillator();
                    const g = this.audio.createGain();
                    o.connect(g);
                    g.connect(this.audio.destination);
                    o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, this.audio.currentTime + i * 0.1);
                    g.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + i * 0.1 + 0.3);
                    o.start(this.audio.currentTime + i * 0.1);
                    o.stop(this.audio.currentTime + i * 0.1 + 0.3);
                });
            } else {
                osc.start();
                osc.stop(this.audio.currentTime + 0.05);
            }
        }
    }

    new NonogramGame();
</script>
<script src="../logo.js"></script>
</body>
</html>