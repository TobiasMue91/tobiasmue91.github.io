<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stack Tower - 3D Block Stacking Game</title>
    <meta name="description" content="Play Stack Tower, an addictive 3D block stacking game. Stack blocks as high as possible with perfect timing. Features beautiful 3D graphics, combo system, and increasing difficulty.">
    <meta name="keywords" content="stack tower, block stacking game, 3d game, tower building, online game, free game, puzzle game, skill game, three.js game">
    <meta name="author" content="Claude Opus 4.1 prompted by Tobias MÃ¼ller">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:title" content="Stack Tower - 3D Block Stacking Game">
    <meta property="og:description" content="Stack blocks as high as you can in this addictive 3D tower building game. Perfect your timing and build the ultimate tower!">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_216.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/stack_tower.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="GPT Games">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Stack Tower - 3D Block Stacking Game">
    <meta name="twitter:description" content="Stack blocks as high as you can in this addictive 3D tower building game. Perfect your timing and build the ultimate tower!">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_216.webp">

    <link rel="canonical" href="https://www.gptgames.dev/games/stack_tower.html">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            user-select: none
        }

        #gameCanvas {
            display: block
        }

        .ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10
        }

        .score {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s
        }

        .score h2 {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px
        }

        .score .value {
            font-size: 32px;
            font-weight: bold;
            color: #333
        }

        .high-score {
            text-align: right
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 20
        }

        .modal h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #333
        }

        .modal p {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4)
        }

        .btn:active {
            transform: translateY(0)
        }

        .perfect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            animation: perfect 1s ease-out forwards;
            display: none;
            z-index: 15
        }

        @keyframes perfect {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1
            }
            100% {
                transform: translate(-50%, -50%) translateY(-50px) scale(1);
                opacity: 0
            }
        }

        .combo {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            display: none;
            animation: combo 2s ease-out forwards;
            z-index: 15
        }

        @keyframes combo {
            0% {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0
            }
            20% {
                transform: translateX(-50%) translateY(0);
                opacity: 1
            }
            80% {
                transform: translateX(-50%) translateY(0);
                opacity: 1
            }
            100% {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0
            }
        }

        .instruction {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            opacity: 0.9;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3)
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div class="ui">
    <div class="score current-score"><h2>Score</h2>
        <div class="value">0</div>
    </div>
    <div class="score high-score"><h2>Best</h2>
        <div class="value">0</div>
    </div>
</div>
<div class="modal" id="startScreen">
    <h1>STACK TOWER</h1>
    <p>Stack the blocks as high as you can!</p>
    <button class="btn" onclick="game.start()">START GAME</button>
</div>
<div class="modal" id="gameOver" style="display:none">
    <h1>Game Over!</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button class="btn" onclick="game.restart()">PLAY AGAIN</button
</div>
<div class="perfect" id="perfectText">PERFECT!</div>
<div class="combo" id="comboText">Combo x<span id="comboCount">2</span></div>
<div class="instruction" id="instruction" style="display:none">Click or tap to place the block</div>
<script>
    const game = {
        animating: false,
        scene: null,
        camera: null,
        renderer: null,
        world: null,
        stack: [],
        overhangs: [],
        gameState: 'menu', // menu, playing, over
        boxHeight: 1,
        currentPosition: 0,
        currentBlock: null,
        speed: 0.05,
        direction: 1,
        colorIndex: 0,
        combo: 0,
        score: 0,
        colors: [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf7dc6f, 0xbb8fce, 0x85c88a, 0xf8b500, 0x6c5ce7],

        init() {
            this.setupThree();
            this.loadHighScore();
            this.setupEventListeners();
        },

        setupThree() {
// Scene
            this.scene = new THREE.Scene();
            this.scene.fog = new THREE.Fog(0xf0f4f7, 10, 100);

// Camera
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;
            const size = 10;
            this.camera = new THREE.OrthographicCamera(
                -size * aspect, size * aspect,
                size, -size,
                -100, 100
            );
            this.camera.position.set(20, 20, 20);
            this.camera.lookAt(0, 0, 0);

// Renderer
            this.renderer = new THREE.WebGLRenderer({antialias: true});
            this.renderer.setSize(width, height);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.domElement.id = 'gameCanvas';
            document.body.appendChild(this.renderer.domElement);

// Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 0);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            const d = 30;
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 100;
            this.scene.add(dirLight);
        },

        setupEventListeners() {
            window.addEventListener('resize', () => this.onResize());
            window.addEventListener('click', (e) => this.onClick(e));
            window.addEventListener('touchstart', (e) => this.onTouch(e), {passive: false});
            window.addEventListener('keydown', (e) => {
                if (e.key === ' ' && this.gameState === 'playing') {
                    e.preventDefault();
                    this.placeBlock();
                }
            });
        },

        start() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('instruction').style.display = 'block';
            this.gameState = 'playing';
            this.stack = [];
            this.overhangs = [];
            this.currentPosition = 0;
            this.colorIndex = 0;
            this.combo = 0;
            this.score = 0;
            this.speed = 0.05;
            this.direction = 1;
            this.updateScore(0);

// Clear scene
            while (this.scene.children.find(child => child.type === 'Mesh')) {
                const mesh = this.scene.children.find(child => child.type === 'Mesh');
                this.scene.remove(mesh);
            }

// Add base
            this.addStaticBlock(0, 0, 3, 3);
            this.world = this.stack[0];

// Add first moving block
            this.addCurrentBlock();

// Start animation
            if (!this.animating) {
                this.animating = true;
                this.animate();
            }
        },

        restart() {
            document.getElementById('gameOver').style.display = 'none';
            this.start();
        },

        addStaticBlock(x, z, width, depth) {
            const color = this.colors[this.colorIndex % this.colors.length];
            const geometry = new THREE.BoxGeometry(width, this.boxHeight, depth);
            const material = new THREE.MeshLambertMaterial({color});
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, this.currentPosition, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            this.scene.add(mesh);

            this.stack.push({
                x: x,
                z: z,
                width: width,
                depth: depth,
                mesh: mesh
            });
        },

        addCurrentBlock() {
            const lastBlock = this.stack[this.stack.length - 1];
            const direction = this.stack.length % 2 === 0 ? 'x' : 'z';

            this.colorIndex++;
            const color = this.colors[this.colorIndex % this.colors.length];
            const geometry = new THREE.BoxGeometry(
                lastBlock.width,
                this.boxHeight,
                lastBlock.depth
            );
            const material = new THREE.MeshLambertMaterial({color});
            const mesh = new THREE.Mesh(geometry, material);

            this.currentPosition += this.boxHeight;

            if (direction === 'x') {
                mesh.position.set(-10, this.currentPosition, lastBlock.z);
            } else {
                mesh.position.set(lastBlock.x, this.currentPosition, -10);
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            this.scene.add(mesh);

            this.currentBlock = {
                mesh: mesh,
                width: lastBlock.width,
                depth: lastBlock.depth,
                direction: direction,
                x: mesh.position.x,
                z: mesh.position.z
            };

// Speed increase every 5 blocks
            // In addCurrentBlock(), right before the speed increase check:
            console.log('addCurrentBlock called, stack length:', this.stack.length, 'current speed:', this.speed);
            if (this.stack.length % 5 === 0) {
                console.log('SPEED INCREASE TRIGGERED!');
                this.speed = Math.min(this.speed * 1.2, 0.1);
            }
        },

        placeBlock() {
            if (!this.currentBlock || this.gameState !== 'playing') return;

            const lastBlock = this.stack[this.stack.length - 1];
            const direction = this.currentBlock.direction;
            const delta = this.currentBlock.mesh.position[direction] - lastBlock[direction];
            const size = direction === 'x' ? this.currentBlock.width : this.currentBlock.depth;
            const overlap = size - Math.abs(delta);

            if (overlap > 0) {
// Perfect placement bonus
                const perfectThreshold = 0.1;
                let isPerfect = false;

                if (Math.abs(delta) < perfectThreshold) {
// Perfect placement
                    this.currentBlock.mesh.position[direction] = lastBlock[direction];
                    this.combo++;
                    isPerfect = true;
                    this.showPerfect();
                    if (this.combo > 1) {
                        this.showCombo();
                    }
                } else {
// Cut the block
                    const newSize = overlap;
                    const newPosition = lastBlock[direction] + (delta / 2);

// Update current block
                    if (direction === 'x') {
                        this.currentBlock.width = newSize;
                        this.currentBlock.mesh.scale.x = newSize / this.currentBlock.width;
                        this.currentBlock.mesh.position.x = newPosition;
                        this.currentBlock.x = newPosition;
                    } else {
                        this.currentBlock.depth = newSize;
                        this.currentBlock.mesh.scale.z = newSize / this.currentBlock.depth;
                        this.currentBlock.mesh.position.z = newPosition;
                        this.currentBlock.z = newPosition;
                    }

// Update geometry for accurate physics
                    const newGeometry = new THREE.BoxGeometry(
                        direction === 'x' ? newSize : this.currentBlock.width,
                        this.boxHeight,
                        direction === 'z' ? newSize : this.currentBlock.depth
                    );
                    this.currentBlock.mesh.geometry.dispose();
                    this.currentBlock.mesh.geometry = newGeometry;

// Create overhang
                    const overhangSize = size - overlap;
                    const overhangPosition = lastBlock[direction] +
                        (delta > 0 ? size / 2 + overhangSize / 2 : -(size / 2 + overhangSize / 2));

                    this.createOverhang(
                        direction === 'x' ? overhangPosition : this.currentBlock.x,
                        direction === 'z' ? overhangPosition : this.currentBlock.z,
                        direction === 'x' ? overhangSize : this.currentBlock.width,
                        direction === 'z' ? overhangSize : this.currentBlock.depth
                    );

                    this.combo = 0;
                }

// Add to stack
                this.stack.push({
                    x: this.currentBlock.mesh.position.x,
                    z: this.currentBlock.mesh.position.z,
                    width: this.currentBlock.width,
                    depth: this.currentBlock.depth,
                    mesh: this.currentBlock.mesh
                });

// Update score
                this.score = this.stack.length - 1;
                this.updateScore(this.score);

// Move camera up
                if (this.currentPosition > 5) {
                    this.moveCamera();
                }

// Add next block
                this.currentBlock = null;
                this.addCurrentBlock();
            } else {
// Game over - missed completely
                this.createOverhang(
                    this.currentBlock.mesh.position.x,
                    this.currentBlock.mesh.position.z,
                    this.currentBlock.width,
                    this.currentBlock.depth
                );
                this.endGame();
            }
        },

        createOverhang(x, z, width, depth) {
            const color = this.colors[this.colorIndex % this.colors.length];
            const geometry = new THREE.BoxGeometry(width, this.boxHeight, depth);
            const material = new THREE.MeshLambertMaterial({color});
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, this.currentPosition, z);
            mesh.castShadow = true;
            this.scene.add(mesh);

// Add physics
            this.overhangs.push({
                mesh: mesh,
                velocityY: 0,
                rotationSpeed: Math.random() * 0.02 - 0.01
            });
        },

        updateOverhangs() {
            for (let i = this.overhangs.length - 1; i >= 0; i--) {
                const overhang = this.overhangs[i];
                overhang.velocityY -= 0.01;
                overhang.mesh.position.y += overhang.velocityY;
                overhang.mesh.rotation.x += overhang.rotationSpeed;
                overhang.mesh.rotation.z += overhang.rotationSpeed;

                if (overhang.mesh.position.y < -30) {
                    this.scene.remove(overhang.mesh);
                    this.overhangs.splice(i, 1);
                }
            }
        },

        moveCamera() {
            const targetY = this.currentPosition + 2;
            const newCameraY = this.camera.position.y + (targetY - this.camera.position.y) * 0.1;
            this.camera.position.y = newCameraY;
            this.camera.lookAt(0, this.currentPosition - 2, 0);
        },

        animate() {
            if (this.gameState !== 'playing') {
                this.updateOverhangs();
                this.renderer.render(this.scene, this.camera);
                if (this.gameState === 'over') {
                    requestAnimationFrame(() => this.animate());
                }
                return;
            }

// Move current block
            if (this.currentBlock) {
                const speed = this.speed;
                if (this.currentBlock.direction === 'x') {
                    this.currentBlock.mesh.position.x += speed * this.direction;
                    if (Math.abs(this.currentBlock.mesh.position.x) > 10) {
                        this.direction *= -1;
                    }
                } else {
                    this.currentBlock.mesh.position.z += speed * this.direction;
                    if (Math.abs(this.currentBlock.mesh.position.z) > 10) {
                        this.direction *= -1;
                    }
                }
            }

            this.updateOverhangs();
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(() => this.animate());
        },

        endGame() {
            this.gameState = 'over';
            document.getElementById('instruction').style.display = 'none';
            document.getElementById('finalScore').textContent = this.score;
            document.getElementById('gameOver').style.display = 'block';

// Update high score
            const highScore = parseInt(localStorage.getItem('stackHighScore') || '0');
            if (this.score > highScore) {
                localStorage.setItem('stackHighScore', this.score.toString());
                this.loadHighScore();
            }
        },

        updateScore(score) {
            document.querySelector('.current-score .value').textContent = score;
        },

        loadHighScore() {
            const highScore = localStorage.getItem('stackHighScore') || '0';
            document.querySelector('.high-score .value').textContent = highScore;
        },

        showPerfect() {
            const element = document.getElementById('perfectText');
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 1000);
        },

        showCombo() {
            document.getElementById('comboCount').textContent = this.combo;
            const element = document.getElementById('comboText');
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 2000);
        },

        onClick(e) {
            if (e.target.tagName === 'BUTTON') return;
            if (this.gameState === 'playing') {
                this.placeBlock();
            }
        },

        onTouch(e) {
            if (e.target.tagName === 'BUTTON') return;
            if (this.gameState === 'playing') {
                e.preventDefault();
                this.placeBlock();
            }
        },

        onResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;
            const size = 10;

            this.camera.left = -size * aspect;
            this.camera.right = size * aspect;
            this.camera.top = size;
            this.camera.bottom = -size;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(width, height);
        }
    };

    // Initialize game
    game.init();
</script>
<script src="../logo.js"></script>
</body>
</html>