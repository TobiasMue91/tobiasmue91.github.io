<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stack Tower - 3D Block Stacking Game</title>
    <meta name="description" content="Play Stack Tower, an addictive 3D block stacking game. Stack blocks as high as possible with perfect timing. Features beautiful 3D graphics, combo system, and increasing difficulty.">
    <meta name="keywords" content="stack tower, block stacking game, 3d game, tower building, online game, free game, puzzle game, skill game, three.js game">
    <meta name="author" content="Claude Opus 4.1 prompted by Tobias MÃ¼ller">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:title" content="Stack Tower - 3D Block Stacking Game">
    <meta property="og:description" content="Stack blocks as high as you can in this addictive 3D tower building game. Perfect your timing and build the ultimate tower!">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_216.webp">
    <meta property="og:url" content="https://www.gptgames.dev/games/stack_tower.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="GPT Games">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Stack Tower - 3D Block Stacking Game">
    <meta name="twitter:description" content="Stack blocks as high as you can in this addictive 3D tower building game. Perfect your timing and build the ultimate tower!">
    <meta name="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_216.webp">

    <link rel="canonical" href="https://www.gptgames.dev/games/stack_tower.html">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            user-select: none
        }

        #gameCanvas {
            display: block
        }

        .ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10
        }

        .score {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s
        }

        .score h2 {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px
        }

        .score .value {
            font-size: 32px;
            font-weight: bold;
            color: #333
        }

        .high-score {
            text-align: right
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 20
        }

        .modal h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #333
        }

        .modal p {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px
        }

        .btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.4)
        }

        .btn:active {
            transform: translateY(0)
        }

        .perfect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 900;
            color: #fbbf24;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
            pointer-events: none;
            opacity: 0;
            z-index: 15;
            letter-spacing: 4px
        }

        .perfect.show {
            animation: perfectPop 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards
        }

        @keyframes perfectPop {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 0
            }
            30% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1
            }
            50% {
                transform: translate(-50%, -50%) scale(0.95);
                opacity: 1
            }
            70% {
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 1
            }
            100% {
                transform: translate(-50%, -50%) translateY(-60px) scale(1);
                opacity: 0
            }
        }

        .combo {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: #ec4899;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            opacity: 0;
            z-index: 15
        }

        .combo.show {
            animation: comboSlide 1.5s ease-out forwards
        }

        @keyframes comboSlide {
            0% {
                transform: translateX(-50%) translateY(-20px) scale(0.8);
                opacity: 0
            }
            20% {
                transform: translateX(-50%) translateY(0) scale(1.1);
                opacity: 1
            }
            30% {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 1
            }
            80% {
                transform: translateX(-50%) translateY(0);
                opacity: 1
            }
            100% {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0
            }
        }

        .instruction {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            opacity: 0.9;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3)
        }

        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fbbf24;
            opacity: 0;
            pointer-events: none;
            z-index: 5
        }

        .screen-flash.flash {
            animation: flashPulse 0.15s ease-out
        }

        @keyframes flashPulse {
            0% { opacity: 0.3 }
            100% { opacity: 0 }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div class="screen-flash" id="screenFlash"></div>
<div class="ui">
    <div class="score current-score"><h2>Score</h2>
        <div class="value">0</div>
    </div>
    <div class="score high-score"><h2>Best</h2>
        <div class="value">0</div>
    </div>
</div>
<div class="modal" id="startScreen">
    <h1>STACK TOWER</h1>
    <p>Stack the blocks as high as you can!</p>
    <button class="btn" onclick="game.start()">START GAME</button>
</div>
<div class="modal" id="gameOver" style="display:none">
    <h1>Game Over!</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button class="btn" onclick="game.restart()">PLAY AGAIN</button>
</div>
<div class="perfect" id="perfectText">PERFECT!</div>
<div class="combo" id="comboText">Combo x<span id="comboCount">2</span></div>
<div class="instruction" id="instruction" style="display:none">Click or tap to place the block</div>
<script>
// ============================================================================
// AUDIO MANAGER - Web Audio API sound effects
// ============================================================================
const AudioManager = {
    ctx: null,
    enabled: true,

    /** Initializes the audio context on first user interaction */
    init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },

    /** Plays a sound effect by name */
    play(sound) {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        switch(sound) {
            case 'place': this.playPlace(); break;
            case 'perfect': this.playPerfect(); break;
            case 'combo': this.playCombo(); break;
            case 'gameOver': this.playGameOver(); break;
            case 'cut': this.playCut(); break;
        }
    },

    playPlace() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(220, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },

    playPerfect() {
        const notes = [523, 659, 784]; // C5, E5, G5 - major chord arpeggio
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime + i * 0.05);
            gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.05);
            gain.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + i * 0.05 + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + i * 0.05 + 0.3);
            osc.start(this.ctx.currentTime + i * 0.05);
            osc.stop(this.ctx.currentTime + i * 0.05 + 0.3);
        });
    },

    playCombo() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(880, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1760, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    },

    playGameOver() {
        const notes = [392, 349, 330, 262]; // G4, F4, E4, C4 - descending
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime + i * 0.15);
            gain.gain.setValueAtTime(0.15, this.ctx.currentTime + i * 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + i * 0.15 + 0.3);
            osc.start(this.ctx.currentTime + i * 0.15);
            osc.stop(this.ctx.currentTime + i * 0.15 + 0.3);
        });
    },

    playCut() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.08);
        gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }
};

// ============================================================================
// PARTICLE SYSTEM - Visual effects for block cutting
// ============================================================================
const ParticleSystem = {
    particles: [],
    scene: null,

    /** Initializes the particle system with a Three.js scene */
    init(scene) {
        this.scene = scene;
    },

    /** Creates particle burst at specified position with given color */
    burst(x, y, z, color, count = 8) {
        const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        const material = new THREE.MeshLambertMaterial({ color });

        for (let i = 0; i < count; i++) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            this.scene.add(mesh);

            this.particles.push({
                mesh,
                velocity: {
                    x: (Math.random() - 0.5) * 0.3,
                    y: Math.random() * 0.15 + 0.05,
                    z: (Math.random() - 0.5) * 0.3
                },
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.2,
                    z: (Math.random() - 0.5) * 0.2
                },
                life: 1.0
            });
        }
    },

    /** Updates all particles each frame */
    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.velocity.y -= 0.008;
            p.mesh.position.x += p.velocity.x;
            p.mesh.position.y += p.velocity.y;
            p.mesh.position.z += p.velocity.z;
            p.mesh.rotation.x += p.rotationSpeed.x;
            p.mesh.rotation.z += p.rotationSpeed.z;
            p.life -= 0.025;
            p.mesh.scale.setScalar(p.life);

            if (p.life <= 0) {
                this.scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                this.particles.splice(i, 1);
            }
        }
    },

    /** Clears all particles from the scene */
    clear() {
        for (const p of this.particles) {
            this.scene.remove(p.mesh);
            p.mesh.geometry.dispose();
        }
        this.particles = [];
    }
};

// ============================================================================
// SCREEN EFFECTS - Shake and flash
// ============================================================================
const ScreenEffects = {
    shakeIntensity: 0,
    shakeDecay: 0.9,
    originalCameraPos: null,
    camera: null,

    /** Initializes screen effects with camera reference */
    init(camera) {
        this.camera = camera;
        this.originalCameraPos = camera.position.clone();
    },

    /** Triggers screen shake with specified intensity */
    shake(intensity = 0.3) {
        this.shakeIntensity = intensity;
    },

    /** Triggers screen flash effect */
    flash() {
        const el = document.getElementById('screenFlash');
        el.classList.remove('flash');
        void el.offsetWidth; // Force reflow
        el.classList.add('flash');
    },

    /** Updates shake effect each frame */
    update() {
        if (this.shakeIntensity > 0.01) {
            const offsetX = (Math.random() - 0.5) * this.shakeIntensity;
            const offsetZ = (Math.random() - 0.5) * this.shakeIntensity;
            this.camera.position.x = this.originalCameraPos.x + offsetX;
            this.camera.position.z = this.originalCameraPos.z + offsetZ;
            this.shakeIntensity *= this.shakeDecay;
        } else {
            this.camera.position.x = this.originalCameraPos.x;
            this.camera.position.z = this.originalCameraPos.z;
            this.shakeIntensity = 0;
        }
    },

    /** Updates base camera Y position for shake calculations */
    updateBaseY(y) {
        this.originalCameraPos.y = y;
    }
};

// ============================================================================
// MAIN GAME
// ============================================================================
const game = {
    animating: false,
    scene: null,
    camera: null,
    renderer: null,
    world: null,
    stack: [],
    overhangs: [],
    gameState: 'menu',
    boxHeight: 1,
    currentPosition: 0,
    currentBlock: null,
    speed: 0.05,
    direction: 1,
    colorIndex: 0,
    combo: 0,
    score: 0,
    time: 0,
    landingBlocks: [],
    // Cohesive color palette - warm to cool progression
    colors: [
        0xef4444, // Red
        0xf97316, // Orange
        0xeab308, // Yellow
        0x22c55e, // Green
        0x14b8a6, // Teal
        0x3b82f6, // Blue
        0x8b5cf6, // Violet
        0xec4899  // Pink
    ],

    /** Initializes the game */
    init() {
        this.setupThree();
        this.loadHighScore();
        this.setupEventListeners();
        ParticleSystem.init(this.scene);
        ScreenEffects.init(this.camera);
    },

    setupThree() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a2e);
        this.scene.fog = new THREE.Fog(0x1a1a2e, 15, 60);

        // Camera
        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspect = width / height;
        const size = 10;
        this.camera = new THREE.OrthographicCamera(
            -size * aspect, size * aspect,
            size, -size,
            -100, 100
        );
        this.camera.position.set(20, 20, 20);
        this.camera.lookAt(0, 0, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.domElement.id = 'gameCanvas';
        document.body.appendChild(this.renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 0);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 30;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 100;
        this.scene.add(dirLight);
    },

    setupEventListeners() {
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('click', (e) => this.onClick(e));
        window.addEventListener('touchstart', (e) => this.onTouch(e), { passive: false });
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ' && this.gameState === 'playing') {
                e.preventDefault();
                this.placeBlock();
            }
        });
    },

    /** Starts a new game */
    start() {
        AudioManager.init();
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('instruction').style.display = 'block';
        this.gameState = 'playing';
        this.stack = [];
        this.overhangs = [];
        this.landingBlocks = [];
        this.currentPosition = 0;
        this.colorIndex = 0;
        this.combo = 0;
        this.score = 0;
        this.speed = 0.05;
        this.direction = 1;
        this.time = 0;
        this.updateScore(0);

        // Clear scene
        const meshesToRemove = this.scene.children.filter(child => child.type === 'Mesh');
        meshesToRemove.forEach(mesh => this.scene.remove(mesh));
        ParticleSystem.clear();

        // Reset camera
        this.camera.position.set(20, 20, 20);
        this.camera.lookAt(0, 0, 0);
        ScreenEffects.init(this.camera);

        // Add base
        this.addStaticBlock(0, 0, 3, 3);
        this.world = this.stack[0];

        // Add first moving block
        this.addCurrentBlock();

        // Start animation
        if (!this.animating) {
            this.animating = true;
            this.animate();
        }
    },

    /** Restarts the game */
    restart() {
        document.getElementById('gameOver').style.display = 'none';
        this.start();
    },

    addStaticBlock(x, z, width, depth) {
        const color = this.colors[this.colorIndex % this.colors.length];
        const geometry = new THREE.BoxGeometry(width, this.boxHeight, depth);
        const material = new THREE.MeshLambertMaterial({ color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, this.currentPosition, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        this.scene.add(mesh);

        this.stack.push({
            x,
            z,
            width,
            depth,
            mesh
        });
    },

    addCurrentBlock() {
        const lastBlock = this.stack[this.stack.length - 1];
        const direction = this.stack.length % 2 === 0 ? 'x' : 'z';

        this.colorIndex++;
        const color = this.colors[this.colorIndex % this.colors.length];
        const geometry = new THREE.BoxGeometry(
            lastBlock.width,
            this.boxHeight,
            lastBlock.depth
        );
        const material = new THREE.MeshLambertMaterial({ color });
        const mesh = new THREE.Mesh(geometry, material);

        this.currentPosition += this.boxHeight;

        if (direction === 'x') {
            mesh.position.set(-10, this.currentPosition, lastBlock.z);
        } else {
            mesh.position.set(lastBlock.x, this.currentPosition, -10);
        }

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        this.scene.add(mesh);

        this.currentBlock = {
            mesh,
            width: lastBlock.width,
            depth: lastBlock.depth,
            direction,
            x: mesh.position.x,
            z: mesh.position.z,
            floatOffset: 0
        };

        // Speed increase every 5 blocks
        if (this.stack.length % 5 === 0) {
            this.speed = Math.min(this.speed * 1.15, 0.15);
        }
    },

    /** Places the current block and handles game logic */
    placeBlock() {
        if (!this.currentBlock || this.gameState !== 'playing') return;

        const lastBlock = this.stack[this.stack.length - 1];
        const direction = this.currentBlock.direction;
        const delta = this.currentBlock.mesh.position[direction] - lastBlock[direction];
        const size = direction === 'x' ? this.currentBlock.width : this.currentBlock.depth;
        const overlap = size - Math.abs(delta);

        if (overlap > 0) {
            const perfectThreshold = 0.15;

            if (Math.abs(delta) < perfectThreshold) {
                // Perfect placement
                this.currentBlock.mesh.position[direction] = lastBlock[direction];
                this.combo++;
                this.showPerfect();
                AudioManager.play('perfect');
                ScreenEffects.flash();

                if (this.combo > 1) {
                    this.showCombo();
                    AudioManager.play('combo');
                }

                // Add landing animation
                this.addLandingBlock(this.currentBlock.mesh);
            } else {
                // Cut the block
                const newSize = overlap;
                const newPosition = lastBlock[direction] + (delta / 2);

                // Store original size for geometry replacement
                const originalWidth = this.currentBlock.width;
                const originalDepth = this.currentBlock.depth;

                // Update dimensions
                if (direction === 'x') {
                    this.currentBlock.width = newSize;
                    this.currentBlock.mesh.position.x = newPosition;
                    this.currentBlock.x = newPosition;
                } else {
                    this.currentBlock.depth = newSize;
                    this.currentBlock.mesh.position.z = newPosition;
                    this.currentBlock.z = newPosition;
                }

                // Replace geometry with new size
                const newGeometry = new THREE.BoxGeometry(
                    direction === 'x' ? newSize : originalWidth,
                    this.boxHeight,
                    direction === 'z' ? newSize : originalDepth
                );
                this.currentBlock.mesh.geometry.dispose();
                this.currentBlock.mesh.geometry = newGeometry;

                // Create overhang
                const overhangSize = size - overlap;
                const overhangPosition = lastBlock[direction] +
                    (delta > 0 ? size / 2 + overhangSize / 2 : -(size / 2 + overhangSize / 2));

                const overhangX = direction === 'x' ? overhangPosition : this.currentBlock.x;
                const overhangZ = direction === 'z' ? overhangPosition : this.currentBlock.z;
                const overhangWidth = direction === 'x' ? overhangSize : this.currentBlock.width;
                const overhangDepth = direction === 'z' ? overhangSize : this.currentBlock.depth;

                this.createOverhang(overhangX, overhangZ, overhangWidth, overhangDepth);

                // Spawn particles at cut point
                const cutX = direction === 'x' ? (newPosition + (delta > 0 ? newSize/2 : -newSize/2)) : this.currentBlock.x;
                const cutZ = direction === 'z' ? (newPosition + (delta > 0 ? newSize/2 : -newSize/2)) : this.currentBlock.z;
                ParticleSystem.burst(cutX, this.currentPosition, cutZ, this.colors[this.colorIndex % this.colors.length], 12);

                AudioManager.play('cut');
                ScreenEffects.shake(0.15);
                this.combo = 0;

                // Add landing animation
                this.addLandingBlock(this.currentBlock.mesh);
            }

            AudioManager.play('place');
            ScreenEffects.shake(0.08);

            // Add to stack
            this.stack.push({
                x: this.currentBlock.mesh.position.x,
                z: this.currentBlock.mesh.position.z,
                width: this.currentBlock.width,
                depth: this.currentBlock.depth,
                mesh: this.currentBlock.mesh
            });

            // Update score
            this.score = this.stack.length - 1;
            this.updateScore(this.score);

            // Move camera up
            if (this.currentPosition > 5) {
                this.moveCamera();
            }

            // Add next block
            this.currentBlock = null;
            this.addCurrentBlock();
        } else {
            // Game over - missed completely
            this.createOverhang(
                this.currentBlock.mesh.position.x,
                this.currentBlock.mesh.position.z,
                this.currentBlock.width,
                this.currentBlock.depth
            );
            this.endGame();
        }
    },

    addLandingBlock(mesh) {
        this.landingBlocks.push({
            mesh,
            phase: 0,
            originalScaleY: mesh.scale.y
        });
    },

    updateLandingBlocks() {
        for (let i = this.landingBlocks.length - 1; i >= 0; i--) {
            const lb = this.landingBlocks[i];
            lb.phase += 0.15;

            if (lb.phase < Math.PI) {
                // Squash and stretch
                const squash = 1 - Math.sin(lb.phase) * 0.15;
                const stretch = 1 + Math.sin(lb.phase) * 0.08;
                lb.mesh.scale.y = lb.originalScaleY * squash;
                lb.mesh.scale.x = stretch;
                lb.mesh.scale.z = stretch;
            } else {
                lb.mesh.scale.set(1, lb.originalScaleY, 1);
                this.landingBlocks.splice(i, 1);
            }
        }
    },

    createOverhang(x, z, width, depth) {
        const color = this.colors[this.colorIndex % this.colors.length];
        const geometry = new THREE.BoxGeometry(width, this.boxHeight, depth);
        const material = new THREE.MeshLambertMaterial({ color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, this.currentPosition, z);
        mesh.castShadow = true;
        this.scene.add(mesh);

        // More dramatic falling with faster rotation
        this.overhangs.push({
            mesh,
            velocityY: 0,
            velocityX: (Math.random() - 0.5) * 0.05,
            velocityZ: (Math.random() - 0.5) * 0.05,
            rotationSpeedX: (Math.random() - 0.5) * 0.08,
            rotationSpeedZ: (Math.random() - 0.5) * 0.08
        });
    },

    updateOverhangs() {
        for (let i = this.overhangs.length - 1; i >= 0; i--) {
            const overhang = this.overhangs[i];
            overhang.velocityY -= 0.015; // Faster gravity
            overhang.mesh.position.y += overhang.velocityY;
            overhang.mesh.position.x += overhang.velocityX;
            overhang.mesh.position.z += overhang.velocityZ;
            overhang.mesh.rotation.x += overhang.rotationSpeedX;
            overhang.mesh.rotation.z += overhang.rotationSpeedZ;

            // Accelerate rotation as it falls
            overhang.rotationSpeedX *= 1.01;
            overhang.rotationSpeedZ *= 1.01;

            if (overhang.mesh.position.y < -30) {
                this.scene.remove(overhang.mesh);
                overhang.mesh.geometry.dispose();
                this.overhangs.splice(i, 1);
            }
        }
    },

    moveCamera() {
        const targetY = this.currentPosition + 2;
        const newCameraY = this.camera.position.y + (targetY - this.camera.position.y) * 0.1;
        this.camera.position.y = newCameraY;
        this.camera.lookAt(0, this.currentPosition - 2, 0);
        ScreenEffects.updateBaseY(newCameraY);
    },

    animate() {
        this.time += 0.02;

        if (this.gameState !== 'playing') {
            this.updateOverhangs();
            ParticleSystem.update();
            ScreenEffects.update();
            this.renderer.render(this.scene, this.camera);
            if (this.gameState === 'over') {
                requestAnimationFrame(() => this.animate());
            }
            return;
        }

        // Move and float current block
        if (this.currentBlock) {
            const speed = this.speed;
            if (this.currentBlock.direction === 'x') {
                this.currentBlock.mesh.position.x += speed * this.direction;
                if (Math.abs(this.currentBlock.mesh.position.x) > 10) {
                    this.direction *= -1;
                }
            } else {
                this.currentBlock.mesh.position.z += speed * this.direction;
                if (Math.abs(this.currentBlock.mesh.position.z) > 10) {
                    this.direction *= -1;
                }
            }

            // Subtle floating animation
            const floatAmount = Math.sin(this.time * 3) * 0.03;
            this.currentBlock.mesh.position.y = this.currentPosition + floatAmount;
        }

        this.updateOverhangs();
        this.updateLandingBlocks();
        ParticleSystem.update();
        ScreenEffects.update();
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(() => this.animate());
    },

    endGame() {
        this.gameState = 'over';
        AudioManager.play('gameOver');
        document.getElementById('instruction').style.display = 'none';
        document.getElementById('finalScore').textContent = this.score;
        document.getElementById('gameOver').style.display = 'block';

        // Update high score
        const highScore = parseInt(localStorage.getItem('stackHighScore') || '0');
        if (this.score > highScore) {
            localStorage.setItem('stackHighScore', this.score.toString());
            this.loadHighScore();
        }
    },

    updateScore(score) {
        document.querySelector('.current-score .value').textContent = score;
    },

    loadHighScore() {
        const highScore = localStorage.getItem('stackHighScore') || '0';
        document.querySelector('.high-score .value').textContent = highScore;
    },

    showPerfect() {
        const element = document.getElementById('perfectText');
        element.classList.remove('show');
        void element.offsetWidth; // Force reflow
        element.classList.add('show');
        setTimeout(() => element.classList.remove('show'), 800);
    },

    showCombo() {
        document.getElementById('comboCount').textContent = this.combo;
        const element = document.getElementById('comboText');
        element.classList.remove('show');
        void element.offsetWidth; // Force reflow
        element.classList.add('show');
        setTimeout(() => element.classList.remove('show'), 1500);
    },

    onClick(e) {
        if (e.target.tagName === 'BUTTON') return;
        if (this.gameState === 'playing') {
            this.placeBlock();
        }
    },

    onTouch(e) {
        if (e.target.tagName === 'BUTTON') return;
        if (this.gameState === 'playing') {
            e.preventDefault();
            this.placeBlock();
        }
    },

    onResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspect = width / height;
        const size = 10;

        this.camera.left = -size * aspect;
        this.camera.right = size * aspect;
        this.camera.top = size;
        this.camera.bottom = -size;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(width, height);
    }
};

// Initialize game
game.init();
</script>
<script src="../logo.js"></script>
</body>
</html>
