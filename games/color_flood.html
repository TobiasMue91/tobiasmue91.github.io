<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Flood</title>
    <meta name="description" content="Play Color Flood - a strategic puzzle game where you flood the board with colors to turn the entire grid into a single color in as few moves as possible. Test your strategic thinking with multiple difficulty levels.">
    <meta name="keywords" content="color flood, flood fill game, puzzle game, strategy game, browser game, color strategy, free online game">
    <meta name="author" content="Claude 3.7 Sonnet prompted by Tobias MÃ¼ller">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/color_flood.html">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/color_flood.html">
    <meta property="og:title" content="Color Flood - Strategic Color Puzzle Game">
    <meta property="og:description" content="Fill the entire grid with a single color in as few moves as possible in this addictive puzzle game with multiple difficulty levels.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_183.png">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://www.gptgames.dev/games/color_flood.html">
    <meta property="twitter:title" content="Color Flood - Strategic Color Puzzle Game">
    <meta property="twitter:description" content="Fill the entire grid with a single color in as few moves as possible in this addictive puzzle game with multiple difficulty levels.">
    <meta property="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_183.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <style>
        :root {--primary:#3498db;--secondary:#2ecc71;--dark:#2c3e50;--light:#ecf0f1;--color-1:#e74c3c;--color-2:#3498db;--color-3:#2ecc71;--color-4:#f1c40f;--color-5:#9b59b6;--color-6:#e67e22;}
        * {margin:0;padding:0;box-sizing:border-box;}
        body {font-family:'Poppins',sans-serif;background-color:var(--light);color:var(--dark);min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:20px;}
        .container {max-width:600px;width:100%;margin:0 auto;}
        header {text-align:center;margin-bottom:20px;}
        h1 {color:var(--primary);margin-bottom:10px;}
        .game-info {display:flex;justify-content:space-between;margin-bottom:20px;font-size:1.2rem;}
        .grid-container {aspect-ratio:1/1;width:100%;display:grid;gap:1px;border:2px solid var(--dark);border-radius:4px;margin-bottom:20px;overflow:hidden;}
        .cell {width:100%;height:100%;transition:background-color 0.3s ease;}
        .color-palette {display:flex;justify-content:center;gap:10px;margin-bottom:20px;flex-wrap:wrap;}
        .color-option {width:40px;height:40px;border-radius:50%;cursor:pointer;transition:transform 0.2s;border:2px solid rgba(0,0,0,0.1);}
        .color-option:hover {transform:scale(1.1);}
        .controls {display:flex;justify-content:space-between;margin-bottom:20px;}
        button {background-color:var(--primary);color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-family:inherit;font-weight:500;transition:background-color 0.3s ease;}
        button:hover {background-color:#2980b9;}
        select {padding:8px;border-radius:4px;border:1px solid #ddd;font-family:inherit;}
        .modal {position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);display:flex;justify-content:center;align-items:center;z-index:1000;opacity:0;pointer-events:none;transition:opacity 0.3s ease;}
        .modal.active {opacity:1;pointer-events:all;}
        .modal-content {background-color:white;padding:20px;border-radius:8px;max-width:500px;width:90%;box-shadow:0 4px 20px rgba(0,0,0,0.2);}
        .modal-header {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;}
        .close-modal {background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--dark);}
        .win-message {text-align:center;font-size:1.2rem;margin-bottom:20px;}
        .win-stats {display:flex;justify-content:space-around;margin-bottom:20px;}
        .stat-item {text-align:center;}
        .stat-value {font-size:1.5rem;font-weight:bold;color:var(--primary);}
        @media (max-width:600px) {
            .container {padding:10px;}
            .color-option {width:35px;height:35px;}
            .controls {flex-direction:column;gap:10px;}
            .game-info {font-size:1rem;}
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Color Flood</h1>
        <p>Fill the entire grid with a single color in as few moves as possible.</p>
    </header>

    <div class="controls">
        <div>
            <select id="difficulty">
                <option value="easy">Easy (10x10, 4 colors)</option>
                <option value="medium" selected>Medium (14x14, 5 colors)</option>
                <option value="hard">Hard (18x18, 6 colors)</option>
            </select>
        </div>
        <div>
            <button id="new-game">New Game</button>
            <button id="help-btn">How to Play</button>
        </div>
    </div>

    <div class="game-info">
        <div>Moves: <span id="moves">0</span></div>
        <div>Best: <span id="best-score">-</span></div>
    </div>

    <div class="grid-container" id="grid"></div>

    <div class="color-palette" id="palette"></div>
</div>

<div class="modal" id="help-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>How to Play</h2>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <p>The goal of Color Flood is to fill the entire grid with a single color in as few moves as possible.</p>
            <ul style="padding-left:20px;margin:10px 0;">
                <li>You start from the top-left corner of the grid.</li>
                <li>Select a color from the palette to flood the connected area.</li>
                <li>The flooded area expands to include any adjacent cells of the same color.</li>
                <li>Try to fill the entire grid in as few moves as possible.</li>
            </ul>
            <p>The fewer moves you make, the better your score!</p>
        </div>
        <div style="text-align:center;margin-top:15px;">
            <button class="close-help">Got it!</button>
        </div>
    </div>
</div>

<div class="modal" id="win-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Congratulations!</h2>
            <button class="close-modal">&times;</button>
        </div>
        <div class="win-message">
            You've flooded the entire grid!
        </div>
        <div class="win-stats">
            <div class="stat-item">
                <div class="stat-value" id="final-moves">0</div>
                <div>Moves</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="best-moves">0</div>
                <div>Best</div>
            </div>
        </div>
        <div style="text-align:center;">
            <button id="play-again">Play Again</button>
        </div>
    </div>
</div>

<script>
    class ColorFlood {
        constructor() {
            this.grid = document.getElementById('grid');
            this.palette = document.getElementById('palette');
            this.movesDisplay = document.getElementById('moves');
            this.bestScoreDisplay = document.getElementById('best-score');
            this.difficultySelect = document.getElementById('difficulty');
            this.newGameBtn = document.getElementById('new-game');
            this.helpBtn = document.getElementById('help-btn');

            this.settings = {
                easy: {size:10,colors:4},
                medium: {size:14,colors:5},
                hard: {size:18,colors:6}
            };
            this.colorMap = ['var(--color-1)','var(--color-2)','var(--color-3)','var(--color-4)','var(--color-5)','var(--color-6)'];
            this.gridData = [];
            this.gridSize = 0;
            this.colorCount = 0;
            this.moves = 0;
            this.bestScores = this.loadBestScores();

            this.initEventListeners();
            this.startNewGame();
        }

        initEventListeners() {
            this.newGameBtn.addEventListener('click', () => this.startNewGame());
            this.helpBtn.addEventListener('click', () => this.openModal('help-modal'));

            document.querySelectorAll('.close-modal, .close-help').forEach(btn => {
                btn.addEventListener('click', () => this.closeAllModals());
            });

            document.getElementById('play-again').addEventListener('click', () => {
                this.closeAllModals();
                this.startNewGame();
            });

            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) this.closeAllModals();
                });
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') this.closeAllModals();
            });
        }

        openModal(modalId) {
            this.closeAllModals();
            document.getElementById(modalId).classList.add('active');
        }

        closeAllModals() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('active');
            });
        }

        loadBestScores() {
            const savedScores = localStorage.getItem('colorFloodBestScores');
            return savedScores ? JSON.parse(savedScores) : {easy:Infinity,medium:Infinity,hard:Infinity};
        }

        saveBestScore(difficulty, score) {
            if (!this.bestScores[difficulty] || score < this.bestScores[difficulty]) {
                this.bestScores[difficulty] = score;
                localStorage.setItem('colorFloodBestScores', JSON.stringify(this.bestScores));
            }
            this.updateBestScoreDisplay();
        }

        updateBestScoreDisplay() {
            const difficulty = this.difficultySelect.value;
            const bestScore = this.bestScores[difficulty];
            this.bestScoreDisplay.textContent = bestScore === Infinity ? '-' : bestScore;
        }

        startNewGame() {
            const difficulty = this.difficultySelect.value;
            this.gridSize = this.settings[difficulty].size;
            this.colorCount = this.settings[difficulty].colors;
            this.moves = 0;
            this.movesDisplay.textContent = '0';
            this.updateBestScoreDisplay();

            this.initGrid();
            this.renderGrid();
            this.createColorPalette();
        }

        initGrid() {
            this.gridData = [];
            for (let row = 0; row < this.gridSize; row++) {
                const rowData = [];
                for (let col = 0; col < this.gridSize; col++) {
                    const colorIndex = Math.floor(Math.random() * this.colorCount);
                    rowData.push(colorIndex);
                }
                this.gridData.push(rowData);
            }
        }

        renderGrid() {
            this.grid.innerHTML = '';
            this.grid.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;

            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.style.backgroundColor = this.colorMap[this.gridData[row][col]];
                    this.grid.appendChild(cell);
                }
            }
        }

        createColorPalette() {
            this.palette.innerHTML = '';

            for (let i = 0; i < this.colorCount; i++) {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = this.colorMap[i];
                colorOption.dataset.colorIndex = i;

                colorOption.addEventListener('click', () => this.makeMove(i));
                this.palette.appendChild(colorOption);
            }
        }

        makeMove(colorIndex) {
            const currentColor = this.gridData[0][0];
            if (currentColor === colorIndex) return;

            this.moves++;
            this.movesDisplay.textContent = this.moves;

            this.floodFill(0, 0, currentColor, colorIndex);
            this.renderGrid();

            if (this.checkWin()) {
                this.handleWin();
            }
        }

        floodFill(row, col, oldColorIndex, newColorIndex) {
            const stack = [[row, col]];
            const visited = new Set();

            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) continue;
                if (this.gridData[r][c] !== oldColorIndex) continue;

                this.gridData[r][c] = newColorIndex;
                visited.add(key);

                stack.push([r+1,c], [r-1,c], [r,c+1], [r,c-1]);
            }
        }

        checkWin() {
            const targetColor = this.gridData[0][0];

            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    if (this.gridData[row][col] !== targetColor) return false;
                }
            }

            return true;
        }

        handleWin() {
            const difficulty = this.difficultySelect.value;
            this.saveBestScore(difficulty, this.moves);

            document.getElementById('final-moves').textContent = this.moves;
            document.getElementById('best-moves').textContent = this.bestScores[difficulty];

            this.playWinAnimation().then(() => {
                this.openModal('win-modal');
            });
        }

        playWinAnimation() {
            return new Promise(resolve => {
                const cells = document.querySelectorAll('.cell');

                anime({
                    targets: cells,
                    scale: [
                        {value:0.8,duration:150,easing:'easeOutSine'},
                        {value:1,duration:250,easing:'easeInOutQuad'}
                    ],
                    opacity: [
                        {value:0.5,duration:150,easing:'easeOutSine'},
                        {value:1,duration:250,easing:'easeInOutQuad'}
                    ],
                    delay: anime.stagger(10, {grid:[this.gridSize,this.gridSize],from:'center'}),
                    complete: resolve
                });
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const game = new ColorFlood();
    });
</script>
<script src="../logo.js"></script>
</body>
</html>