<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Flood</title>
    <meta name="description" content="Play Color Flood - a strategic puzzle game where you flood the board with colors to turn the entire grid into a single color in as few moves as possible. Test your strategic thinking with multiple difficulty levels.">
    <meta name="keywords" content="color flood, flood fill game, puzzle game, strategy game, browser game, color strategy, free online game">
    <meta name="author" content="Claude 3.7 Sonnet prompted by Tobias Müller">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://www.gptgames.dev/games/color_flood.html">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.gptgames.dev/games/color_flood.html">
    <meta property="og:title" content="Color Flood - Strategic Color Puzzle Game">
    <meta property="og:description" content="Fill the entire grid with a single color in as few moves as possible in this addictive puzzle game with multiple difficulty levels.">
    <meta property="og:image" content="https://www.gptgames.dev/screenshots/screenshot_183.png">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://www.gptgames.dev/games/color_flood.html">
    <meta property="twitter:title" content="Color Flood - Strategic Color Puzzle Game">
    <meta property="twitter:description" content="Fill the entire grid with a single color in as few moves as possible in this addictive puzzle game with multiple difficulty levels.">
    <meta property="twitter:image" content="https://www.gptgames.dev/screenshots/screenshot_183.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <style>
        :root {
            /* Main Colors */
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #4cc9f0;
            --accent: #f72585;
            --success: #06d6a0;
            --warning: #ffd166;
            --danger: #ef476f;
            --dark: #2b2d42;
            --medium: #8d99ae;
            --light: #edf2f4;
            --white: #ffffff;

            /* Game Colors */
            --color-1: #ef476f;  /* Red */
            --color-2: #4cc9f0;  /* Blue */
            --color-3: #06d6a0;  /* Green */
            --color-4: #ffd166;  /* Yellow */
            --color-5: #9381ff;  /* Purple */
            --color-6: #f8961e;  /* Orange */

            /* UI Elements */
            --background: var(--light);
            --card-bg: var(--white);
            --text: var(--dark);
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
            --transition: all 0.3s ease;

            /* Typography */
            --font-main: 'Poppins', sans-serif;
        }

        [data-theme="dark"] {
            --background: #121212;
            --card-bg: #1e1e1e;
            --text: #edf2f4;
            --medium: #a0a9b8;
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--background);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            transition: var(--transition);
        }

        .container {
            max-width: 600px;
            width: 100%;
            margin: 0 auto;
        }

        .game-card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.4rem;
            font-weight: 700;
        }

        .subtitle {
            color: var(--medium);
            font-size: 1rem;
            max-width: 80%;
        }

        .controls-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-group {
            display: flex;
            gap: 8px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-radius: var(--border-radius);
            background-color: rgba(0, 0, 0, 0.03);
            padding: 10px 15px;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .info-value {
            font-weight: 600;
            color: var(--primary);
        }

        .progress-container {
            height: 6px;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .grid-container-wrapper {
            position: relative;
            aspect-ratio: 1/1;
            width: 100%;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            gap: 1px;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .cell {
            width: 100%;
            height: 100%;
            transition: background-color 0.3s ease;
        }

        .hint-cell {
            position: relative;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .color-palette {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .color-option {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 3px solid transparent;
            position: relative;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .color-option.active {
            border-color: var(--white);
            box-shadow: 0 0 0 2px var(--primary);
        }

        .color-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .keyboard-shortcut {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background-color: var(--dark);
            color: var(--white);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background-color: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        button.secondary:hover {
            background-color: rgba(67, 97, 238, 0.1);
        }

        button.icon-only {
            padding: 8px;
            border-radius: 50%;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        select {
            padding: 8px 12px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-family: inherit;
            background-color: var(--card-bg);
            color: var(--text);
            cursor: pointer;
            transition: var(--transition);
        }

        select:hover {
            border-color: var(--primary);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 25px;
            border-radius: var(--border-radius);
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text);
            padding: 0;
            margin: 0;
            line-height: 1;
        }

        .win-message {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .win-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group h3 {
            margin-bottom: 10px;
            color: var(--primary);
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        .achievement {
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: var(--border-radius);
            padding: 10px 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .achievement.unlocked {
            background-color: rgba(6, 214, 160, 0.1);
        }

        .achievement-info {
            display: flex;
            flex-direction: column;
        }

        .achievement-title {
            font-weight: 600;
        }

        .achievement-desc {
            font-size: 0.8rem;
            color: var(--medium);
        }

        .achievement-icon {
            font-size: 1.5rem;
            color: var(--medium);
        }

        .achievement.unlocked .achievement-icon {
            color: var(--success);
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-icon {
            font-size: 1.5rem;
            color: var(--primary);
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .theme-toggle:hover {
            transform: rotate(30deg);
        }

        .stats-value {
            font-weight: 600;
            color: var(--primary);
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            color: var(--medium);
            font-size: 0.8rem;
        }

        .footer a {
            color: var(--primary);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .hidden {
            display: none !important;
        }

        /* Responsive styles */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            .game-card {
                padding: 15px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 0.9rem;
                max-width: 100%;
            }

            .controls-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: space-between;
            }

            .color-option {
                width: 40px;
                height: 40px;
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .keyboard-shortcut {
                font-size: 8px;
                width: 16px;
                height: 16px;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .fade-in {
            animation: fadeIn 0.3s ease forwards;
        }

        .slide-in-up {
            animation: slideInUp 0.3s ease forwards;
        }
    </style>
</head>
<body>
<button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark/light mode">
    <i class="bi bi-moon-fill"></i>
</button>

<div class="container">
    <header>
        <h1>Color Flood</h1>
        <p class="subtitle">Fill the grid with a single color in as few moves as possible</p>
    </header>

    <div class="game-card">
        <div class="controls-panel">
            <div class="control-group">
                <select id="difficulty" aria-label="Select difficulty">
                    <option value="easy">Easy (10×10, 4 colors)</option>
                    <option value="medium" selected>Medium (14×14, 5 colors)</option>
                    <option value="hard">Hard (18×18, 6 colors)</option>
                </select>
                <button id="new-game" class="secondary">
                    <i class="bi bi-plus-circle"></i> New Game
                </button>
            </div>
            <div class="control-group">
                <button id="undo-btn" class="icon-only secondary" disabled aria-label="Undo move">
                    <i class="bi bi-arrow-counterclockwise"></i>
                </button>
                <button id="hint-btn" class="icon-only secondary" aria-label="Get hint">
                    <i class="bi bi-lightbulb"></i>
                </button>
                <button id="settings-btn" class="icon-only secondary" aria-label="Settings">
                    <i class="bi bi-gear"></i>
                </button>
                <button id="help-btn" class="icon-only secondary" aria-label="How to play">
                    <i class="bi bi-question-circle"></i>
                </button>
            </div>
        </div>

        <div class="game-info">
            <div class="info-item">
                <i class="bi bi-layers"></i>
                Moves: <span id="moves" class="info-value">0</span>
            </div>
            <div class="info-item">
                <i class="bi bi-trophy"></i>
                Best: <span id="best-score" class="info-value">-</span>
            </div>
            <div class="info-item" id="timer-display">
                <i class="bi bi-stopwatch"></i>
                Time: <span id="timer" class="info-value">0:00</span>
            </div>
        </div>

        <div class="progress-container">
            <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
        </div>

        <div class="grid-container-wrapper">
            <div class="grid-container" id="grid"></div>
        </div>

        <div class="color-palette" id="palette"></div>
    </div>
</div>

<div class="toast-container" id="toast-container"></div>

<!-- Help Modal -->
<div class="modal" id="help-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>How to Play</h2>
            <button class="close-modal" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <p>The goal of Color Flood is to fill the entire grid with a single color in as few moves as possible.</p>
            <ul style="padding-left:20px;margin:15px 0;">
                <li>You start from the top-left corner of the grid.</li>
                <li>Select a color from the palette to flood the connected area.</li>
                <li>The flooded area expands to include any adjacent cells of the same color.</li>
                <li>Try to flood the entire grid in as few moves as possible.</li>
                <li>Use keyboard numbers 1-6 to select colors quickly.</li>
            </ul>
            <p>Features:</p>
            <ul style="padding-left:20px;margin:15px 0;">
                <li><i class="bi bi-arrow-counterclockwise"></i> Undo your last moves</li>
                <li><i class="bi bi-lightbulb"></i> Get a hint if you're stuck</li>
                <li><i class="bi bi-gear"></i> Customize your game experience in settings</li>
            </ul>
            <p>The fewer moves you make, the better your score!</p>
        </div>
        <div style="text-align:center;margin-top:15px;">
            <button class="close-help">Got it!</button>
        </div>
    </div>
</div>

<!-- Win Modal -->
<div class="modal" id="win-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Congratulations!</h2>
            <button class="close-modal" aria-label="Close">&times;</button>
        </div>
        <div class="win-message">
            You've flooded the entire grid!
        </div>
        <div class="win-stats">
            <div class="stat-item">
                <div class="stat-value" id="final-moves">0</div>
                <div>Moves</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="final-time">0:00</div>
                <div>Time</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="best-moves">0</div>
                <div>Best</div>
            </div>
        </div>
        <div style="text-align:center;">
            <button id="play-again">Play Again</button>
            <button id="share-result" class="secondary">
                <i class="bi bi-share"></i> Share
            </button>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal" id="settings-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Settings</h2>
            <button class="close-modal" aria-label="Close">&times;</button>
        </div>
        <div class="settings-group">
            <h3>Game</h3>
            <div class="settings-row">
                <span>Show Timer</span>
                <label class="switch">
                    <input type="checkbox" id="show-timer" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-row">
                <span>Sound Effects</span>
                <label class="switch">
                    <input type="checkbox" id="sound-effects" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-row">
                <span>Keyboard Shortcuts</span>
                <label class="switch">
                    <input type="checkbox" id="keyboard-shortcuts" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <div class="settings-group">
            <h3>Statistics</h3>
            <div class="settings-row">
                <span>Games Played</span>
                <span id="stats-games" class="stats-value">0</span>
            </div>
            <div class="settings-row">
                <span>Games Won</span>
                <span id="stats-wins" class="stats-value">0</span>
            </div>
            <div class="settings-row">
                <span>Best Game (Easy)</span>
                <span id="stats-best-easy" class="stats-value">-</span>
            </div>
            <div class="settings-row">
                <span>Best Game (Medium)</span>
                <span id="stats-best-medium" class="stats-value">-</span>
            </div>
            <div class="settings-row">
                <span>Best Game (Hard)</span>
                <span id="stats-best-hard" class="stats-value">-</span>
            </div>
        </div>
        <div style="text-align:center;margin-top:20px;">
            <button id="reset-stats" class="secondary">Reset Statistics</button>
            <button class="close-settings">Save</button>
        </div>
    </div>
</div>

<!-- Achievements Modal -->
<div class="modal" id="achievements-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Achievements</h2>
            <button class="close-modal" aria-label="Close">&times;</button>
        </div>
        <div id="achievements-container">
            <div class="achievement" data-id="first-win">
                <div class="achievement-info">
                    <div class="achievement-title">First Victory</div>
                    <div class="achievement-desc">Complete your first game</div>
                </div>
                <div class="achievement-icon">
                    <i class="bi bi-lock"></i>
                </div>
            </div>
            <div class="achievement" data-id="perfect-easy">
                <div class="achievement-info">
                    <div class="achievement-title">Efficiency Expert</div>
                    <div class="achievement-desc">Win an Easy game in 20 moves or less</div>
                </div>
                <div class="achievement-icon">
                    <i class="bi bi-lock"></i>
                </div>
            </div>
            <div class="achievement" data-id="perfect-medium">
                <div class="achievement-info">
                    <div class="achievement-title">Color Master</div>
                    <div class="achievement-desc">Win a Medium game in 30 moves or less</div>
                </div>
                <div class="achievement-icon">
                    <i class="bi bi-lock"></i>
                </div>
            </div>
            <div class="achievement" data-id="perfect-hard">
                <div class="achievement-info">
                    <div class="achievement-title">Flood Legend</div>
                    <div class="achievement-desc">Win a Hard game in 40 moves or less</div>
                </div>
                <div class="achievement-icon">
                    <i class="bi bi-lock"></i>
                </div>
            </div>
            <div class="achievement" data-id="persistent">
                <div class="achievement-info">
                    <div class="achievement-title">Persistent</div>
                    <div class="achievement-desc">Play 10 games</div>
                </div>
                <div class="achievement-icon">
                    <i class="bi bi-lock"></i>
                </div>
            </div>
        </div>
        <div style="text-align:center;margin-top:20px;">
            <button class="close-modal">Close</button>
        </div>
    </div>
</div>

<footer class="footer">
    <p>Created by <a href="https://github.com/TobiasMue91/tobiasmue91.github.io" target="_blank">GPTGames</a> &copy; 2025</p>
</footer>

<script>
    class GameState {
        constructor() {
            this.gridData = [];
            this.gridSize = 0;
            this.colorCount = 0;
            this.moves = 0;
            this.startTime = 0;
            this.elapsedTime = 0;
            this.timerInterval = null;
            this.moveHistory = [];
            this.settings = {
                showTimer: true,
                soundEffects: true,
                keyboardShortcuts: true
            };
            this.statistics = {
                gamesPlayed: 0,
                gamesWon: 0,
                bestScores: {
                    easy: Infinity,
                    medium: Infinity,
                    hard: Infinity
                }
            };
            this.achievements = {
                "first-win": false,
                "perfect-easy": false,
                "perfect-medium": false,
                "perfect-hard": false,
                "persistent": false
            };
            this.currentTheme = 'light';
            this.isGameActive = false;
            this.hintActive = false;
        }

        loadFromStorage() {
            const savedSettings = localStorage.getItem('colorFloodSettings');
            if (savedSettings) {
                this.settings = {...this.settings, ...JSON.parse(savedSettings)};
            }

            const savedStats = localStorage.getItem('colorFloodStatistics');
            if (savedStats) {
                this.statistics = {...this.statistics, ...JSON.parse(savedStats)};
            }

            const savedAchievements = localStorage.getItem('colorFloodAchievements');
            if (savedAchievements) {
                this.achievements = {...this.achievements, ...JSON.parse(savedAchievements)};
            }

            const savedTheme = localStorage.getItem('colorFloodTheme');
            if (savedTheme) {
                this.currentTheme = savedTheme;
            }
        }

        saveToStorage() {
            localStorage.setItem('colorFloodSettings', JSON.stringify(this.settings));
            localStorage.setItem('colorFloodStatistics', JSON.stringify(this.statistics));
            localStorage.setItem('colorFloodAchievements', JSON.stringify(this.achievements));
            localStorage.setItem('colorFloodTheme', this.currentTheme);
        }

        resetGame(gridSize, colorCount) {
            this.gridSize = gridSize;
            this.colorCount = colorCount;
            this.moves = 0;
            this.moveHistory = [];
            this.startTime = Date.now();
            this.elapsedTime = 0;
            this.isGameActive = true;
            this.hintActive = false;

            // Initialize grid
            this.initGrid();

            // Start timer if enabled
            if (this.settings.showTimer) {
                this.startTimer();
            }
        }

        initGrid() {
            this.gridData = [];
            for (let row = 0; row < this.gridSize; row++) {
                const rowData = [];
                for (let col = 0; col < this.gridSize; col++) {
                    const colorIndex = Math.floor(Math.random() * this.colorCount);
                    rowData.push(colorIndex);
                }
                this.gridData.push(rowData);
            }
        }

        makeMove(colorIndex) {
            const currentColor = this.gridData[0][0];
            if (currentColor === colorIndex || !this.isGameActive) return false;

            // Save current state for undo
            this.saveState();

            // Update moves count
            this.moves++;

            // Perform flood fill
            this.floodFill(0, 0, currentColor, colorIndex);

            // Check if game is won
            if (this.checkWin()) {
                this.handleWin();
            }

            return true;
        }

        saveState() {
            // Create a deep copy of the current grid
            const gridCopy = this.gridData.map(row => [...row]);
            this.moveHistory.push({
                grid: gridCopy,
                moves: this.moves
            });

            // Limit history to last 10 moves to prevent memory issues
            if (this.moveHistory.length > 10) {
                this.moveHistory.shift();
            }
        }

        undo() {
            if (this.moveHistory.length === 0 || !this.isGameActive) return false;

            const previousState = this.moveHistory.pop();
            this.gridData = previousState.grid;
            this.moves = previousState.moves;

            return true;
        }

        floodFill(row, col, oldColorIndex, newColorIndex) {
            const stack = [[row, col]];
            const visited = new Set();

            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) continue;
                if (this.gridData[r][c] !== oldColorIndex) continue;

                this.gridData[r][c] = newColorIndex;
                visited.add(key);

                stack.push([r+1,c], [r-1,c], [r,c+1], [r,c-1]);
            }

            return visited.size; // Return the number of cells changed
        }

        checkWin() {
            const targetColor = this.gridData[0][0];

            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    if (this.gridData[row][col] !== targetColor) return false;
                }
            }

            return true;
        }

        handleWin() {
            this.stopTimer();
            this.isGameActive = false;

            // Update statistics
            this.statistics.gamesWon++;

            // Update best score if current score is better
            const difficulty = this.getDifficultyName();
            if (this.moves < this.statistics.bestScores[difficulty]) {
                this.statistics.bestScores[difficulty] = this.moves;
            }

            // Check for achievements
            this.checkAchievements();

            // Save to storage
            this.saveToStorage();
        }

        startTimer() {
            this.stopTimer(); // Clear any existing timer
            this.startTime = Date.now() - this.elapsedTime;
            this.timerInterval = setInterval(() => {
                this.elapsedTime = Date.now() - this.startTime;
                UI.updateTimer(this.formatTime(this.elapsedTime));
            }, 1000);
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        getDifficultyName() {
            if (this.gridSize === 10) return 'easy';
            if (this.gridSize === 14) return 'medium';
            return 'hard';
        }

        getProgressPercentage() {
            let totalCells = this.gridSize * this.gridSize;
            let floodedColor = this.gridData[0][0];
            let floodedCount = 0;

            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    if (this.gridData[row][col] === floodedColor) {
                        floodedCount++;
                    }
                }
            }

            return Math.floor((floodedCount / totalCells) * 100);
        }

        getHint() {
            if (!this.isGameActive) return null;

            const currentColor = this.gridData[0][0];
            let bestColor = -1;
            let maxNewCells = -1;

            // Try each color and see which one would flood the most new cells
            for (let colorIndex = 0; colorIndex < this.colorCount; colorIndex++) {
                if (colorIndex === currentColor) continue;

                // Create a copy of the grid for simulation
                const gridCopy = this.gridData.map(row => [...row]);

                // Simulate the flood fill
                const newCellsCount = this.simulateFloodFill(gridCopy, 0, 0, currentColor, colorIndex);

                if (newCellsCount > maxNewCells) {
                    maxNewCells = newCellsCount;
                    bestColor = colorIndex;
                }
            }

            return bestColor;
        }

        simulateFloodFill(grid, row, col, oldColorIndex, newColorIndex) {
            const stack = [[row, col]];
            const visited = new Set();

            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) continue;
                if (grid[r][c] !== oldColorIndex) continue;

                grid[r][c] = newColorIndex;
                visited.add(key);

                stack.push([r+1,c], [r-1,c], [r,c+1], [r,c-1]);
            }

            return visited.size;
        }

        checkAchievements() {
            // First win
            if (!this.achievements["first-win"]) {
                this.achievements["first-win"] = true;
                UI.showAchievementToast("First Victory", "Completed your first game!");
            }

            // Perfect scores based on difficulty
            const difficulty = this.getDifficultyName();
            if (difficulty === 'easy' && this.moves <= 20 && !this.achievements["perfect-easy"]) {
                this.achievements["perfect-easy"] = true;
                UI.showAchievementToast("Efficiency Expert", "Won an Easy game in 20 moves or less!");
            } else if (difficulty === 'medium' && this.moves <= 30 && !this.achievements["perfect-medium"]) {
                this.achievements["perfect-medium"] = true;
                UI.showAchievementToast("Color Master", "Won a Medium game in 30 moves or less!");
            } else if (difficulty === 'hard' && this.moves <= 40 && !this.achievements["perfect-hard"]) {
                this.achievements["perfect-hard"] = true;
                UI.showAchievementToast("Flood Legend", "Won a Hard game in 40 moves or less!");
            }

            // Persistence achievement
            if (this.statistics.gamesPlayed >= 10 && !this.achievements["persistent"]) {
                this.achievements["persistent"] = true;
                UI.showAchievementToast("Persistent", "Played 10 games!");
            }
        }
    }

    class UI {
        static gameState = null;
        static colorMap = [
            'var(--color-1)',
            'var(--color-2)',
            'var(--color-3)',
            'var(--color-4)',
            'var(--color-5)',
            'var(--color-6)'
        ];

        static init(gameState) {
            this.gameState = gameState;
            this.initEventListeners();
            this.applyTheme();
            this.updateSettingsUI();
            this.updateAchievementsUI();
            this.updateStatisticsUI();
        }

        static initEventListeners() {
            // Game controls
            document.getElementById('new-game').addEventListener('click', () => this.startNewGame());
            document.getElementById('undo-btn').addEventListener('click', () => this.undoMove());
            document.getElementById('hint-btn').addEventListener('click', () => this.getHint());
            document.getElementById('help-btn').addEventListener('click', () => this.openModal('help-modal'));
            document.getElementById('settings-btn').addEventListener('click', () => this.openModal('settings-modal'));
            document.getElementById('theme-toggle').addEventListener('click', () => this.toggleTheme());

            // Difficulty selection
            document.getElementById('difficulty').addEventListener('change', () => this.startNewGame());

            // Modal controls
            document.querySelectorAll('.close-modal, .close-help, .close-settings').forEach(btn => {
                btn.addEventListener('click', () => this.closeAllModals());
            });

            document.getElementById('play-again').addEventListener('click', () => {
                this.closeAllModals();
                this.startNewGame();
            });

            document.getElementById('share-result').addEventListener('click', () => this.shareResult());

            // Settings controls
            document.getElementById('show-timer').addEventListener('change', (e) => {
                this.gameState.settings.showTimer = e.target.checked;
                this.gameState.saveToStorage();
                this.updateTimerVisibility();
            });

            document.getElementById('sound-effects').addEventListener('change', (e) => {
                this.gameState.settings.soundEffects = e.target.checked;
                this.gameState.saveToStorage();
            });

            document.getElementById('keyboard-shortcuts').addEventListener('change', (e) => {
                this.gameState.settings.keyboardShortcuts = e.target.checked;
                this.gameState.saveToStorage();
                this.updateKeyboardShortcutsVisibility();
            });

            document.getElementById('reset-stats').addEventListener('click', () => this.resetStatistics());

            // Modal backdrop close
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) this.closeAllModals();
                });
            });

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!this.gameState.settings.keyboardShortcuts) return;

                // Number keys 1-6 for color selection
                if (e.key >= '1' && e.key <= '6') {
                    const colorIndex = parseInt(e.key) - 1;
                    if (colorIndex < this.gameState.colorCount) {
                        this.makeMove(colorIndex);
                    }
                }

                // ESC to close modals
                if (e.key === 'Escape') {
                    this.closeAllModals();
                }

                // U for undo
                if (e.key === 'u' || e.key === 'U') {
                    this.undoMove();
                }

                // H for hint
                if (e.key === 'h' || e.key === 'H') {
                    this.getHint();
                }

                // N for new game
                if (e.key === 'n' || e.key === 'N') {
                    this.startNewGame();
                }
            });
        }

        static startNewGame() {
            const difficultySelect = document.getElementById('difficulty');
            const difficulty = difficultySelect.value;

            let gridSize, colorCount;

            switch (difficulty) {
                case 'easy':
                    gridSize = 10;
                    colorCount = 4;
                    break;
                case 'hard':
                    gridSize = 18;
                    colorCount = 6;
                    break;
                case 'medium':
                default:
                    gridSize = 14;
                    colorCount = 5;
                    break;
            }

            // Update game statistics
            this.gameState.statistics.gamesPlayed++;
            this.gameState.saveToStorage();

            // Reset the game
            this.gameState.resetGame(gridSize, colorCount);

            // Update UI
            this.renderGrid();
            this.createColorPalette();
            this.updateMovesDisplay();
            this.updateBestScoreDisplay();
            this.updateProgressBar();
            this.updateTimerVisibility();
            this.updateStatisticsUI();

            // Reset undo button
            document.getElementById('undo-btn').disabled = true;
        }

        static renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${this.gameState.gridSize}, 1fr)`;

            for (let row = 0; row < this.gameState.gridSize; row++) {
                for (let col = 0; col < this.gameState.gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.style.backgroundColor = this.colorMap[this.gameState.gridData[row][col]];
                    grid.appendChild(cell);
                }
            }
        }

        static createColorPalette() {
            const palette = document.getElementById('palette');
            palette.innerHTML = '';

            for (let i = 0; i < this.gameState.colorCount; i++) {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = this.colorMap[i];
                colorOption.dataset.colorIndex = i;

                // Add keyboard shortcut indicator if enabled
                if (this.gameState.settings.keyboardShortcuts) {
                    const shortcut = document.createElement('div');
                    shortcut.className = 'keyboard-shortcut';
                    shortcut.textContent = i + 1;
                    colorOption.appendChild(shortcut);
                }

                // Disable the color if it's the current color
                if (i === this.gameState.gridData[0][0]) {
                    colorOption.classList.add('disabled');
                }

                colorOption.addEventListener('click', () => this.makeMove(i));
                palette.appendChild(colorOption);
            }
        }

        static makeMove(colorIndex) {
            // Don't do anything if the color is the same as current
            if (colorIndex === this.gameState.gridData[0][0]) return;

            // Make the move in the game state
            const moveSuccessful = this.gameState.makeMove(colorIndex);

            if (moveSuccessful) {
                // Play sound if enabled
                if (this.gameState.settings.soundEffects) {
                    this.playSound('move');
                }

                // Enable undo button if this is the first move
                if (this.gameState.moveHistory.length === 1) {
                    document.getElementById('undo-btn').disabled = false;
                }

                // Remove any active hints
                this.clearHint();

                // Update UI
                this.animateFloodFill().then(() => {
                    this.renderGrid();
                    this.updateColorPalette();
                    this.updateMovesDisplay();
                    this.updateProgressBar();
                });
            }
        }

        static undoMove() {
            const undoSuccessful = this.gameState.undo();

            if (undoSuccessful) {
                // Play sound if enabled
                if (this.gameState.settings.soundEffects) {
                    this.playSound('undo');
                }

                // Disable undo button if no more moves to undo
                if (this.gameState.moveHistory.length === 0) {
                    document.getElementById('undo-btn').disabled = true;
                }

                // Remove any active hints
                this.clearHint();

                // Update UI
                this.renderGrid();
                this.updateColorPalette();
                this.updateMovesDisplay();
                this.updateProgressBar();
            }
        }

        static getHint() {
            if (this.gameState.hintActive) {
                this.clearHint();
                return;
            }

            const hintColorIndex = this.gameState.getHint();

            if (hintColorIndex !== null && hintColorIndex >= 0) {
                // Play sound if enabled
                if (this.gameState.settings.soundEffects) {
                    this.playSound('hint');
                }

                // Highlight the suggested color in the palette
                const palette = document.getElementById('palette');
                const colorOptions = palette.querySelectorAll('.color-option');

                colorOptions.forEach(option => {
                    if (parseInt(option.dataset.colorIndex) === hintColorIndex) {
                        option.classList.add('active');
                    }
                });

                // Set hint active flag
                this.gameState.hintActive = true;
            }
        }

        static clearHint() {
            if (!this.gameState.hintActive) return;

            // Remove highlight from palette
            const palette = document.getElementById('palette');
            const colorOptions = palette.querySelectorAll('.color-option');

            colorOptions.forEach(option => {
                option.classList.remove('active');
            });

            // Reset hint active flag
            this.gameState.hintActive = false;
        }

        static updateColorPalette() {
            const currentColor = this.gameState.gridData[0][0];
            const palette = document.getElementById('palette');
            const colorOptions = palette.querySelectorAll('.color-option');

            colorOptions.forEach(option => {
                const colorIndex = parseInt(option.dataset.colorIndex);
                if (colorIndex === currentColor) {
                    option.classList.add('disabled');
                } else {
                    option.classList.remove('disabled');
                }
            });
        }

        static updateMovesDisplay() {
            document.getElementById('moves').textContent = this.gameState.moves;
        }

        static updateBestScoreDisplay() {
            const difficulty = this.gameState.getDifficultyName();
            const bestScore = this.gameState.statistics.bestScores[difficulty];
            document.getElementById('best-score').textContent = bestScore === Infinity ? '-' : bestScore;
        }

        static updateTimer(time) {
            document.getElementById('timer').textContent = time;
        }

        static updateTimerVisibility() {
            const timerDisplay = document.getElementById('timer-display');
            if (this.gameState.settings.showTimer) {
                timerDisplay.classList.remove('hidden');
                if (this.gameState.isGameActive) {
                    this.gameState.startTimer();
                }
            } else {
                timerDisplay.classList.add('hidden');
                this.gameState.stopTimer();
            }
        }

        static updateProgressBar() {
            const progressBar = document.getElementById('progress-bar');
            const percentage = this.gameState.getProgressPercentage();
            progressBar.style.width = `${percentage}%`;
        }

        static updateKeyboardShortcutsVisibility() {
            const palette = document.getElementById('palette');
            const colorOptions = palette.querySelectorAll('.color-option');

            colorOptions.forEach((option, index) => {
                const shortcut = option.querySelector('.keyboard-shortcut');
                if (shortcut) {
                    option.removeChild(shortcut);
                }

                if (this.gameState.settings.keyboardShortcuts) {
                    const newShortcut = document.createElement('div');
                    newShortcut.className = 'keyboard-shortcut';
                    newShortcut.textContent = index + 1;
                    option.appendChild(newShortcut);
                }
            });
        }

        static openModal(modalId) {
            this.closeAllModals();
            document.getElementById(modalId).classList.add('active');
        }

        static closeAllModals() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('active');
            });
        }

        static toggleTheme() {
            const newTheme = this.gameState.currentTheme === 'light' ? 'dark' : 'light';
            this.gameState.currentTheme = newTheme;
            this.gameState.saveToStorage();
            this.applyTheme();
        }

        static applyTheme() {
            if (this.gameState.currentTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                document.getElementById('theme-toggle').innerHTML = '<i class="bi bi-sun-fill"></i>';
            } else {
                document.body.removeAttribute('data-theme');
                document.getElementById('theme-toggle').innerHTML = '<i class="bi bi-moon-fill"></i>';
            }
        }

        static updateSettingsUI() {
            document.getElementById('show-timer').checked = this.gameState.settings.showTimer;
            document.getElementById('sound-effects').checked = this.gameState.settings.soundEffects;
            document.getElementById('keyboard-shortcuts').checked = this.gameState.settings.keyboardShortcuts;
        }

        static updateAchievementsUI() {
            for (const [id, unlocked] of Object.entries(this.gameState.achievements)) {
                const achievement = document.querySelector(`.achievement[data-id="${id}"]`);
                if (achievement) {
                    if (unlocked) {
                        achievement.classList.add('unlocked');
                        achievement.querySelector('.achievement-icon').innerHTML = '<i class="bi bi-trophy-fill"></i>';
                    } else {
                        achievement.classList.remove('unlocked');
                        achievement.querySelector('.achievement-icon').innerHTML = '<i class="bi bi-lock"></i>';
                    }
                }
            }
        }

        static updateStatisticsUI() {
            document.getElementById('stats-games').textContent = this.gameState.statistics.gamesPlayed;
            document.getElementById('stats-wins').textContent = this.gameState.statistics.gamesWon;

            document.getElementById('stats-best-easy').textContent =
                this.gameState.statistics.bestScores.easy === Infinity ? '-' : this.gameState.statistics.bestScores.easy;
            document.getElementById('stats-best-medium').textContent =
                this.gameState.statistics.bestScores.medium === Infinity ? '-' : this.gameState.statistics.bestScores.medium;
            document.getElementById('stats-best-hard').textContent =
                this.gameState.statistics.bestScores.hard === Infinity ? '-' : this.gameState.statistics.bestScores.hard;
        }

        static resetStatistics() {
            if (confirm('Are you sure you want to reset all statistics and achievements?')) {
                this.gameState.statistics = {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    bestScores: {
                        easy: Infinity,
                        medium: Infinity,
                        hard: Infinity
                    }
                };

                this.gameState.achievements = {
                    "first-win": false,
                    "perfect-easy": false,
                    "perfect-medium": false,
                    "perfect-hard": false,
                    "persistent": false
                };

                this.gameState.saveToStorage();
                this.updateStatisticsUI();
                this.updateAchievementsUI();
                this.showToast('Statistics reset successfully', 'bi-check-circle');
            }
        }

        static shareResult() {
            const difficulty = this.gameState.getDifficultyName();
            const shareText = `I just completed Color Flood (${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}) in ${this.gameState.moves} moves! Try to beat my score at https://www.gptgames.dev/games/color_flood.html`;

            if (navigator.share) {
                navigator.share({
                    title: 'Color Flood Score',
                    text: shareText
                }).catch(err => {
                    console.error('Share failed:', err);
                    this.copyToClipboard(shareText);
                });
            } else {
                this.copyToClipboard(shareText);
            }
        }

        static copyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            this.showToast('Result copied to clipboard!', 'bi-clipboard-check');
        }

        static showToast(message, icon) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="toast-icon"><i class="bi ${icon}"></i></div>
                <div class="toast-message">${message}</div>
            `;

            toastContainer.appendChild(toast);

            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Remove toast after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toastContainer.removeChild(toast);
                }, 300);
            }, 3000);
        }

        static showAchievementToast(title, message) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="toast-icon"><i class="bi bi-trophy-fill"></i></div>
                <div class="toast-message">
                    <strong>${title}</strong><br>
                    ${message}
                </div>
            `;

            toastContainer.appendChild(toast);

            // Play sound if enabled
            if (this.gameState.settings.soundEffects) {
                this.playSound('achievement');
            }

            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Remove toast after 5 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toastContainer.removeChild(toast);
                }, 300);
            }, 5000);
        }

        static animateFloodFill() {
            return new Promise(resolve => {
                const cellElements = document.querySelectorAll('.cell');
                const targetColor = this.colorMap[this.gameState.gridData[0][0]];

                // Find all cells that match the target color
                const animatedCells = [];
                for (let i = 0; i < cellElements.length; i++) {
                    const row = parseInt(cellElements[i].dataset.row);
                    const col = parseInt(cellElements[i].dataset.col);

                    if (this.gameState.gridData[row][col] === this.gameState.gridData[0][0]) {
                        animatedCells.push(cellElements[i]);
                    }
                }

                // Animate them
                anime({
                    targets: animatedCells,
                    backgroundColor: [
                        { value: targetColor, duration: 300, easing: 'easeOutQuad' }
                    ],
                    scale: [
                        { value: 0.9, duration: 150, easing: 'easeOutSine' },
                        { value: 1, duration: 150, easing: 'easeInOutQuad' }
                    ],
                    delay: anime.stagger(5, { from: 'first' }),
                    complete: resolve
                });
            });
        }

        static playWinAnimation() {
            return new Promise(resolve => {
                const cells = document.querySelectorAll('.cell');

                anime({
                    targets: cells,
                    scale: [
                        { value: 0.8, duration: 150, easing: 'easeOutSine' },
                        { value: 1, duration: 250, easing: 'easeInOutQuad' }
                    ],
                    opacity: [
                        { value: 0.5, duration: 150, easing: 'easeOutSine' },
                        { value: 1, duration: 250, easing: 'easeInOutQuad' }
                    ],
                    delay: anime.stagger(10, { grid: [this.gameState.gridSize, this.gameState.gridSize], from: 'center' }),
                    complete: resolve
                });
            });
        }

        static playSound(type) {
            // Simple audio synthesis for sounds
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch (type) {
                case 'move':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'undo':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'win':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(554, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.4);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.8);
                    break;
                case 'hint':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'achievement':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.15);
                    oscillator.frequency.setValueAtTime(1318, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
            }
        }
    }

    class Game {
        constructor() {
            this.gameState = new GameState();
            this.gameState.loadFromStorage();

            UI.init(this.gameState);
            UI.startNewGame();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const game = new Game();
    });
</script>
<script src="../logo.js"></script>
</body>
</html>