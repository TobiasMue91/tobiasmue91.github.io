<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üòé</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Emoji Horde Survival</title>
    <style>body {
        margin: 0;
        overflow: hidden;
        background: #111;
        font-family: Arial, sans-serif;
        color: #fff
    }

    #gameCanvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0
    }

    #uiCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none
    }

    #startScreen, #gameOverScreen, #pauseMenu, #upgradeMenu, #tutorialOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        background: rgba(0, 0, 0, 0.85);
        z-index: 10
    }

    #gameOverScreen, #pauseMenu, #upgradeMenu, #tutorialOverlay {
        display: none
    }

    #statsPanel {
        position: absolute;
        right: 20px;
        bottom: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #444;
        border-radius: 5px;
        padding: 10px;
        font-size: 14px;
        display: none;
        z-index: 5
    }

    button {
        padding: 15px 30px;
        font-size: 20px;
        background: #2a9d8f;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin: 10px;
        transition: all 0.2s
    }

    button:hover {
        background: #1d7d7d;
        transform: scale(1.05)
    }

    .upgrade-option {
        width: 200px;
        height: 150px;
        background: rgba(42, 157, 143, 0.2);
        border: 2px solid #2a9d8f;
        border-radius: 10px;
        padding: 15px;
        margin: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s
    }

    .upgrade-option:hover {
        transform: scale(1.05);
        background: rgba(42, 157, 143, 0.4)
    }

    .wave-indicator {
        position: absolute;
        top: 130px;
        left: 20px;
        font-size: 24px;
        color: #f4a261;
        text-shadow: 0 0 5px #000
    }

    .mini-map {
        position: absolute;
        right: 20px;
        top: 20px;
        width: 150px;
        height: 150px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #444;
        border-radius: 5px
    }

    .combo-counter {
        position: absolute;
        left: 20px;
        top: 180px;
        font-size: 20px;
        color: #e9c46a;
        text-shadow: 0 0 5px #000;
        display: none
    }

    .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #264653;
        margin: 5px 0;
        border-radius: 10px;
        overflow: hidden;
        position: relative
    }

    .progress-fill {
        height: 100%;
        background-color: #2a9d8f;
        width: 0%;
        transition: width 0.3s
    }

    .health-bar {
        background-color: #264653;
        border-radius: 10px;
        overflow: hidden
    }

    .health-fill {
        height: 100%;
        background-color: #e76f51;
        transition: width 0.3s
    }

    .xp-bar {
        background-color: #264653;
        border-radius: 10px;
        overflow: hidden
    }

    .xp-fill {
        height: 100%;
        background-color: #e9c46a;
        transition: width 0.3s
    }

    #fpsCounter {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 12px;
        color: rgb(255, 0, 0);
        z-index: 1;
    }</style>
</head>
<body>
<div id="startScreen"><h1>EMOJI HORDE SURVIVAL</h1>
    <p>Survive the waves of emoji enemies!</p>
    <ul>
        <li>WASD or Arrow Keys to move</li>
        <li>SPACE to dash (with invincibility)</li>
        <li>ESC to pause</li>
        <li>TAB to toggle stats</li>
    </ul>
    <button id="startButton">START GAME</button>
</div>
<div id="gameOverScreen"><h1>GAME OVER</h1>
    <p>You survived <span id="finalTime">0</span></p>
    <p>Final score: <span id="finalScore">0</span></p>
    <p>Enemies defeated: <span id="finalKills">0</span></p>
    <p>Highest combo: <span id="finalCombo">0</span></p>
    <button id="restartButton">PLAY AGAIN</button>
</div>
<div id="pauseMenu"><h1>PAUSED</h1>
    <button id="resumeButton">RESUME</button>
    <button id="quitButton">QUIT TO MENU</button>
</div>
<div id="upgradeMenu"><h1>LEVEL UP!</h1>
    <p>Choose an upgrade:</p>
    <div id="upgradeOptions" style="display:flex;flex-wrap:wrap;justify-content:center;max-width:700px"></div>
</div>
<div id="tutorialOverlay"><h2>How to Play</h2>
    <p>Survive waves of emoji enemies for as long as possible!</p>
    <ul>
        <li>Move with WASD or Arrow Keys</li>
        <li>Dash with SPACE (with invincibility)</li>
        <li>Collect items to grow stronger</li>
        <li>Level up to choose upgrades</li>
        <li>Press TAB to see your stats</li>
        <li>Press ESC to pause</li>
    </ul>
    <button id="tutorialCloseButton">GOT IT!</button>
</div>
<div id="statsPanel"></div>
<div id="fpsCounter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<canvas id="uiCanvas"></canvas>
<script>const GAME_WIDTH = window.innerWidth;
const GAME_HEIGHT = window.innerHeight;
const CENTER_X = GAME_WIDTH / 2;
const CENTER_Y = GAME_HEIGHT / 2;
const ENDLESS_MODE_TIME = 20 * 60 * 1000;
const SPAWN_INTERVAL_BASE = 2000;
const MAX_ENEMIES = 300;
const gameCanvas = document.getElementById('gameCanvas');
const uiCanvas = document.getElementById('uiCanvas');
const gameCtx = gameCanvas.getContext('2d');
const uiCtx = uiCanvas.getContext('2d');
const startScreen = document.getElementById('startScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const pauseMenu = document.getElementById('pauseMenu');
const upgradeMenu = document.getElementById('upgradeMenu');
const tutorialOverlay = document.getElementById('tutorialOverlay');
const statsPanel = document.getElementById('statsPanel');
const startButton = document.getElementById('startButton');
const restartButton = document.getElementById('restartButton');
const resumeButton = document.getElementById('resumeButton');
const quitButton = document.getElementById('quitButton');
const tutorialCloseButton = document.getElementById('tutorialCloseButton');
const upgradeOptionsElement = document.getElementById('upgradeOptions');
const finalTimeSpan = document.getElementById('finalTime');
const finalScoreSpan = document.getElementById('finalScore');
const finalKillsSpan = document.getElementById('finalKills');
const finalComboSpan = document.getElementById('finalCombo');
const fpsCounter = document.getElementById('fpsCounter');
let lastTime = 0;
let deltaTime = 0;
let gameTime = 0;
let isGameOver = false;
let isGameRunning = false;
let isPaused = false;
let isEndlessMode = false;
let isUpgrading = false;
let isFirstGame = true;
let score = 0;
let level = 1;
let experience = 0;
let experienceToNextLevel = 75;
let enemySpawnTimer = 0;
let waveNumber = 1;
let waveTimer = 0;
let waveInterval = 30000;
let comboCount = 0;
let comboTimer = 0;
let highestCombo = 0;
let spawnInterval = SPAWN_INTERVAL_BASE;
let lastAttackTime = 0;
let backgroundPattern = null;
let screenShake = 0;
let killCount = 0;
let dashCooldown = 0;
let isDashing = false;
let dashDirection = {x: 0, y: 0};
let specialWave = false;
let keys = {};
let mouseX = 0;
let mouseY = 0;
let frameCount = 0;
let fps = 0;
let lastFpsUpdate = 0;
const enemies = [];
const items = [];
const projectiles = [];
const particles = [];
const floatingTexts = [];
let obstacleParticles = [];
let effects = {};
let itemLabels = [];
let environmentalElements = [];
// Spatial partitioning for collision optimization
const GRID_SIZE = 100;
let spatialGrid = {};
const player = {
    x: CENTER_X,
    y: CENTER_Y,
    size: 40,
    speed: 200,
    dashSpeed: 500,
    dashDuration: 300,
    dashCooldownTime: 2000,
    health: 100,
    maxHealth: 100,
    damage: 12,
    attackSpeed: 1.1,
    attackRange: 200,
    pickupRange: 120,
    critChance: 0.05,
    critMultiplier: 1.5,
    emoji: 'üòé',
    direction: 1,
    isMoving: false,
    lastAttackTime: 0,
    effects: {},
    invulnerableTime: 0,
    kills: 0
};// Enhanced enemy types with more diverse behaviors
const enemyTypes = [{
    type: 'basic',
    emoji: 'üëæ',
    health: 35,
    damage: 5,
    speed: 100,
    range: 0,
    pointValue: 10,
    dropChance: 0.12,
    collisionRadius: 20,
    behavior: 'follow'
}, {
    type: 'fast',
    emoji: 'üêÄ',
    health: 22,
    damage: 3,
    speed: 180,
    range: 0,
    pointValue: 15,
    dropChance: 0.14,
    collisionRadius: 18,
    behavior: 'zigzag'
}, {
    type: 'tank',
    emoji: 'ü¶è',
    health: 120,
    damage: 8,
    speed: 60,
    range: 0,
    pointValue: 25,
    dropChance: 0.15,
    collisionRadius: 25,
    behavior: 'follow'
}, {
    type: 'ranged',
    emoji: 'üßô',
    health: 30,
    damage: 6,
    speed: 70,
    range: 300,
    pointValue: 20,
    attackSpeed: 1.5,
    projectileSpeed: 300,
    dropChance: 0.18,
    collisionRadius: 20,
    behavior: 'keepDistance'
}, {
    type: 'explosive',
    emoji: 'üí£',
    health: 50,
    damage: 15,
    speed: 90,
    range: 0,
    explosionRange: 150,
    pointValue: 30,
    dropChance: 0.2,
    collisionRadius: 22,
    behavior: 'kamikaze'
}, {
    type: 'boss',
    emoji: 'üëπ',
    health: 400,
    damage: 15,
    speed: 70,
    range: 0,
    isBoss: true,
    size: 60,
    pointValue: 100,
    dropChance: 1.0,
    collisionRadius: 40,
    specialAttack: 'summon',
    specialAttackCooldown: 10000,
    behavior: 'aggressive'
}, {
    type: 'elite',
    emoji: 'üëø',
    health: 180,
    damage: 10,
    speed: 120,
    range: 150,
    isElite: true,
    size: 50,
    pointValue: 50,
    attackSpeed: 1.2,
    projectileSpeed: 320,
    dropChance: 0.5,
    collisionRadius: 30,
    behavior: 'flanking'
}, {
    type: 'ghost',
    emoji: 'üëª',
    health: 60,
    damage: 7,
    speed: 130,
    range: 0,
    isGhost: true,
    size: 40,
    pointValue: 35,
    dropChance: 0.2,
    collisionRadius: 20,
    behavior: 'phasing'
}, {
    type: 'vampire',
    emoji: 'üßõ',
    health: 100,
    damage: 9,
    speed: 110,
    range: 0,
    isVampire: true,
    size: 45,
    pointValue: 40,
    vampiricStrength: 0.3,
    dropChance: 0.25,
    collisionRadius: 25,
    behavior: 'aggressive'
}, {
    type: 'teleporter',
    emoji: '‚ö°',
    health: 70,
    damage: 8,
    speed: 100,
    range: 0,
    pointValue: 45,
    dropChance: 0.22,
    collisionRadius: 22,
    behavior: 'teleport',
    teleportCooldown: 3000
}, {
    type: 'swarm',
    emoji: 'üêù',
    health: 15,
    damage: 2,
    speed: 140,
    range: 0,
    pointValue: 8,
    dropChance: 0.1,
    collisionRadius: 16,
    behavior: 'swarm'
}];// Enhanced item types with synergies
const itemTypes = [{
    type: 'healthUp',
    emoji: '‚ù§Ô∏è',
    name: 'Health Up',
    rarity: 'common',
    description: 'Increases max health by 20',
    effect(p) {
        p.maxHealth += 20;
        p.health = Math.min(p.health + 20, p.maxHealth);
        addEffect('healthUp', 10);
    }
}, {
    type: 'speedUp',
    emoji: 'üëü',
    name: 'Speed Up',
    rarity: 'common',
    description: 'Increases movement speed by 20',
    effect(p) {
        p.speed += 20;
        addEffect('speedUp', 10);
    }
}, {
    type: 'damageUp', emoji: 'üí™', name: 'Damage Up', rarity: 'common', description: 'Increases damage by 2', effect(p) {
        p.damage += 2;
        addEffect('damageUp', 10);
    }
}, {
    type: 'attackSpeedUp',
    emoji: '‚ö°',
    name: 'Attack Speed Up',
    rarity: 'common',
    description: 'Increases attack speed by 0.15',
    effect(p) {
        p.attackSpeed += 0.15;
        addEffect('attackSpeedUp', 10);
    }
}, {
    type: 'rangeUp',
    emoji: 'üî≠',
    name: 'Range Up',
    rarity: 'common',
    description: 'Increases attack and pickup range',
    effect(p) {
        p.attackRange += 30;
        p.pickupRange += 10;
        addEffect('rangeUp', 10);
    }
}, {
    type: 'vampirism',
    emoji: 'üßõ',
    name: 'Vampirism',
    rarity: 'uncommon',
    description: 'Heal for 5% of damage dealt',
    effect(p) {
        if (!p.effects.vampirism) p.effects.vampirism = 0;
        p.effects.vampirism += 0.05;
        addEffect('vampirism');
        if (p.effects.burnAttack) {
            p.effects.burnAttack += 0.05;
            createFloatingText(p.x, p.y - 30, 'Synergy: Vampiric Fire!', '#FF6600', 18);
        }
    }
}, {
    type: 'poisonAttack',
    emoji: 'üß™',
    name: 'Poison Attack',
    rarity: 'uncommon',
    description: '30% chance to poison enemies',
    effect(p) {
        if (!p.effects.poisonAttack) p.effects.poisonAttack = 0;
        p.effects.poisonAttack += 0.3;
        addEffect('poisonAttack');
        if (p.effects.freezeAttack) {
            p.damage += 3;
            createFloatingText(p.x, p.y - 30, 'Synergy: Chemical Frost!', '#00FFAA', 18);
        }
    }
}, {
    type: 'freezeAttack',
    emoji: '‚ùÑÔ∏è',
    name: 'Freeze Attack',
    rarity: 'uncommon',
    description: '20% chance to freeze enemies',
    effect(p) {
        if (!p.effects.freezeAttack) p.effects.freezeAttack = 0;
        p.effects.freezeAttack += 0.2;
        addEffect('freezeAttack');
        if (p.effects.thornAura) {
            p.effects.thornAura += 0.1;
            createFloatingText(p.x, p.y - 30, 'Synergy: Frost Thorns!', '#66CCFF', 18);
        }
    }
}, {
    type: 'burnAttack',
    emoji: 'üî•',
    name: 'Burn Attack',
    rarity: 'uncommon',
    description: '25% chance to burn enemies',
    effect(p) {
        if (!p.effects.burnAttack) p.effects.burnAttack = 0;
        p.effects.burnAttack += 0.25;
        addEffect('burnAttack');
        if (p.effects.multishot) {
            p.attackSpeed += 0.15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Rapid Fire!', '#FF4500', 18);
        }
    }
}, {
    type: 'magnet',
    emoji: 'üß≤',
    name: 'Magnet',
    rarity: 'uncommon',
    description: 'Increases item pickup range by 50',
    effect(p) {
        p.pickupRange += 50;
        addEffect('magnet', 10);
        if (p.effects.luckyCharm) {
            p.pickupRange += 20;
            createFloatingText(p.x, p.y - 30, 'Synergy: Fortune Magnet!', '#FFD700', 18);
        }
    }
}, {
    type: 'shield', emoji: 'üõ°Ô∏è', name: 'Shield', rarity: 'rare', description: 'Reduces damage taken by 10%', effect(p) {
        if (!p.effects.shield) p.effects.shield = 0;
        p.effects.shield += 0.1;
        addEffect('shield');
        if (p.effects.regeneration) {
            p.maxHealth += 15;
            p.health += 15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Vital Shield!', '#5CCCCC', 18);
        }
    }
}, {
    type: 'luckyCharm',
    emoji: 'üçÄ',
    name: 'Lucky Charm',
    rarity: 'rare',
    description: '+10% item drop chance, +3% crit chance',
    effect(p) {
        if (!p.effects.luckyCharm) p.effects.luckyCharm = 0;
        p.effects.luckyCharm += 0.1;
        p.critChance += 0.03;
        addEffect('luckyCharm');
    }
}, {
    type: 'regeneration',
    emoji: 'üîÑ',
    name: 'Regeneration',
    rarity: 'rare',
    description: 'Heal 1 health per second',
    effect(p) {
        if (!p.effects.regeneration) p.effects.regeneration = 0;
        p.effects.regeneration += 1;
        addEffect('regeneration');
    }
}, {
    type: 'thornAura',
    emoji: 'üåµ',
    name: 'Thorn Aura',
    rarity: 'rare',
    description: 'Damages nearby enemies',
    effect(p) {
        if (!p.effects.thornAura) p.effects.thornAura = 0;
        p.effects.thornAura += 0.3;
        addEffect('thornAura');
        if (p.effects.poisonAttack) {
            p.thornPoisonChance = 0.2;
            createFloatingText(p.x, p.y - 30, 'Synergy: Toxic Thorns!', '#00CC00', 18);
        }
    }
}, {
    type: 'multishot',
    emoji: 'üéØ',
    name: 'Multishot',
    rarity: 'legendary',
    description: 'Fire an additional projectile',
    effect(p) {
        if (!p.effects.multishot) p.effects.multishot = 0;
        p.effects.multishot += 1;
        addEffect('multishot');
    }
}, {
    type: 'dashMastery',
    emoji: 'üí®',
    name: 'Dash Mastery',
    rarity: 'legendary',
    description: 'Reduces dash cooldown by 25%',
    effect(p) {
        p.dashCooldownTime *= 0.75;
        addEffect('dashMastery');
        if (p.effects.speedUp) {
            p.dashSpeed += 50;
            createFloatingText(p.x, p.y - 30, 'Synergy: Rapid Dash!', '#00AAFF', 18);
        }
    }
}, {
    type: 'criticalStrike',
    emoji: '‚öîÔ∏è',
    name: 'Critical Strike',
    rarity: 'legendary',
    description: '+10% crit chance, +20% crit damage',
    effect(p) {
        p.critChance += 0.1;
        p.critMultiplier += 0.2;
        addEffect('criticalStrike');
        if (p.effects.multishot) {
            p.critMultiplier += 0.15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Critical Barrage!', '#FF00AA', 18);
        }
    }
}, {
    type: 'nukeBomb',
    emoji: '‚ò¢Ô∏è',
    name: 'Nuke Bomb',
    rarity: 'legendary',
    description: 'Damages all enemies on screen',
    effect(p) {
        enemies.forEach(enemy => {
            const damage = p.damage * 3;
            enemy.health -= damage;
            createFloatingText(enemy.x, enemy.y, Math.round(damage), '#ff4d4d', 20);
        });
        createFloatingText(p.x, p.y, 'üí• BOOM!', '#ff4d4d', 36);
        screenShake = 15;
        for (let i = 0; i < 50; i++) {
            particles.push({
                x: CENTER_X + (Math.random() - 0.5) * GAME_WIDTH * 0.8,
                y: CENTER_Y + (Math.random() - 0.5) * GAME_HEIGHT * 0.8,
                size: Math.random() * 10 + 5,
                color: '#ff4d4d',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                life: 60,
            });
        }
    },
}, {
    type: 'orbital',
    emoji: 'üîÆ',
    name: 'Orbital',
    rarity: 'legendary',
    description: 'Creates a projectile that orbits you',
    effect(p) {
        if (!p.effects.orbital) p.effects.orbital = 0;
        p.effects.orbital += 1;
        addEffect('orbital');
        createFloatingText(p.x, p.y - 30, 'Orbital Protection', '#9966FF', 18);
    }
}, {
    type: 'rageMode',
    emoji: 'üò°',
    name: 'Rage Mode',
    rarity: 'legendary',
    description: 'Temporarly massively increases damage and speed',
    effect(p) {
        p.damage *= 1.5;
        p.speed *= 1.3;
        p.attackSpeed *= 1.3;
        addEffect('rageMode', 20);
        createFloatingText(p.x, p.y, 'RAGE MODE ACTIVATED!', '#FF0000', 30);
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: p.x,
                y: p.y,
                size: Math.random() * 10 + 5,
                color: '#FF0000',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8},
                life: 40,
            });
        }
    }
}];// Enhanced upgrade choices with more variety
const upgradeChoices = [{
    name: 'Health Boost', emoji: '‚ù§Ô∏è', description: 'Increase max health by 25', effect() {
        player.maxHealth += 25;
        player.health += 25;
    }
}, {
    name: 'Attack Damage', emoji: 'üí™', description: 'Increase damage by 20%', effect() {
        player.damage *= 1.2;
    }
}, {
    name: 'Attack Speed', emoji: '‚ö°', description: 'Increase attack speed by 1', effect() {
        player.attackSpeed += 1;
    }
}, {
    name: 'Movement Speed', emoji: 'üëü', description: 'Increase movement speed by 25', effect() {
        player.speed += 25;
    }
}, {
    name: 'Attack Range', emoji: 'üî≠', description: 'Increase attack range by 40', effect() {
        player.attackRange += 40;
    }
}, {
    name: 'Dash Power', emoji: 'üí®', description: 'Reduce dash cooldown by 15%', effect() {
        player.dashCooldownTime *= 0.85;
    }
}, {
    name: 'Critical Strikes', emoji: '‚öîÔ∏è', description: 'Increase crit chance by 5%', effect() {
        player.critChance += 0.05;
    }
}, {
    name: 'Pickup Range', emoji: 'üß≤', description: 'Increase item pickup range by 40', effect() {
        player.pickupRange += 40;
    }
}, {
    name: 'Regeneration', emoji: 'üîÑ', description: 'Regenerate 0.5 health per second', effect() {
        if (!player.effects.regeneration) player.effects.regeneration = 0;
        player.effects.regeneration += 0.5;
    }
}, {
    name: 'Vampiric Touch', emoji: 'üßõ', description: 'Gain 3% lifesteal on hit', effect() {
        if (!player.effects.vampirism) player.effects.vampirism = 0;
        player.effects.vampirism += 0.03;
    }
}, {
    name: 'Toxic Attacks', emoji: 'üß™', description: '15% chance to poison enemies', effect() {
        if (!player.effects.poisonAttack) player.effects.poisonAttack = 0;
        player.effects.poisonAttack += 0.15;
    }
}, {
    name: 'Icy Projectiles', emoji: '‚ùÑÔ∏è', description: '15% chance to freeze enemies', effect() {
        if (!player.effects.freezeAttack) p.effects.freezeAttack = 0;
        player.effects.freezeAttack += 0.15;
    }
}, {
    name: 'Flame Aura', emoji: 'üî•', description: '15% chance to burn enemies', effect() {
        if (!player.effects.burnAttack) player.effects.burnAttack = 0;
        player.effects.burnAttack += 0.15;
    }
}, {
    name: 'Shield Matrix', emoji: 'üõ°Ô∏è', description: 'Reduce damage taken by 7%', effect() {
        if (!player.effects.shield) player.effects.shield = 0;
        player.effects.shield += 0.07;
    }
}, {
    name: 'Lucky Strikes', emoji: 'üçÄ', description: 'Increase crit damage by 15%', effect() {
        player.critMultiplier += 0.15;
    }
}, {
    name: 'Thorn Barrier', emoji: 'üåµ', description: 'Damage enemies that hit you', effect() {
        if (!player.effects.thornAura) player.effects.thornAura = 0;
        player.effects.thornAura += 0.15;
    }
}];// Achievements
const achievements = [{
    id: 'firstKill',
    name: 'First Blood',
    description: 'Defeat your first enemy',
    unlocked: false,
    emoji: 'ü©∏'
}, {
    id: 'tenKills',
    name: 'Beginner Slayer',
    description: 'Defeat 10 enemies',
    unlocked: false,
    emoji: '‚öîÔ∏è'
}, {
    id: 'hundredKills',
    name: 'Horde Destroyer',
    description: 'Defeat 100 enemies',
    unlocked: false,
    emoji: 'üí•'
}, {
    id: 'firstBoss',
    name: 'Boss Slayer',
    description: 'Defeat your first boss',
    unlocked: false,
    emoji: 'üëë'
}, {
    id: 'maxCombo',
    name: 'Combo Master',
    description: 'Get a 15+ combo',
    unlocked: false,
    emoji: 'üîÑ'
}, {
    id: 'firstItem',
    name: 'Collector',
    description: 'Collect your first item',
    unlocked: false,
    emoji: 'üéÅ'
}, {
    id: 'firstLevelUp',
    name: 'Level Up',
    description: 'Reach level 2',
    unlocked: false,
    emoji: '‚≠ê'
}, {
    id: 'threeMinutes',
    name: 'Survivor',
    description: 'Survive for 3 minutes',
    unlocked: false,
    emoji: '‚è±Ô∏è'
}, {
    id: 'tenMinutes',
    name: 'Veteran',
    description: 'Survive for 10 minutes',
    unlocked: false,
    emoji: 'üèÜ'
}, {id: 'endlessMode', name: 'Endless Warrior', description: 'Enter endless mode', unlocked: false, emoji: '‚ôæÔ∏è'}];// Environmental elements for visual detail
function createEnvironment() {
    environmentalElements = [];
    const rockCount = Math.floor(Math.random() * 10) + 10;
    for (let i = 0; i < rockCount; i++) {
        environmentalElements.push({
            type: 'rock',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 20 + 10,
            emoji: 'ü™®'
        });
    }
    const flowerCount = Math.floor(Math.random() * 15) + 5;
    for (let i = 0; i < flowerCount; i++) {
        environmentalElements.push({
            type: 'flower',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 15 + 10,
            emoji: ['üåº', 'üå∏', 'üå∫', 'üåª'][Math.floor(Math.random() * 4)]
        });
    }
    const treeCount = Math.floor(Math.random() * 5) + 3;
    for (let i = 0; i < treeCount; i++) {
        environmentalElements.push({
            type: 'tree',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 30 + 20,
            emoji: 'üå≥'
        });
    }
}

function drawEnvironment() {
    environmentalElements.forEach(element => {
        gameCtx.save();
        gameCtx.globalAlpha = 0.6;
        gameCtx.font = `${element.size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(element.emoji, element.x, element.y);
        gameCtx.restore();
    });
}// Spatial grid functions for collision optimization
function updateSpatialGrid() {
    spatialGrid = {};
    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        const gridX = Math.floor(enemy.x / GRID_SIZE);
        const gridY = Math.floor(enemy.y / GRID_SIZE);
        const key = `${gridX},${gridY}`;
        if (!spatialGrid[key]) {
            spatialGrid[key] = [];
        }
        spatialGrid[key].push(enemy);
    }
}

function getNeighbors(entity) {
    const neighbors = [];
    const gridX = Math.floor(entity.x / GRID_SIZE);
    const gridY = Math.floor(entity.y / GRID_SIZE);
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            const key = `${gridX + x},${gridY + y}`;
            if (spatialGrid[key]) {
                neighbors.push(...spatialGrid[key]);
            }
        }
    }
    return neighbors;
}

function addEffect(effectName, duration = null) {
    if (duration) {
        effects[effectName] = {duration: duration, icon: getEffectIcon(effectName)};
    } else {
        effects[effectName] = {permanent: true, icon: getEffectIcon(effectName)};
    }
}

function getEffectIcon(effectName) {
    switch (effectName) {
        case 'healthUp':
            return '‚ù§Ô∏è';
        case 'speedUp':
            return 'üëü';
        case 'damageUp':
            return 'üí™';
        case 'attackSpeedUp':
            return '‚ö°';
        case 'rangeUp':
            return 'üî≠';
        case 'vampirism':
            return 'üßõ';
        case 'poisonAttack':
            return 'üß™';
        case 'freezeAttack':
            return '‚ùÑÔ∏è';
        case 'burnAttack':
            return 'üî•';
        case 'magnet':
            return 'üß≤';
        case 'shield':
            return 'üõ°Ô∏è';
        case 'luckyCharm':
            return 'üçÄ';
        case 'regeneration':
            return 'üîÑ';
        case 'thornAura':
            return 'üåµ';
        case 'multishot':
            return 'üéØ';
        case 'dashMastery':
            return 'üí®';
        case 'criticalStrike':
            return '‚öîÔ∏è';
        case 'orbital':
            return 'üîÆ';
        case 'rageMode':
            return 'üò°';
        default:
            return '‚ùì';
    }
}

function resizeCanvases() {
    gameCanvas.width = window.innerWidth;
    gameCanvas.height = window.innerHeight;
    uiCanvas.width = window.innerWidth;
    uiCanvas.height = window.innerHeight;
    createBackgroundPattern();
}

function createBackgroundPattern() {
    const patternCanvas = document.createElement('canvas');
    const patternContext = patternCanvas.getContext('2d');
    patternCanvas.width = 150;
    patternCanvas.height = 150;
    patternContext.fillStyle = '#121212';
    patternContext.fillRect(0, 0, 150, 150);
    patternContext.strokeStyle = '#1a1a1a';
    patternContext.lineWidth = 1;
    patternContext.beginPath();
    for (let i = 0; i <= 150; i += 20) {
        patternContext.moveTo(i, 0);
        patternContext.lineTo(i, 150);
        patternContext.moveTo(0, i);
        patternContext.lineTo(150, i);
    }
    patternContext.stroke();
    patternContext.fillStyle = '#222';
    for (let i = 0; i < 25; i++) {
        const x = Math.random() * 150;
        const y = Math.random() * 150;
        const radius = Math.random() * 2 + 1;
        patternContext.beginPath();
        patternContext.arc(x, y, radius, 0, Math.PI * 2);
        patternContext.fill();
    }
    for (let i = 0; i < obstacleParticles.length; i++) {
        const p = obstacleParticles[i];
        patternContext.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a})`;
        patternContext.beginPath();
        patternContext.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        patternContext.fill();
    }
    backgroundPattern = gameCtx.createPattern(patternCanvas, 'repeat');
}// Generate background obstacles
function generateObstacleParticles() {
    obstacleParticles = [];
    for (let i = 0; i < 40; i++) {
        obstacleParticles.push({
            x: Math.random() * 150,
            y: Math.random() * 150,
            size: Math.random() * 3 + 1,
            r: Math.floor(Math.random() * 40) + 30,
            g: Math.floor(Math.random() * 40) + 30,
            b: Math.floor(Math.random() * 60) + 40,
            a: Math.random() * 0.3 + 0.1
        });
    }
}

function drawBackground() {
    gameCtx.fillStyle = backgroundPattern;
    gameCtx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    if (screenShake > 0) {
        gameCtx.save();
        const shakeX = (Math.random() - 0.5) * screenShake * 2;
        const shakeY = (Math.random() - 0.5) * screenShake * 2;
        gameCtx.translate(shakeX, shakeY);
    }
}

function spawnEnemy() {
    if (enemies.length >= MAX_ENEMIES) return;
    const spawnDistance = Math.max(GAME_WIDTH, GAME_HEIGHT) / 2 + 100;
    const angle = Math.random() * Math.PI * 2;
    const spawnX = CENTER_X + Math.cos(angle) * spawnDistance;
    const spawnY = CENTER_Y + Math.sin(angle) * spawnDistance;
    let typeIndex;
    const minutes = gameTime / 60000;
    const waveProgress = waveTimer / waveInterval;
    if (specialWave) {
        if (specialWave === 'ghost') {
            typeIndex = 7;
        } else if (specialWave === 'vampire') {
            typeIndex = 8;
        } else if (specialWave === 'teleporter') {
            typeIndex = 9;
        } else if (specialWave === 'swarm') {
            typeIndex = 10;
        } else {
            typeIndex = Math.floor(Math.random() * 5);
        }
    } else if (gameTime > ENDLESS_MODE_TIME) {
        if (Math.random() < 0.08) {
            typeIndex = 5;
        } else if (Math.random() < 0.2) {
            typeIndex = 6;
        } else if (Math.random() < 0.12) {
            typeIndex = 7;
        } else if (Math.random() < 0.12) {
            typeIndex = 8;
        } else if (Math.random() < 0.1) {
            typeIndex = 9;
        } else if (Math.random() < 0.1) {
            typeIndex = 10;
        } else {
            typeIndex = Math.floor(Math.random() * 5);
        }
    } else {
        if (minutes < 1) {
            typeIndex = 0;
        } else if (minutes < 3) {
            typeIndex = Math.random() < 0.75 ? 0 : 1;
        } else if (minutes < 6) {
            typeIndex = Math.floor(Math.random() * 3);
        } else if (minutes < 10) {
            typeIndex = Math.floor(Math.random() * 4);
        } else if (minutes < 15) {
            typeIndex = Math.floor(Math.random() * 5);
        } else {
            typeIndex = Math.floor(Math.random() * enemyTypes.length - 2);
        }
    }
    const shouldSpawnBoss = (waveNumber % 5 === 0 && waveProgress > 0.7 && enemies.filter(e => e.isBoss).length < 1);
    if (shouldSpawnBoss) {
        typeIndex = 5;
    }
    const shouldSpawnElite = (waveNumber % 3 === 0 && waveProgress > 0.5 && enemies.filter(e => e.isElite).length < 3);
    if (shouldSpawnElite && !shouldSpawnBoss && minutes > 5) {
        typeIndex = 6;
    }
    const type = enemyTypes[typeIndex];
    const waveMultiplier = 1 + (waveNumber - 1) * 0.08;
    const timeMultiplier = 1 + (minutes * 0.03);
    const endlessMultiplier = isEndlessMode ? 1 + ((gameTime - ENDLESS_MODE_TIME) / 1000 / 60) * 0.2 : 1;
    const healthMultiplier = waveMultiplier * timeMultiplier * endlessMultiplier;
    const damageMultiplier = waveMultiplier * endlessMultiplier;
    const enemy = {
        x: spawnX,
        y: spawnY,
        health: type.health * healthMultiplier,
        maxHealth: type.health * healthMultiplier,
        damage: type.damage * damageMultiplier,
        speed: type.speed,
        range: type.range || 0,
        size: type.size || 40,
        type: type.type,
        emoji: type.emoji,
        isBoss: type.isBoss || false,
        isElite: type.isElite || false,
        isGhost: type.isGhost || false,
        isVampire: type.isVampire || false,
        vampiricStrength: type.vampiricStrength || 0,
        lastAttackTime: 0,
        attackSpeed: type.attackSpeed || 1,
        projectileSpeed: type.projectileSpeed,
        explosionRange: type.explosionRange,
        pointValue: type.pointValue,
        dropChance: type.dropChance,
        collisionRadius: type.collisionRadius || 20,
        behavior: type.behavior || 'follow',
        behaviorTimer: 0,
        behaviorState: {},
        effects: {},
        specialAttack: type.specialAttack,
        specialAttackCooldown: type.specialAttackCooldown,
        lastSpecialAttack: 0,
        teleportCooldown: type.teleportCooldown,
        lastTeleport: 0,
    };
    enemies.push(enemy);
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: spawnX,
            y: spawnY,
            size: Math.random() * 5 + 5,
            color: enemy.isBoss ? '#ff4d4d' : (enemy.isElite ? '#9966ff' : (enemy.isGhost ? '#b8c0ff' : (enemy.isVampire ? '#800020' : '#4da6ff'))),
            alpha: 1,
            speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
            life: 20,
        });
    }
}

function drawEnemy(enemy) {
    let x = enemy.x;
    let y = enemy.y;
    const isFrozen = enemy.effects.frozen;
    gameCtx.save();
    if (isFrozen) {
        gameCtx.globalAlpha = 0.8;
        gameCtx.shadowColor = '#00BFFF';
        gameCtx.shadowBlur = 10;
    }
    if (enemy.isGhost) {
        gameCtx.globalAlpha = 0.7;
    }
    if (enemy.effects.burning) {
        if (Math.random() > 0.7) {
            particles.push({
                x: enemy.x + (Math.random() * enemy.size - enemy.size / 2),
                y: enemy.y + (Math.random() * enemy.size - enemy.size / 2),
                size: Math.random() * 5 + 5,
                color: '#FF4500',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 2},
                life: 30,
            });
        }
    }
    if (enemy.effects.poisoned) {
        if (Math.random() > 0.7) {
            particles.push({
                x: enemy.x + (Math.random() * enemy.size - enemy.size / 2),
                y: enemy.y + (Math.random() * enemy.size - enemy.size / 2),
                size: Math.random() * 5 + 3,
                color: '#00FF00',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 1},
                life: 20,
            });
        }
    }
    if (enemy.isBoss) {
        gameCtx.shadowColor = '#ff4d4d';
        gameCtx.shadowBlur = 15;
    } else if (enemy.isElite) {
        gameCtx.shadowColor = '#9966ff';
        gameCtx.shadowBlur = 10;
    } else if (enemy.isGhost) {
        gameCtx.shadowColor = '#b8c0ff';
        gameCtx.shadowBlur = 8;
    } else if (enemy.isVampire) {
        gameCtx.shadowColor = '#800020';
        gameCtx.shadowBlur = 12;
    } else if (enemy.type === 'teleporter') {
        gameCtx.shadowColor = '#FFDD00';
        gameCtx.shadowBlur = 10;
    }
    gameCtx.font = `${enemy.size}px Arial`;
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(enemy.emoji, x, y);
    if (enemy.health < enemy.maxHealth) {
        const healthBarWidth = enemy.size * 1.2;
        const healthBarHeight = 6;
        const healthPercent = enemy.health / enemy.maxHealth;
        gameCtx.fillStyle = '#333';
        gameCtx.fillRect(x - healthBarWidth / 2, y + enemy.size / 2 + 5, healthBarWidth, healthBarHeight);
        if (healthPercent > 0.6) {
            gameCtx.fillStyle = '#2ecc71';
        } else if (healthPercent > 0.3) {
            gameCtx.fillStyle = '#f39c12';
        } else {
            gameCtx.fillStyle = '#e74c3c';
        }
        gameCtx.fillRect(x - healthBarWidth / 2, y + enemy.size / 2 + 5, healthBarWidth * healthPercent, healthBarHeight);
    }
    gameCtx.restore();
}

function drawEnemies() {
    enemies.forEach(drawEnemy);
}// Add enemy collision detection and improved movement
function moveEnemies() {
    updateSpatialGrid();
    enemies.forEach(enemy => {// Apply special behaviors
        applyEnemyBehavior(enemy); // Handle collisions with other enemies
        if (!enemy.isGhost) {
            const neighbors = getNeighbors(enemy);
            neighbors.forEach(other => {
                if (enemy !== other && !other.isGhost) {
                    const dx = enemy.x - other.x;
                    const dy = enemy.y - other.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = enemy.collisionRadius + other.collisionRadius;
                    if (distance < minDistance && distance > 0) {
                        const angle = Math.atan2(dy, dx);
                        const pushFactor = 0.3;
                        const pushX = (minDistance - distance) * Math.cos(angle) * pushFactor;
                        const pushY = (minDistance - distance) * Math.sin(angle) * pushFactor;
                        enemy.x += pushX;
                        enemy.y += pushY;
                        other.x -= pushX;
                        other.y -= pushY;
                    }
                }
            });
        }
    });
}// Advanced enemy behavior patterns
function applyEnemyBehavior(enemy) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    let speedMultiplier = enemy.effects.frozen ? 0.3 : 1;
    const angle = Math.atan2(dy, dx);
    const now = Date.now(); // Special attack for bosses
    if (enemy.specialAttack === 'summon' && now - enemy.lastSpecialAttack >= enemy.specialAttackCooldown) {
        enemy.lastSpecialAttack = now;
        for (let i = 0; i < 3; i++) {
            if (enemies.length < MAX_ENEMIES) {
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnDistance = enemy.size * 1.5;
                const spawnX = enemy.x + Math.cos(spawnAngle) * spawnDistance;
                const spawnY = enemy.y + Math.sin(spawnAngle) * spawnDistance;
                const summonType = Math.random() < 0.5 ? enemyTypes[0] : enemyTypes[1];
                const summonedEnemy = {
                    x: spawnX,
                    y: spawnY,
                    health: summonType.health * 0.7,
                    maxHealth: summonType.health * 0.7,
                    damage: summonType.damage * 0.7,
                    speed: summonType.speed,
                    size: summonType.size || 40,
                    type: summonType.type,
                    emoji: summonType.emoji,
                    pointValue: Math.floor(summonType.pointValue * 0.5),
                    dropChance: 0,
                    collisionRadius: summonType.collisionRadius || 20,
                    behavior: 'follow',
                    effects: {},
                };
                enemies.push(summonedEnemy);
                createFloatingText(spawnX, spawnY, 'Summoned!', '#FF00FF', 16);
                for (let j = 0; j < 5; j++) {
                    particles.push({
                        x: spawnX,
                        y: spawnY,
                        size: Math.random() * 5 + 3,
                        color: '#FF00FF',
                        alpha: 0.8,
                        speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                        life: 15,
                    });
                }
            }
        }
        createFloatingText(enemy.x, enemy.y - 30, 'Summoning!', '#FF00FF', 22);
    } // Teleporter enemies
    if (enemy.behavior === 'teleport' && now - enemy.lastTeleport >= enemy.teleportCooldown && distance < 300 && distance > 100) {
        enemy.lastTeleport = now;
        const oldX = enemy.x;
        const oldY = enemy.y;
        const teleportAngle = Math.random() * Math.PI * 2;
        const teleportDistance = Math.random() * 100 + 100;
        enemy.x = player.x + Math.cos(teleportAngle) * teleportDistance;
        enemy.y = player.y + Math.sin(teleportAngle) * teleportDistance;
        createFloatingText(oldX, oldY, 'Teleport!', '#FFDD00', 20);
        createFloatingText(enemy.x, enemy.y, '‚ö°', '#FFDD00', 30);
        for (let i = 0; i < 10; i++) {
            particles.push({
                x: oldX,
                y: oldY,
                size: Math.random() * 5 + 3,
                color: '#FFDD00',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                life: 15,
            });
            particles.push({
                x: enemy.x,
                y: enemy.y,
                size: Math.random() * 5 + 3,
                color: '#FFDD00',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                life: 15,
            });
        }
        return;
    } // Apply different movement patterns
    switch (enemy.behavior) {
        case 'follow':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'zigzag':
            enemy.behaviorTimer += deltaTime;
            const zigzagAngle = angle + Math.sin(enemy.behaviorTimer / 500) * 0.5;
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(zigzagAngle) * speed;
                enemy.y += Math.sin(zigzagAngle) * speed;
            }
            break;
        case 'keepDistance':
            const idealDistance = enemy.range * 0.7;
            if (distance < idealDistance - 20) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x -= Math.cos(angle) * speed;
                enemy.y -= Math.sin(angle) * speed;
            } else if (distance > idealDistance + 20) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 0.7;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'kamikaze':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 1.2;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'aggressive':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 1.1;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'flanking':
            if (!enemy.behaviorState.targetAngle) {
                enemy.behaviorState.targetAngle = angle + Math.PI / 2 * (Math.random() < 0.5 ? 1 : -1);
            }
            if (distance > 200) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            } else {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(enemy.behaviorState.targetAngle) * speed;
                enemy.y += Math.sin(enemy.behaviorState.targetAngle) * speed;
                enemy.behaviorTimer += deltaTime;
                if (enemy.behaviorTimer > 2000) {
                    enemy.behaviorTimer = 0;
                    enemy.behaviorState.targetAngle = angle + Math.PI / 2 * (Math.random() < 0.5 ? 1 : -1);
                }
            }
            break;
        case 'phasing':
            if (distance > enemy.size / 2 + player.size / 2) {
                if (!enemy.behaviorState.phasing && Math.random() < 0.01) {
                    enemy.behaviorState.phasing = true;
                    enemy.behaviorState.phaseDuration = Math.random() * 1000 + 500;
                    enemy.behaviorState.phaseTimer = 0;
                }
                if (enemy.behaviorState.phasing) {
                    enemy.behaviorState.phaseTimer += deltaTime;
                    if (enemy.behaviorState.phaseTimer >= enemy.behaviorState.phaseDuration) {
                        enemy.behaviorState.phasing = false;
                    }
                    const phaseAngle = Math.random() * Math.PI * 2;
                    const phaseSpeed = enemy.speed * 2 * deltaTime / 1000;
                    enemy.x += Math.cos(phaseAngle) * phaseSpeed;
                    enemy.y += Math.sin(phaseAngle) * phaseSpeed;
                    if (Math.random() > 0.7) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            size: Math.random() * 5 + 3,
                            color: '#b8c0ff',
                            alpha: 0.5,
                            speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2},
                            life: 10,
                        });
                    }
                } else {
                    const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                    enemy.x += Math.cos(angle) * speed;
                    enemy.y += Math.sin(angle) * speed;
                }
            }
            break;
        case 'swarm':
            enemy.behaviorTimer += deltaTime;
            if (!enemy.behaviorState.offset) {
                enemy.behaviorState.offset = {x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100};
                enemy.behaviorState.offsetTimer = 0;
            }
            enemy.behaviorState.offsetTimer += deltaTime;
            if (enemy.behaviorState.offsetTimer > 2000) {
                enemy.behaviorState.offset = {x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100};
                enemy.behaviorState.offsetTimer = 0;
            }
            if (distance > enemy.size / 2 + player.size / 2) {
                const targetX = player.x + enemy.behaviorState.offset.x;
                const targetY = player.y + enemy.behaviorState.offset.y;
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const swarmAngle = Math.atan2(dy, dx);
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(swarmAngle) * speed;
                enemy.y += Math.sin(swarmAngle) * speed;
            }
            break;
        default:
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
    }
    if (Math.random() > 0.9) {
        particles.push({
            x: enemy.x,
            y: enemy.y + enemy.size / 2,
            size: 3,
            color: '#555',
            alpha: 0.5,
            speed: {x: 0, y: 0},
            life: 10
        });
    }
    if (enemy.type === 'explosive' && !enemy.isBoss && distance < enemy.size / 2 + player.size / 2) {
        enemy.health = 0;
        createExplosion(enemy.x, enemy.y, enemy.explosionRange, enemy.damage);
    }
}

function attackEnemies() {
    const now = Date.now();
    if (now - player.lastAttackTime >= 1000 / player.attackSpeed) {
        player.lastAttackTime = now;
        let nearestEnemy = null;
        let nearestDistance = Infinity;
        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.attackRange && distance < nearestDistance) {
                nearestDistance = distance;
                nearestEnemy = enemy;
            }
        });
        if (nearestEnemy) {
            const shotCount = player.effects.multishot ? 1 + player.effects.multishot : 1;
            for (let i = 0; i < shotCount; i++) {
                const angle = i === 0 ? Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x) : Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x) + (Math.random() - 0.5) * 0.5;
                const isCrit = Math.random() < player.critChance;
                const projectile = {
                    x: player.x,
                    y: player.y,
                    targetX: nearestEnemy.x,
                    targetY: nearestEnemy.y,
                    speed: 400,
                    size: 15,
                    angle: angle,
                    damage: isCrit ? player.damage * player.critMultiplier : player.damage,
                    isCrit: isCrit,
                    emoji: isCrit ? '‚ö°' : 'üîπ',
                    effects: {
                        poisoned: player.effects.poisonAttack > 0 && Math.random() < player.effects.poisonAttack,
                        frozen: player.effects.freezeAttack > 0 && Math.random() < player.effects.freezeAttack,
                        burning: player.effects.burnAttack > 0 && Math.random() < player.effects.burnAttack
                    }
                };
                projectiles.push(projectile);
                for (let j = 0; j < 3; j++) {
                    particles.push({
                        x: player.x + Math.cos(angle) * 20,
                        y: player.y + Math.sin(angle) * 20,
                        size: Math.random() * 4 + 2,
                        color: isCrit ? '#FFD700' : '#4da6ff',
                        alpha: 1,
                        speed: {
                            x: Math.cos(angle) * (Math.random() * 2 + 1),
                            y: Math.sin(angle) * (Math.random() * 2 + 1)
                        },
                        life: 10
                    });
                }
            }
        }
    }
}

// Handle orbiting projectiles
if (player.effects.orbital) {
    const now = Date.now();
    const orbitalCount = Math.min(player.effects.orbital, 3);
    for (let i = 0; i < orbitalCount; i++) {
        const angle = (now / 1000) * (1 + i * 0.2);
        const distance = player.size * 1.5;
        const x = player.x + Math.cos(angle) * distance;
        const y = player.y + Math.sin(angle) * distance; // Draw orbital
        gameCtx.save();
        gameCtx.font = '20px Arial';
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.shadowColor = '#9966FF';
        gameCtx.shadowBlur = 10;
        gameCtx.fillText('üîÆ', x, y);
        gameCtx.restore(); // Check for enemies
        enemies.forEach(enemy => {
            const dx = x - enemy.x;
            const dy = y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < enemy.size / 2 + 10) {
                const damage = player.damage * 0.4;
                enemy.health -= damage;
                if (Math.random() > 0.7) {
                    createFloatingText(enemy.x, enemy.y, Math.round(damage), '#9966FF');
                }
                for (let j = 0; j < 3; j++) {
                    particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        size: Math.random() * 3 + 2,
                        color: '#9966FF',
                        alpha: 0.7,
                        speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                        life: 10
                    });
                }
            }
        })
    }
}
;const rangedEnemies = enemies.filter(e => e.range > 0);
rangedEnemies.forEach(enemy => {
    const now = Date.now();
    if (now - enemy.lastAttackTime >= 1000 / enemy.attackSpeed) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < enemy.range) {
            enemy.lastAttackTime = now;
            const projectile = {
                x: enemy.x,
                y: enemy.y,
                targetX: player.x,
                targetY: player.y,
                speed: enemy.projectileSpeed,
                size: 15,
                angle: Math.atan2(dy, dx),
                damage: enemy.damage,
                emoji: enemy.isElite ? 'üîÆ' : 'üî¥',
                isEnemyProjectile: true,
            };
            projectiles.push(projectile);
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: Math.random() * 5 + 3,
                    color: enemy.isElite ? '#9966ff' : '#ff4d4d',
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                    life: 15,
                });
            }
        }
    }
});

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += Math.cos(p.angle) * p.speed * deltaTime / 1000;
        p.y += Math.sin(p.angle) * p.speed * deltaTime / 1000;
        if (p.x < -50 || p.x > GAME_WIDTH + 50 || p.y < -50 || p.y > GAME_HEIGHT + 50) {
            projectiles.splice(i, 1);
            continue;
        }
        if (!p.isEnemyProjectile) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const dx = p.x - enemy.x;
                const dy = p.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < enemy.collisionRadius) {
                    enemy.health -= p.damage;
                    if (p.effects.poisoned) {
                        enemy.effects.poisoned = {duration: 3000, damage: p.damage * 0.2};
                    }
                    if (p.effects.frozen) {
                        enemy.effects.frozen = {duration: 2000};
                    }
                    if (p.effects.burning) {
                        enemy.effects.burning = {duration: 2500, damage: p.damage * 0.15};
                    }
                    if (p.isCrit) {
                        createFloatingText(enemy.x, enemy.y, `${Math.round(p.damage)}!`, '#FFD700', 24);
                    } else {
                        createFloatingText(enemy.x, enemy.y, Math.round(p.damage), '#FFF');
                    }
                    if (player.effects.vampirism && player.health < player.maxHealth) {
                        const healAmount = p.damage * player.effects.vampirism;
                        player.health = Math.min(player.health + healAmount, player.maxHealth);
                        createFloatingText(player.x, player.y, `+${Math.round(healAmount)}`, '#6FFF6F');
                    }
                    if (enemy.isVampire && enemy.health > 0) {
                        const vampHeal = p.damage * enemy.vampiricStrength;
                        enemy.health = Math.min(enemy.health + vampHeal, enemy.maxHealth);
                        createFloatingText(enemy.x, enemy.y, `+${Math.round(vampHeal)}`, '#800020');
                    }
                    for (let k = 0; k < 5; k++) {
                        particles.push({
                            x: p.x,
                            y: p.y,
                            size: Math.random() * 3 + 2,
                            color: p.isCrit ? '#FFD700' : '#FFF',
                            alpha: 0.8,
                            speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                            life: 15
                        });
                    }
                    projectiles.splice(i, 1);
                    break;
                }
            }
        } else {
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.size / 2 && player.invulnerableTime <= 0) {
                takeDamage(p.damage);
                for (let k = 0; k < 8; k++) {
                    particles.push({
                        x: p.x,
                        y: p.y,
                        size: Math.random() * 5 + 3,
                        color: '#ff4d4d',
                        alpha: 0.8,
                        speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
                        life: 20
                    });
                }
                projectiles.splice(i, 1);
                break;
            }
        }
    }
}

function drawProjectiles() {
    projectiles.forEach(p => {
        gameCtx.save();
        gameCtx.font = `${p.size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        if (p.isCrit) {
            gameCtx.shadowColor = '#FFD700';
            gameCtx.shadowBlur = 10;
        } else if (p.effects && p.effects.poisoned) {
            gameCtx.shadowColor = '#00FF00';
            gameCtx.shadowBlur = 8;
        } else if (p.effects && p.effects.frozen) {
            gameCtx.shadowColor = '#00BFFF';
            gameCtx.shadowBlur = 8;
        } else if (p.effects && p.effects.burning) {
            gameCtx.shadowColor = '#FF4500';
            gameCtx.shadowBlur = 8;
        } else if (p.isEnemyProjectile) {
            gameCtx.shadowColor = '#ff4d4d';
            gameCtx.shadowBlur = 6;
        }
        gameCtx.fillText(p.emoji, p.x, p.y);
        if (Math.random() > 0.7) {
            particles.push({
                x: p.x,
                y: p.y,
                size: Math.random() * 3 + 1,
                color: p.isEnemyProjectile ? '#ff4d4d' : (p.isCrit ? '#FFD700' : '#4da6ff'),
                alpha: 0.6,
                speed: {x: 0, y: 0},
                life: 10
            });
        }
        gameCtx.restore();
    });
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.health <= 0) {
            if (enemy.type === 'explosive') {
                createExplosion(enemy.x, enemy.y, enemy.explosionRange, enemy.damage);
            }
            score += enemy.pointValue;
            killCount++;
            player.kills++;
            comboCount++;
            comboTimer = 3000;
            if (comboCount > highestCombo) {
                highestCombo = comboCount;
            }
            createFloatingText(enemy.x, enemy.y, `+${enemy.pointValue}`, '#FFD700', 20);
            if (comboCount > 1) {
                createFloatingText(enemy.x, enemy.y - 25, `Combo x${comboCount}`, comboCount > 5 ? '#ff4d4d' : '#e9c46a', comboCount > 5 ? 24 : 18);
            }
            experience += enemy.pointValue;
            checkLevelUp();
            checkAchievements();
            if (Math.random() < enemy.dropChance * (player.effects.luckyCharm ? 1 + player.effects.luckyCharm : 1)) {
                dropItem(enemy);
            }
            const particleCount = enemy.isBoss ? 20 : (enemy.isElite ? 12 : 8);
            for (let j = 0; j < particleCount; j++) {
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: Math.random() * 5 + 3,
                    color: enemy.isBoss ? '#ff4d4d' : (enemy.isElite ? '#9966ff' : (enemy.isGhost ? '#b8c0ff' : (enemy.isVampire ? '#800020' : '#4da6ff'))),
                    alpha: 1,
                    speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                    life: 30
                });
            }
            enemies.splice(i, 1);
            if (enemy.isBoss) {
                unlockAchievement('firstBoss');
            }
            continue;
        }
        if (enemy.effects.poisoned) {
            enemy.effects.poisoned.duration -= deltaTime;
            if (enemy.effects.poisoned.duration > 0) {
                enemy.health -= enemy.effects.poisoned.damage * deltaTime / 1000;
                if (Math.random() > 0.8) {
                    createFloatingText(enemy.x + (Math.random() * 20 - 10), enemy.y + (Math.random() * 20 - 10), Math.round(enemy.effects.poisoned.damage * deltaTime / 1000), '#00FF00', 14);
                }
            } else {
                delete enemy.effects.poisoned;
            }
        }
        if (enemy.effects.frozen) {
            enemy.effects.frozen.duration -= deltaTime;
            if (enemy.effects.frozen.duration <= 0) {
                delete enemy.effects.frozen;
            }
        }
        if (enemy.effects.burning) {
            enemy.effects.burning.duration -= deltaTime;
            if (enemy.effects.burning.duration > 0) {
                enemy.health -= enemy.effects.burning.damage * deltaTime / 1000;
                if (Math.random() > 0.8) {
                    createFloatingText(enemy.x + (Math.random() * 20 - 10), enemy.y + (Math.random() * 20 - 10), Math.round(enemy.effects.burning.damage * deltaTime / 1000), '#FF4500', 14);
                }
            } else {
                delete enemy.effects.burning;
            }
        }
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < enemy.collisionRadius + player.size / 2 && enemy.range === 0 && player.invulnerableTime <= 0) {
            const now = Date.now();
            if (now - enemy.lastAttackTime >= 1000) {
                enemy.lastAttackTime = now;
                takeDamage(enemy.damage);
                if (enemy.isVampire) {
                    const vampHeal = enemy.damage * enemy.vampiricStrength;
                    enemy.health = Math.min(enemy.health + vampHeal, enemy.maxHealth);
                    createFloatingText(enemy.x, enemy.y, `+${Math.round(vampHeal)}`, '#800020');
                }
            }
        }
    }
}

function createExplosion(x, y, range, damage) {
    screenShake = 10;
    createFloatingText(x, y, "üí• BOOM!", '#ff4d4d', 28);
    for (let i = 0; i < 30; i++) {
        particles.push({
            x: x,
            y: y,
            size: Math.random() * 10 + 5,
            color: i % 2 === 0 ? '#FF4500' : '#FFD700',
            alpha: 1,
            speed: {x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10},
            life: 40,
        });
    }
    const dx = player.x - x;
    const dy = player.y - y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < range && player.invulnerableTime <= 0) {
        takeDamage(damage * (1 - distance / range));
    }
    enemies.forEach(enemy => {
        if (enemy.x !== x || enemy.y !== y) {
            const dx = enemy.x - x;
            const dy = enemy.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < range) {
                enemy.health -= damage * (1 - distance / range);
                createFloatingText(enemy.x, enemy.y, Math.round(damage * (1 - distance / range)), '#FF4500');
            }
        }
    });
}

function takeDamage(amount) {
    if (player.invulnerableTime > 0) return;
    const shieldReduction = player.effects.shield ? amount * player.effects.shield : 0;
    const finalDamage = amount - shieldReduction;
    player.health -= finalDamage;
    player.invulnerableTime = 500;
    screenShake = 5;
    comboCount = 0;
    comboTimer = 0;
    if (shieldReduction > 0) {
        createFloatingText(player.x, player.y - 20, `Shield: -${Math.round(shieldReduction)}`, '#3498DB');
    }
    createFloatingText(player.x, player.y, `-${Math.round(finalDamage)}`, '#E74C3C', 20);
    if (player.effects.thornAura) {
        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.size * 3) {
                const thornDamage = finalDamage * player.effects.thornAura;
                enemy.health -= thornDamage;
                createFloatingText(enemy.x, enemy.y, Math.round(thornDamage), '#8F8', 16);
                if (player.thornPoisonChance && Math.random() < player.thornPoisonChance) {
                    enemy.effects.poisoned = {duration: 2000, damage: thornDamage * 0.3};
                }
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: Math.random() * 5 + 3,
                    color: '#8F8',
                    alpha: 0.8,
                    speed: {x: 0, y: 0},
                    life: 15
                });
            }
        });
    }
    if (player.health <= 0) {
        gameOver();
    }
}

function dropItem(enemy) {
    let rarityRoll = Math.random();
    let itemPool;
    if (enemy.isBoss) {
        itemPool = itemTypes;
        rarityRoll *= 0.7;
    } else if (enemy.isElite) {
        itemPool = itemTypes;
        rarityRoll *= 0.8;
    } else if (rarityRoll < 0.6) {
        itemPool = itemTypes.filter(item => item.rarity === 'common');
    } else if (rarityRoll < 0.9) {
        itemPool = itemTypes.filter(item => item.rarity === 'uncommon');
    } else {
        itemPool = itemTypes.filter(item => item.rarity === 'rare');
        if (rarityRoll > 0.97) {
            itemPool = itemPool.concat(itemTypes.filter(item => item.rarity === 'legendary'));
        }
    }
    const randomItem = itemPool[Math.floor(Math.random() * itemPool.length)];
    items.push({
        x: enemy.x,
        y: enemy.y,
        size: 30,
        type: randomItem.type,
        emoji: randomItem.emoji,
        name: randomItem.name,
        description: randomItem.description,
        effect: randomItem.effect,
        rarity: randomItem.rarity,
        collectTime: 0,
        hoverTime: 0
    });
    for (let i = 0; i < 5; i++) {
        particles.push({
            x: enemy.x,
            y: enemy.y,
            size: Math.random() * 4 + 2,
            color: getRarityColor(randomItem.rarity),
            alpha: 0.8,
            speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 2},
            life: 20
        });
    }
}

function getRarityColor(rarity) {
    switch (rarity) {
        case 'common':
            return '#b9bbbe';
        case 'uncommon':
            return '#43b581';
        case 'rare':
            return '#4070ff';
        case 'legendary':
            return '#f1c40f';
        default:
            return '#FFF';
    }
}

function drawItems() {
    items.forEach(item => {
        gameCtx.save();
        gameCtx.shadowColor = getRarityColor(item.rarity);
        gameCtx.shadowBlur = 10;
        const scaleFactor = 1 + Math.sin(Date.now() / 200) * 0.1;
        const size = item.size * scaleFactor;
        gameCtx.font = `${size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(item.emoji, item.x, item.y);
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < player.pickupRange * 1.5) {
            item.hoverTime = Math.min(item.hoverTime + deltaTime / 200, 1);
        } else {
            item.hoverTime = Math.max(item.hoverTime - deltaTime / 400, 0);
        }
        if (item.hoverTime > 0.1) {
            gameCtx.globalAlpha = item.hoverTime;
            gameCtx.font = '14px Arial';
            gameCtx.fillStyle = getRarityColor(item.rarity);
            gameCtx.fillText(item.name, item.x, item.y - 20);
            gameCtx.globalAlpha = 1;
        }
        gameCtx.restore();
    });
}

function checkItemPickup() {
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < player.pickupRange) {
            const vx = (player.x - item.x) * 5 * deltaTime / 1000;
            const vy = (player.y - item.y) * 5 * deltaTime / 1000;
            item.x += vx;
            item.y += vy;
        }
        if (distance < player.size / 2) {
            item.collectTime = Date.now();
            itemLabels.push({
                text: `${item.name}`,
                description: item.description,
                x: player.x,
                y: player.y - 40,
                life: 120,
                alpha: 1,
            });
            item.effect(player);
            createFloatingText(player.x, player.y - 20, item.name, getRarityColor(item.rarity), 16);
            unlockAchievement('firstItem');
            for (let j = 0; j < 10; j++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    size: Math.random() * 5 + 2,
                    color: getRarityColor(item.rarity),
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 - 1},
                    life: 20
                });
            }
            items.splice(i, 1);
        }
    }
}

function drawPlayer() {
    gameCtx.save();
    if (player.invulnerableTime > 0) {
        gameCtx.globalAlpha = 0.7;
        gameCtx.shadowColor = '#ccccff';
        gameCtx.shadowBlur = 15;
    }
    if (isDashing) {
        gameCtx.shadowColor = '#00ffff';
        gameCtx.shadowBlur = 20;
        for (let i = 0; i < 5; i++) {
            gameCtx.globalAlpha = 0.15 * (5 - i);
            gameCtx.font = `${player.size}px Arial`;
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.fillText(player.emoji, player.x - dashDirection.x * (i * 10), player.y - dashDirection.y * (i * 10));
        }
        gameCtx.globalAlpha = 1;
    }
    if (effects.rageMode) {
        gameCtx.shadowColor = '#FF0000';
        gameCtx.shadowBlur = 20;
        if (Math.random() > 0.8) {
            particles.push({
                x: player.x + (Math.random() * player.size - player.size / 2),
                y: player.y + (Math.random() * player.size - player.size / 2),
                size: Math.random() * 5 + 3,
                color: '#FF0000',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 - 1},
                life: 15,
            });
        }
    }
    gameCtx.font = `${player.size}px Arial`;
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(player.emoji, player.x, player.y);
    gameCtx.beginPath();
    gameCtx.arc(player.x, player.y, player.attackRange, 0, Math.PI * 2);
    gameCtx.strokeStyle = 'rgba(255,255,255,0.1)';
    gameCtx.stroke();
    if (player.effects.thornAura) {
        gameCtx.save();
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.size * 3, 0, Math.PI * 2);
        gameCtx.strokeStyle = `rgba(0,255,0,${0.3 * player.effects.thornAura})`;
        gameCtx.lineWidth = 2;
        gameCtx.stroke();
        gameCtx.restore();
    }
    if (dashCooldown > 0) {
        const dashReadyPercent = 1 - (dashCooldown / player.dashCooldownTime);
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.size * 0.8, -Math.PI / 2, -Math.PI / 2 + dashReadyPercent * Math.PI * 2);
        gameCtx.strokeStyle = dashReadyPercent < 1 ? 'rgba(100,100,255,0.5)' : 'rgba(100,255,100,0.5)';
        gameCtx.lineWidth = 3;
        gameCtx.stroke();
    }
    if (player.isMoving && Math.random() > 0.8) {
        particles.push({
            x: player.x,
            y: player.y + player.size / 3,
            size: Math.random() * 4 + 2,
            color: '#888',
            alpha: 0.5,
            speed: {x: (Math.random() - 0.5) * 1, y: (Math.random() - 0.5) * 1},
            life: 10
        });
    }
    gameCtx.restore();
}

function movePlayer() {
    if (isUpgrading || isPaused) return;
    if (dashCooldown > 0) {
        dashCooldown -= deltaTime;
    }
    if (isDashing) {
        player.x += dashDirection.x * player.dashSpeed * deltaTime / 1000;
        player.y += dashDirection.y * player.dashSpeed * deltaTime / 1000;
        if (Math.random() > 0.3) {
            particles.push({
                x: player.x - dashDirection.x * 10,
                y: player.y - dashDirection.y * 10,
                size: Math.random() * 5 + 3,
                color: '#4da6ff',
                alpha: 0.6,
                speed: {x: -dashDirection.x * (Math.random() * 2 + 1), y: -dashDirection.y * (Math.random() * 2 + 1)},
                life: 15
            });
        }
        return;
    }
    let moveX = 0;
    let moveY = 0;
    if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;
    if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
    if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;
    if ((keys[' '] || keys['Space']) && dashCooldown <= 0 && (moveX !== 0 || moveY !== 0)) {
        isDashing = true;
        dashDirection = {
            x: moveX / Math.sqrt(moveX * moveX + moveY * moveY),
            y: moveY / Math.sqrt(moveX * moveX + moveY * moveY)
        };
        dashCooldown = player.dashCooldownTime;
        player.invulnerableTime = player.dashDuration;
        for (let i = 0; i < 10; i++) {
            particles.push({
                x: player.x,
                y: player.y,
                size: Math.random() * 6 + 3,
                color: '#4da6ff',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
                life: 20
            });
        }
        setTimeout(() => {
            isDashing = false;
        }, player.dashDuration);
        return;
    }
    if (moveX !== 0 || moveY !== 0) {
        player.isMoving = true;
        const length = Math.sqrt(moveX * moveX + moveY * moveY);
        moveX /= length;
        moveY /= length;
        player.x += moveX * player.speed * deltaTime / 1000;
        player.y += moveY * player.speed * deltaTime / 1000;
        player.direction = moveX < 0 ? -1 : 1;
    } else {
        player.isMoving = false;
    }
    player.x = Math.max(player.size / 2, Math.min(player.x, GAME_WIDTH - player.size / 2));
    player.y = Math.max(player.size / 2, Math.min(player.y, GAME_HEIGHT - player.size / 2));
}

function createFloatingText(x, y, text, color = '#FFF', size = 16) {
    const textObj = {
        x: x,
        y: y,
        text: text,
        color: color,
        size: size,
        alpha: 1,
        life: 50,
        velocity: {x: (Math.random() - 0.5) * 2, y: -2}
    };
    floatingTexts.push(textObj);
}

function updateFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.life--;
        if (t.life <= 0) {
            floatingTexts.splice(i, 1);
            continue;
        }
        t.y += t.velocity.y;
        t.x += t.velocity.x;
        t.alpha = t.life / 50;
    }
}

function drawFloatingTexts() {
    floatingTexts.forEach(t => {
        gameCtx.save();
        gameCtx.globalAlpha = t.alpha;
        gameCtx.font = `${t.size}px Arial`;
        gameCtx.fillStyle = t.color;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(t.text, t.x, t.y);
        gameCtx.restore();
    });
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life--;
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        p.x += p.speed.x;
        p.y += p.speed.y;
        p.size *= 0.95;
        p.alpha = p.life / 40;
    }
}

function drawParticles() {
    particles.forEach(p => {
        gameCtx.save();
        gameCtx.globalAlpha = p.alpha;
        gameCtx.fillStyle = p.color;
        gameCtx.beginPath();
        gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        gameCtx.fill();
        gameCtx.restore();
    });
}

function drawUI() {
    uiCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    uiCtx.font = '24px Arial';
    uiCtx.fillStyle = '#FFF';
    uiCtx.textAlign = 'left';
    uiCtx.fillText(`Score: ${score}`, 20, 30);
    uiCtx.fillText(`Level: ${level}`, 20, 60);
    const timeString = formatTime(gameTime);
    uiCtx.fillText(timeString, 20, 90);
    uiCtx.font = '24px Arial';
    uiCtx.fillStyle = '#f4a261';
    if (specialWave) {
        uiCtx.fillText(`Wave ${waveNumber} - ${specialWave.toUpperCase()}`, 20, 130);
    } else {
        uiCtx.fillText(`Wave ${waveNumber}`, 20, 130);
    }
    uiCtx.fillStyle = '#444';
    uiCtx.fillRect(20, 140, 200, 10);
    uiCtx.fillStyle = '#f4a261';
    uiCtx.fillRect(20, 140, 200 * (waveTimer / waveInterval), 10);
    if (comboCount > 1) {
        uiCtx.save();
        const comboElement = document.querySelector('.combo-counter');
        uiCtx.font = comboCount > 5 ? 'bold 24px Arial' : '20px Arial';
        uiCtx.fillStyle = comboCount > 10 ? '#ff4d4d' : (comboCount > 5 ? '#e76f51' : '#e9c46a');
        if (comboCount > 5) {
            uiCtx.shadowColor = '#000';
            uiCtx.shadowBlur = 3;
        }
        uiCtx.fillText(`Combo: ${comboCount}x`, 20, 180);
        uiCtx.restore();
    }
    if (isEndlessMode) {
        uiCtx.fillStyle = '#e76f51';
        uiCtx.font = 'bold 20px Arial';
        uiCtx.fillText('ENDLESS MODE', 20, 210);
    } // Draw health bar background
    uiCtx.fillStyle = '#264653';
    uiCtx.fillRect(20, GAME_HEIGHT - 40, 300, 20); // Draw health bar fill
    const healthPercent = player.health / player.maxHealth;
    if (healthPercent > 0.6) {
        uiCtx.fillStyle = '#2ecc71';
    } else if (healthPercent > 0.3) {
        uiCtx.fillStyle = '#f39c12';
    } else {
        uiCtx.fillStyle = '#e74c3c';
    }
    uiCtx.fillRect(20, GAME_HEIGHT - 40, 300 * healthPercent, 20); // Draw health text on top of the bar (fixed positioning)
    uiCtx.fillStyle = '#FFF';
    uiCtx.font = '16px Arial';
    uiCtx.fillText(`${Math.ceil(player.health)}/${player.maxHealth}`, 30, GAME_HEIGHT - 28); // XP bar
    uiCtx.fillStyle = '#264653';
    uiCtx.fillRect(20, GAME_HEIGHT - 80, 300, 10);
    uiCtx.fillStyle = '#e9c46a';
    const expPercentage = experience / experienceToNextLevel;
    uiCtx.fillRect(20, GAME_HEIGHT - 80, 300 * expPercentage, 10); // Dash cooldown bar
    if (dashCooldown > 0) {
        uiCtx.fillStyle = '#264653';
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150, 10);
        uiCtx.fillStyle = '#4da6ff';
        const dashReadyPercent = 1 - (dashCooldown / player.dashCooldownTime);
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150 * dashReadyPercent, 10);
        uiCtx.fillStyle = '#FFF';
        uiCtx.font = '12px Arial';
        uiCtx.fillText(`Dash: ${(dashCooldown / 1000).toFixed(1)}s`, 30, GAME_HEIGHT - 65);
    } else {
        uiCtx.fillStyle = '#2ecc71';
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150, 10);
        uiCtx.fillStyle = '#FFF';
        uiCtx.font = '12px Arial';
        uiCtx.fillText(`Dash: Ready!`, 30, GAME_HEIGHT - 65);
    } // Display effects
    let row = 0;
    let col = 0;
    Object.keys(effects).forEach(effectName => {
        const effect = effects[effectName];
        if (effect) {
            const x = GAME_WIDTH - 70 - col * 40;
            const y = 30 + row * 40;
            uiCtx.font = '24px Arial';
            uiCtx.fillText(effect.icon, x, y);
            if (!effect.permanent) {
                uiCtx.font = '12px Arial';
                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(Math.ceil(effect.duration), x - 5, y + 15);
            }
            col++;
            if (col >= 3) {
                col = 0;
                row++;
            }
        }
    });// Display item pickup notifications
    itemLabels.forEach((label, index) => {
        label.life--;
        label.alpha = label.life / 120;
        if (label.life <= 0) {
            itemLabels.splice(index, 1);
        } else {
            uiCtx.save();
            uiCtx.globalAlpha = label.alpha;
            uiCtx.font = 'bold 18px Arial';
            uiCtx.fillStyle = '#FFD700';
            uiCtx.textAlign = 'center';
            uiCtx.fillText(label.text, label.x, label.y);
            uiCtx.font = '14px Arial';
            uiCtx.fillStyle = '#FFF';
            uiCtx.fillText(label.description, label.x, label.y + 20);
            uiCtx.restore();
        }
    });// Display achievements when unlocked
    if (achievementDisplay) {
        uiCtx.save();
        uiCtx.globalAlpha = achievementDisplay.alpha;
        uiCtx.fillStyle = 'rgba(0,0,0,0.8)';
        uiCtx.fillRect(GAME_WIDTH / 2 - 150, 50, 300, 60);
        uiCtx.font = '18px Arial';
        uiCtx.fillStyle = '#FFD700';
        uiCtx.textAlign = 'center';
        uiCtx.fillText('Achievement Unlocked!', GAME_WIDTH / 2, 70);
        uiCtx.font = '16px Arial';
        uiCtx.fillStyle = '#FFF';
        uiCtx.fillText(`${achievementDisplay.emoji} ${achievementDisplay.name}`, GAME_WIDTH / 2, 100);
        uiCtx.restore();
    }
    drawMinimap();
    updateStatsPanel();
}

function drawMinimap() {
    const mapSize = 150;
    const mapX = GAME_WIDTH - mapSize - 20;
    const mapY = 20;
    uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
    uiCtx.fillRect(mapX, mapY, mapSize, mapSize);
    uiCtx.strokeStyle = '#444';
    uiCtx.lineWidth = 2;
    uiCtx.strokeRect(mapX, mapY, mapSize, mapSize);
    const scale = 0.1;
    const visibleRadius = Math.min(GAME_WIDTH, GAME_HEIGHT) / 2;
    const playerMapX = mapX + mapSize / 2;
    const playerMapY = mapY + mapSize / 2;
    uiCtx.fillStyle = '#4da6ff';
    uiCtx.beginPath();
    uiCtx.arc(playerMapX, playerMapY, 4, 0, Math.PI * 2);
    uiCtx.fill();
    enemies.forEach(enemy => {
        const relX = enemy.x - player.x;
        const relY = enemy.y - player.y;
        const distance = Math.sqrt(relX * relX + relY * relY);
        if (distance < visibleRadius * 1.5) {
            const enemyMapX = playerMapX + relX * scale;
            const enemyMapY = playerMapY + relY * scale;
            if (enemyMapX > mapX && enemyMapX < mapX + mapSize && enemyMapY > mapY && enemyMapY < mapY + mapSize) {
                if (enemy.isBoss) {
                    uiCtx.fillStyle = '#ff4d4d';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 3, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isElite) {
                    uiCtx.fillStyle = '#9966ff';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2.5, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isGhost) {
                    uiCtx.fillStyle = '#b8c0ff';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isVampire) {
                    uiCtx.fillStyle = '#800020';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                } else {
                    uiCtx.fillStyle = '#e74c3c';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                }
            }
        }
    });
    items.forEach(item => {
        const relX = item.x - player.x;
        const relY = item.y - player.y;
        const distance = Math.sqrt(relX * relX + relY * relY);
        if (distance < visibleRadius * 1.5) {
            const itemMapX = playerMapX + relX * scale;
            const itemMapY = playerMapY + relY * scale;
            if (itemMapX > mapX && itemMapX < mapX + mapSize && itemMapY > mapY && itemMapY < mapY + mapSize) {
                uiCtx.fillStyle = getRarityColor(item.rarity);
                uiCtx.fillRect(itemMapX - 1.5, itemMapY - 1.5, 3, 3);
            }
        }
    });
}

function updateStatsPanel() {
    statsPanel.innerHTML = `<h3>Player Stats</h3><p>‚ù§Ô∏è Health: ${Math.floor(player.health)}/${player.maxHealth}</p><p>üí™ Damage: ${player.damage.toFixed(1)}</p><p>‚ö° Attack Speed: ${player.attackSpeed.toFixed(2)}/s</p><p>üî≠ Attack Range: ${Math.floor(player.attackRange)}</p><p>üëü Speed: ${Math.floor(player.speed)}</p><p>üß≤ Pickup Range: ${Math.floor(player.pickupRange)}</p><p>‚öîÔ∏è Crit Chance: ${Math.floor(player.critChance * 100)}%</p><p>üéØ Crit Damage: ${Math.floor(player.critMultiplier * 100)}%</p><p>üí® Dash Cooldown: ${(player.dashCooldownTime / 1000).toFixed(1)}s</p><h3>Effects</h3>${player.effects.vampirism ? `<p>üßõ Vampirism: ${Math.floor(player.effects.vampirism * 100)}%</p>` : ''}${player.effects.regeneration ? `<p>üîÑ Regeneration: ${player.effects.regeneration.toFixed(1)}/s</p>` : ''}${player.effects.shield ? `<p>üõ°Ô∏è Shield: ${Math.floor(player.effects.shield * 100)}%</p>` : ''}${player.effects.thornAura ? `<p>üåµ Thorn Aura: ${Math.floor(player.effects.thornAura * 100)}%</p>` : ''}${player.effects.poisonAttack ? `<p>üß™ Poison: ${Math.floor(player.effects.poisonAttack * 100)}%</p>` : ''}${player.effects.freezeAttack ? `<p>‚ùÑÔ∏è Freeze: ${Math.floor(player.effects.freezeAttack * 100)}%</p>` : ''}${player.effects.burnAttack ? `<p>üî• Burn: ${Math.floor(player.effects.burnAttack * 100)}%</p>` : ''}${player.effects.multishot ? `<p>üéØ Multishot: +${player.effects.multishot}</p>` : ''}${player.effects.luckyCharm ? `<p>üçÄ Luck: +${Math.floor(player.effects.luckyCharm * 100)}%</p>` : ''}${player.effects.orbital ? `<p>üîÆ Orbitals: ${player.effects.orbital}</p>` : ''}`;
    if (player.thornPoisonChance) {
        statsPanel.innerHTML += `<p>üåµüß™ Thorn Poison: ${Math.floor(player.thornPoisonChance * 100)}%</p>`;
    }
}

function formatTime(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function checkLevelUp() {
    if (experience >= experienceToNextLevel) {
        experience -= experienceToNextLevel;
        experienceToNextLevel = Math.floor(experienceToNextLevel * 1.15);
        level++;
        isUpgrading = true;
        isPaused = true;
        showUpgradeOptions();
        createFloatingText(player.x, player.y - 40, 'LEVEL UP!', '#3498DB', 28);
        unlockAchievement('firstLevelUp');
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: player.x,
                y: player.y,
                size: Math.random() * 8 + 4,
                color: i % 2 === 0 ? '#3498DB' : '#2ECC71',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 6, y: (Math.random() - 0.5) * 6},
                life: 50
            });
        }
    }
}

function showUpgradeOptions() {
    upgradeOptionsElement.innerHTML = '';
    const shuffled = [...upgradeChoices].sort(() => 0.5 - Math.random());
    const selected = shuffled.slice(0, 3);
    selected.forEach((option, index) => {
        const div = document.createElement('div');
        div.className = 'upgrade-option';
        div.innerHTML = `<div style="font-size:36px;">${option.emoji}</div><h3>${option.name}</h3><p>${option.description}</p>`;
        div.addEventListener('click', () => {
            option.effect();
            closeUpgradeMenu();
            createFloatingText(player.x, player.y - 30, `Upgraded: ${option.name}!`, '#2ECC71', 20);
        });
        upgradeOptionsElement.appendChild(div);
    });
    upgradeMenu.style.display = 'flex';
}

function closeUpgradeMenu() {
    upgradeMenu.style.display = 'none';
    isUpgrading = false;
    isPaused = false;
}

let achievementDisplay = null;

function unlockAchievement(id) {
    const achievement = achievements.find(a => a.id === id);
    if (achievement && !achievement.unlocked) {
        achievement.unlocked = true;
        achievementDisplay = {name: achievement.name, emoji: achievement.emoji, alpha: 1, time: 180};
        setTimeout(() => {
            achievementDisplay = null;
        }, 3000);
    }
}

function checkAchievements() {
    if (killCount >= 1) unlockAchievement('firstKill');
    if (killCount >= 10) unlockAchievement('tenKills');
    if (killCount >= 100) unlockAchievement('hundredKills');
    if (comboCount >= 15) unlockAchievement('maxCombo');
    if (gameTime >= 3 * 60 * 1000) unlockAchievement('threeMinutes');
    if (gameTime >= 10 * 60 * 1000) unlockAchievement('tenMinutes');
    if (isEndlessMode) unlockAchievement('endlessMode');
}

function updateAchievementDisplay() {
    if (achievementDisplay) {
        achievementDisplay.time--;
        achievementDisplay.alpha = achievementDisplay.time / 180;
        if (achievementDisplay.time <= 0) {
            achievementDisplay = null;
        }
    }
}

function startGame() {
    isGameRunning = true;
    isGameOver = false;
    isEndlessMode = false;
    isPaused = false;
    isUpgrading = false;
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    pauseMenu.style.display = 'none';
    statsPanel.style.display = 'block';
    if (isFirstGame) {
        setTimeout(() => {
            tutorialOverlay.style.display = 'flex';
            isPaused = true;
        }, 500);
        isFirstGame = false;
    }
    gameTime = 0;
    lastTime = Date.now();
    score = 0;
    level = 1;
    experience = 0;
    experienceToNextLevel = 75;
    enemySpawnTimer = 0;
    spawnInterval = SPAWN_INTERVAL_BASE;
    waveNumber = 1;
    waveTimer = 0;
    waveInterval = 30000;
    comboCount = 0;
    comboTimer = 0;
    highestCombo = 0;
    screenShake = 0;
    killCount = 0;
    dashCooldown = 0;
    isDashing = false;
    specialWave = false;
    enemies.length = 0;
    items.length = 0;
    projectiles.length = 0;
    particles.length = 0;
    floatingTexts.length = 0;
    effects = {};
    itemLabels = [];
    player.x = CENTER_X;
    player.y = CENTER_Y;
    player.health = 100;
    player.maxHealth = 100;
    player.speed = 200;
    player.damage = 50;
    player.attackSpeed = 2;
    player.attackRange = 200;
    player.pickupRange = 120;
    player.critChance = 0.05;
    player.critMultiplier = 1.5;
    player.dashSpeed = 500;
    player.dashDuration = 300;
    player.dashCooldownTime = 2000;
    player.direction = 1;
    player.effects = {};
    player.invulnerableTime = 0;
    player.kills = 0;
    player.thornPoisonChance = 0; // Reset unlocked achievements
    achievements.forEach(a => a.unlocked = false); // Generate environmental elements
    generateObstacleParticles();
    createEnvironment();
    gameLoop();
}

function gameOver() {
    isGameOver = true;
    isGameRunning = false;
    gameOverScreen.style.display = 'flex';
    statsPanel.style.display = 'none';
    finalTimeSpan.textContent = formatTime(gameTime);
    finalScoreSpan.textContent = score;
    finalKillsSpan.textContent = killCount;
    finalComboSpan.textContent = highestCombo;
    for (let i = 0; i < 30; i++) {
        particles.push({
            x: CENTER_X + (Math.random() - 0.5) * 100,
            y: CENTER_Y + (Math.random() - 0.5) * 100,
            size: Math.random() * 10 + 5,
            color: '#e74c3c',
            alpha: 0.8,
            speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
            life: 40,
        });
    }
}

function updateGameTime() {
    const timeScale = 1;
    const currentTime = Date.now();
    deltaTime = (currentTime - lastTime) * timeScale;
    if (deltaTime > 100 * timeScale) deltaTime = 100 * timeScale;
    gameTime += deltaTime;
    waveTimer += deltaTime;
    if (waveTimer >= waveInterval) {
        waveTimer = 0;
        waveNumber++;
        createFloatingText(CENTER_X, 150, `Wave ${waveNumber}!`, '#f4a261', 32);
        if (waveNumber % 10 === 0) {
            specialWave = 'ghost';
            createFloatingText(CENTER_X, 200, 'Ghost Wave!', '#b8c0ff', 28);
        } else if (waveNumber % 7 === 0) {
            specialWave = 'vampire';
            createFloatingText(CENTER_X, 200, 'Vampire Wave!', '#800020', 28);
        } else if (waveNumber % 9 === 0) {
            specialWave = 'teleporter';
            createFloatingText(CENTER_X, 200, 'Teleporter Wave!', '#FFDD00', 28);
        } else if (waveNumber % 8 === 0) {
            specialWave = 'swarm';
            createFloatingText(CENTER_X, 200, 'Swarm Wave!', '#FFA500', 28);
        } else {
            specialWave = false;
        }
        const waveStartCount = Math.min(5 + Math.floor(waveNumber / 2), 15);
        for (let i = 0; i < waveStartCount; i++) {
            setTimeout(() => {
                spawnEnemy();
            }, i * 300);
        }
    }
    if (gameTime >= ENDLESS_MODE_TIME && !isEndlessMode) {
        isEndlessMode = true;
        createFloatingText(CENTER_X, CENTER_Y - 100, 'ENDLESS MODE ACTIVATED!', '#e76f51', 36);
        unlockAchievement('endlessMode');
        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                particles.push({
                    x: CENTER_X + (Math.random() - 0.5) * GAME_WIDTH * 0.8,
                    y: CENTER_Y + (Math.random() - 0.5) * GAME_HEIGHT * 0.8,
                    size: Math.random() * 10 + 5,
                    color: '#e76f51',
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                    life: 60
                });
            }, i * 50);
        }
    }
    if (comboTimer > 0) {
        comboTimer -= deltaTime;
        if (comboTimer <= 0) {
            comboCount = 0;
        }
    }
    lastTime = currentTime;
}

function updateEnemySpawns() {
    if (isPaused || isUpgrading) return;
    enemySpawnTimer += deltaTime;
    if (isEndlessMode) {
        spawnInterval = SPAWN_INTERVAL_BASE / (1 + (gameTime - ENDLESS_MODE_TIME) / 1000 / 60 * 0.3);
    } else {
        const minutes = gameTime / 60000;
        spawnInterval = SPAWN_INTERVAL_BASE / (1 + minutes * 0.15);
    }
    spawnInterval = Math.max(spawnInterval, 200);
    if (enemySpawnTimer >= spawnInterval) {
        enemySpawnTimer = 0;
        const baseWaveSize = Math.min(1 + Math.floor(gameTime / 60000 * 0.5), 4);
        const waveMultiplier = isEndlessMode ? 1.5 : 1;
        const waveSize = Math.ceil(baseWaveSize * waveMultiplier);
        for (let i = 0; i < waveSize; i++) {
            if (enemies.length < MAX_ENEMIES) {
                spawnEnemy();
            }
        }
    }
}

function updateEffects() {
    Object.keys(effects).forEach(key => {
        if (effects[key] && !effects[key].permanent) {
            effects[key].duration -= deltaTime / 1000;
            if (effects[key].duration <= 0) {
                delete effects[key];
            }
        }
    });
    if (player.effects.regeneration && player.health < player.maxHealth) {
        player.health = Math.min(player.health + player.effects.regeneration * deltaTime / 1000, player.maxHealth);
    }
    if (player.invulnerableTime > 0) {
        player.invulnerableTime -= deltaTime;
    }
    if (screenShake > 0) {
        screenShake -= deltaTime / 50;
        if (screenShake < 0) screenShake = 0;
    }
    if (achievementDisplay) {
        achievementDisplay.alpha = Math.max(0, achievementDisplay.time / 180);
        achievementDisplay.time--;
    }
    updateFPS();
}

function togglePause() {
    if (isGameOver || isUpgrading) return;
    isPaused = !isPaused;
    if (isPaused) {
        pauseMenu.style.display = 'flex';
    } else {
        pauseMenu.style.display = 'none';
        lastTime = Date.now();
    }
}

function toggleStats() {
    if (statsPanel.style.display === 'none' || statsPanel.style.display === '') {
        statsPanel.style.display = 'block';
    } else {
        statsPanel.style.display = 'none';
    }
}

function updateFPS() {
    frameCount++;
    const now = Date.now();
    if (now - lastFpsUpdate > 1000) {
        fps = (frameCount * 1000) / (now - lastFpsUpdate);
        frameCount = 0;
        lastFpsUpdate = now;
        fpsCounter.textContent = `FPS: ${Math.round(fps)}`;
    }
}

function gameLoop() {
    if (!isGameRunning) return;
    frameCount++; // Update FPS counter
    if (Date.now() - lastFpsUpdate > 1000) {
        fps = Math.round((frameCount * 1000) / (Date.now() - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = Date.now();
        fpsCounter.textContent = `FPS: ${fps}`;
    }
    if (!isPaused && !isUpgrading) {
        updateGameTime();
        updateEnemySpawns();
        movePlayer();
        updateEffects();
        moveEnemies();
        attackEnemies();
        updateProjectiles();
        checkItemPickup();
        updateEnemies();
        updateParticles();
        updateFloatingTexts();
        updateAchievementDisplay();
    }
    gameCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    drawBackground();
    drawEnvironment();
    drawItems();
    drawEnemies();
    drawProjectiles();
    drawPlayer();
    drawParticles();
    drawFloatingTexts();
    drawUI();
    if (screenShake > 0) {
        gameCtx.restore();
    }
    if (!isGameOver) {
        requestAnimationFrame(gameLoop);
    }
}

function setupEventListeners() {
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (e.key === 'Escape' && isGameRunning) {
            togglePause();
        }
        if (e.key === 'Tab' && isGameRunning) {
            e.preventDefault();
            toggleStats();
        }
    });
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
    });
    window.addEventListener('mousemove', e => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    window.addEventListener('resize', resizeCanvases);
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
    resumeButton.addEventListener('click', togglePause);
    quitButton.addEventListener('click', () => {
        isPaused = false;
        isGameRunning = false;
        startScreen.style.display = 'flex';
        pauseMenu.style.display = 'none';
        statsPanel.style.display = 'none';
    });
    tutorialCloseButton.addEventListener('click', () => {
        tutorialOverlay.style.display = 'none';
        isPaused = false;
    });
}

function initialize() {
    resizeCanvases();
    generateObstacleParticles();
    createEnvironment();
    setupEventListeners();
}

window.onload = initialize;</script>
</body>
</html>