<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ˜Ž</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
    <title>Emoji Horde Survival v2.0</title>
    <style>* {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none
    }

    body {
        margin: 0;
        overflow: hidden;
        background: #111;
        font-family: Arial, sans-serif;
        color: #fff
    }

    #gameCanvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0
    }

    #uiCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none
    }

    #startScreen, #gameOverScreen, #pauseMenu, #upgradeMenu {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10
    }

    #gameOverScreen, #pauseMenu, #upgradeMenu {
        display: none
    }

    #statsPanel {
        position: absolute;
        right: 20px;
        bottom: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #444;
        border-radius: 5px;
        padding: 10px;
        font-size: 14px;
        display: none;
        z-index: 5
    }

    #emojiSelector {
        display: flex;
        gap: 10px;
        margin: 20px auto;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 80%
    }

    #dashButton {
        position: absolute;
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        right: 20px;
        bottom: 40px;
        z-index: 5;
        opacity: 0.7;
        display: none;
        pointer-events: none
    }

    .emoji-option {
        font-size: 30px;
        cursor: pointer;
        padding: 10px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        transition: all 0.2s
    }

    .emoji-option.selected {
        background: rgba(42, 157, 143, 0.4);
        transform: scale(1.2)
    }

    .emoji-option:hover {
        background: rgba(255, 255, 255, 0.2)
    }

    button {
        padding: 15px 30px;
        font-size: 20px;
        background: #2a9d8f;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin: 10px;
        transition: all 0.2s
    }

    button:hover {
        background: #1d7d7d;
        transform: scale(1.05)
    }

    .upgrade-option {
        width: 200px;
        height: 150px;
        background: rgba(42, 157, 143, 0.2);
        border: 2px solid #2a9d8f;
        border-radius: 10px;
        padding: 15px;
        margin: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s
    }

    .upgrade-option:hover {
        transform: scale(1.05);
        background: rgba(42, 157, 143, 0.4)
    }

    .wave-indicator {
        position: absolute;
        top: 130px;
        left: 20px;
        font-size: 24px;
        color: #f4a261;
        text-shadow: 0 0 5px #000
    }

    .mini-map {
        position: absolute;
        right: 20px;
        top: 20px;
        width: 150px;
        height: 150px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #444;
        border-radius: 5px
    }

    .combo-counter {
        position: absolute;
        left: 20px;
        top: 180px;
        font-size: 20px;
        color: #e9c46a;
        text-shadow: 0 0 5px #000;
        display: none
    }

    .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #264653;
        margin: 5px 0;
        border-radius: 10px;
        overflow: hidden;
        position: relative
    }

    .progress-fill {
        height: 100%;
        background-color: #2a9d8f;
        width: 0%;
        transition: width 0.3s
    }

    .health-bar {
        background-color: #264653;
        border-radius: 10px;
        overflow: hidden
    }

    .health-fill {
        height: 100%;
        background-color: #e76f51;
        transition: width 0.3s
    }

    .xp-bar {
        background-color: #264653;
        border-radius: 10px;
        overflow: hidden
    }

    .xp-fill {
        height: 100%;
        background-color: #e9c46a;
        transition: width 0.3s
    }

    #fpsCounter {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 12px;
        color: rgb(255, 0, 0);
        z-index: 1
    }

    #achievementPopup {
        position: absolute;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #FFD700;
        border-radius: 10px;
        padding: 15px;
        display: none;
        z-index: 10;
        text-align: center
    }

    .tabs {
        display: flex;
        justify-content: center;
        margin-bottom: 20px
    }

    .tab {
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        cursor: pointer;
        border-radius: 5px 5px 0 0
    }

    .tab.active {
        background: rgba(42, 157, 143, 0.4)
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block
    }

    .tab-content[data-tab="game"] {
        text-align: center;
    }

    .how-to-play {
        max-width: 600px;
        margin: 0 auto;
        text-align: left
    }

    .how-to-play h3 {
        margin: 10px 0
    }

    .how-to-play ul {
        margin-left: 20px;
        margin-bottom: 15px
    }

    .emoji-preview {
        font-size: 80px;
        margin: 20px;
        animation: float 2s ease-in-out infinite
    }

    @keyframes float {
        0%, 100% {
            transform: translateY(0)
        }
        50% {
            transform: translateY(-10px)
        }
    }

    .section {
        margin-bottom: 20px
    }

    .section-title {
        font-size: 18px;
        margin-bottom: 10px;
        color: #2a9d8f
    }

    .shake {
        animation: shake 0.5s
    }

    @keyframes shake {
        0%, 100% {
            transform: translateX(0)
        }
        10%, 30%, 50%, 70%, 90% {
            transform: translateX(-5px)
        }
        20%, 40%, 60%, 80% {
            transform: translateX(5px)
        }
    }

    .pulse {
        animation: pulse 0.5s
    }

    @keyframes pulse {
        0% {
            transform: scale(1)
        }
        50% {
            transform: scale(1.1)
        }
        100% {
            transform: scale(1)
        }
    }</style>
</head>
<body>
<div id="gameContainer">
    <div id="startScreen"><h1>EMOJI HORDE SURVIVAL</h1>
        <div class="tabs">
            <div class="tab active" data-tab="game">Play Game</div>
            <div class="tab" data-tab="howto">How to Play</div>
        </div>
        <div class="tab-content active" data-tab="game"><p>Choose your character:</p>
            <div id="emojiSelector"></div>
            <div class="emoji-preview" id="emojiPreview">ðŸ˜Ž</div>
            <button id="startButton">START GAME</button>
        </div>
        <div class="tab-content" data-tab="howto">
            <div class="how-to-play"><h3>How to Play</h3>
                <div class="section">
                    <div class="section-title">Controls:</div>
                    <ul>
                        <li>WASD or Arrow Keys to move</li>
                        <li>SPACE to dash (with invincibility)</li>
                        <li>ESC to pause</li>
                        <li>TAB to toggle stats</li>
                    </ul>
                </div>
                <div class="section">
                    <div class="section-title">Mobile Controls:</div>
                    <ul>
                        <li>Touch and hold where you want to move</li>
                        <li>Double-tap to dash</li>
                        <li>Tap pause to pause</li>
                    </ul>
                </div>
                <div class="section">
                    <div class="section-title">Gameplay:</div>
                    <ul>
                        <li>Survive waves of emoji enemies</li>
                        <li>Collect items to gain power</li>
                        <li>Level up and choose upgrades</li>
                        <li>Special waves every few waves</li>
                        <li>Endless mode after 20 minutes</li>
                    </ul>
                </div>
                <button id="backToGameButton">Back to Game</button>
            </div>
        </div>
    </div>
    <div id="gameOverScreen"><h1>GAME OVER</h1>
        <p>You survived <span id="finalTime">0</span></p>
        <p>Final score: <span id="finalScore">0</span></p>
        <p>Enemies defeated: <span id="finalKills">0</span></p>
        <p>Highest combo: <span id="finalCombo">0</span></p>
        <button id="restartButton">PLAY AGAIN</button>
    </div>
    <div id="pauseMenu"><h1>PAUSED</h1>
        <button id="resumeButton">RESUME</button>
        <button id="quitButton">QUIT TO MENU</button>
    </div>
    <div id="upgradeMenu"><h1>LEVEL UP!</h1>
        <p>Choose an upgrade:</p>
        <div id="upgradeOptions" style="display:flex;flex-wrap:wrap;justify-content:center;max-width:700px"></div>
    </div>
    <div id="statsPanel"></div>
    <div id="fpsCounter">FPS: 0</div>
    <div id="dashButton">ðŸ’¨</div>
    <div id="achievementPopup"><h3>Achievement Unlocked!</h3>
        <p id="achievementName"></p></div>
    <canvas id="gameCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>
</div>
<script>const GAME_WIDTH = window.innerWidth;
const GAME_HEIGHT = window.innerHeight;
const CENTER_X = GAME_WIDTH / 2;
const CENTER_Y = GAME_HEIGHT / 2;
const ENDLESS_MODE_TIME = 20 * 60 * 1000;
const SPAWN_INTERVAL_BASE = 2000;
const MAX_ENEMIES = 300;
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth <= 800);
let useTouchControls = isMobile;
const gameCanvas = document.getElementById('gameCanvas');
const uiCanvas = document.getElementById('uiCanvas');
const gameCtx = gameCanvas.getContext('2d');
const uiCtx = uiCanvas.getContext('2d');
const startScreen = document.getElementById('startScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const pauseMenu = document.getElementById('pauseMenu');
const upgradeMenu = document.getElementById('upgradeMenu');
const statsPanel = document.getElementById('statsPanel');
const emojiSelector = document.getElementById('emojiSelector');
const emojiPreview = document.getElementById('emojiPreview');
const startButton = document.getElementById('startButton');
const restartButton = document.getElementById('restartButton');
const resumeButton = document.getElementById('resumeButton');
const quitButton = document.getElementById('quitButton');
const backToGameButton = document.getElementById('backToGameButton');
const upgradeOptionsElement = document.getElementById('upgradeOptions');
const finalTimeSpan = document.getElementById('finalTime');
const finalScoreSpan = document.getElementById('finalScore');
const finalKillsSpan = document.getElementById('finalKills');
const finalComboSpan = document.getElementById('finalCombo');
const fpsCounter = document.getElementById('fpsCounter');
const dashButton = document.getElementById('dashButton');
const achievementPopup = document.getElementById('achievementPopup');
const achievementName = document.getElementById('achievementName');
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');
let lastTime = 0;
let deltaTime = 0;
let gameTime = 0;
let isGameOver = false;
let isGameRunning = false;
let isPaused = false;
let isEndlessMode = false;
let isUpgrading = false;
let isFirstGame = true;
let score = 0;
let level = 1;
let experience = 0;
let experienceToNextLevel = 75;
let enemySpawnTimer = 0;
let waveNumber = 1;
let waveTimer = 0;
let waveInterval = 30000;
let comboCount = 0;
let comboTimer = 0;
let highestCombo = 0;
let spawnInterval = SPAWN_INTERVAL_BASE;
let lastAttackTime = 0;
let backgroundPattern = null;
let screenShake = 0;
let killCount = 0;
let dashCooldown = 0;
let isDashing = false;
let dashDirection = {x: 0, y: 0};
let specialWave = false;
let selectedEmoji = 'ðŸ˜Ž';
let touchPosition = {x: null, y: null};
let touchActive = false;
let lastTap = 0;
const keys = {};
let mouseX = 0;
let mouseY = 0;
let frameCount = 0;
let fps = 0;
let lastFpsUpdate = 0;
const enemies = [];
const items = [];
const projectiles = [];
const particles = [];
const floatingTexts = [];
let obstacleParticles = [];
let effects = {};
let itemLabels = [];
let environmentalElements = [];
const emojiOptions = ['ðŸ˜Ž', 'ðŸ¥·', 'ðŸ¦¸', 'ðŸ§™', 'ðŸ‘¸', 'ðŸ¦Š', 'ðŸ±', 'ðŸ¤–', 'ðŸ‘½', 'ðŸ‘»', 'ðŸ¦„', 'ðŸ‰', 'ðŸ’€', 'ðŸ‘º', 'ðŸ¤¡'];
const enemyTypes = [{
    type: 'basic',
    emoji: 'ðŸ‘¾',
    health: 35,
    damage: 5,
    speed: 100,
    range: 0,
    pointValue: 10,
    dropChance: 0.12,
    collisionRadius: 20,
    behavior: 'follow'
}, {
    type: 'fast',
    emoji: 'ðŸ€',
    health: 22,
    damage: 3,
    speed: 180,
    range: 0,
    pointValue: 15,
    dropChance: 0.14,
    collisionRadius: 18,
    behavior: 'zigzag'
}, {
    type: 'tank',
    emoji: 'ðŸ¦',
    health: 120,
    damage: 8,
    speed: 60,
    range: 0,
    pointValue: 25,
    dropChance: 0.15,
    collisionRadius: 25,
    behavior: 'follow'
}, {
    type: 'ranged',
    emoji: 'ðŸ§™',
    health: 30,
    damage: 6,
    speed: 70,
    range: 300,
    pointValue: 20,
    attackSpeed: 1.5,
    projectileSpeed: 300,
    dropChance: 0.18,
    collisionRadius: 20,
    behavior: 'keepDistance'
}, {
    type: 'explosive',
    emoji: 'ðŸ’£',
    health: 50,
    damage: 15,
    speed: 90,
    range: 0,
    explosionRange: 150,
    pointValue: 30,
    dropChance: 0.2,
    collisionRadius: 22,
    behavior: 'kamikaze'
}, {
    type: 'boss',
    emoji: 'ðŸ‘¹',
    health: 400,
    damage: 15,
    speed: 70,
    range: 0,
    isBoss: true,
    size: 60,
    pointValue: 100,
    dropChance: 1.0,
    collisionRadius: 40,
    specialAttack: 'summon',
    specialAttackCooldown: 10000,
    behavior: 'aggressive'
}, {
    type: 'elite',
    emoji: 'ðŸ‘¿',
    health: 180,
    damage: 10,
    speed: 120,
    range: 150,
    isElite: true,
    size: 50,
    pointValue: 50,
    attackSpeed: 1.2,
    projectileSpeed: 320,
    dropChance: 0.5,
    collisionRadius: 30,
    behavior: 'flanking'
}, {
    type: 'ghost',
    emoji: 'ðŸ‘»',
    health: 60,
    damage: 7,
    speed: 130,
    range: 0,
    isGhost: true,
    size: 40,
    pointValue: 35,
    dropChance: 0.2,
    collisionRadius: 20,
    behavior: 'phasing'
}, {
    type: 'vampire',
    emoji: 'ðŸ§›',
    health: 100,
    damage: 9,
    speed: 110,
    range: 0,
    isVampire: true,
    size: 45,
    pointValue: 40,
    vampiricStrength: 0.3,
    dropChance: 0.25,
    collisionRadius: 25,
    behavior: 'aggressive'
}, {
    type: 'teleporter',
    emoji: 'âš¡',
    health: 70,
    damage: 8,
    speed: 100,
    range: 0,
    pointValue: 45,
    dropChance: 0.22,
    collisionRadius: 22,
    behavior: 'teleport',
    teleportCooldown: 3000
}, {
    type: 'swarm',
    emoji: 'ðŸ',
    health: 15,
    damage: 2,
    speed: 140,
    range: 0,
    pointValue: 8,
    dropChance: 0.1,
    collisionRadius: 16,
    behavior: 'swarm'
}];
const itemTypes = [{
    type: 'healthUp',
    emoji: 'â¤ï¸',
    name: 'Health Up',
    rarity: 'common',
    description: 'Increases max health by 20',
    effect(p) {
        p.maxHealth += 20;
        p.health = Math.min(p.health + 20, p.maxHealth);
        addEffect('healthUp', 10);
    }
}, {
    type: 'speedUp',
    emoji: 'ðŸ‘Ÿ',
    name: 'Speed Up',
    rarity: 'common',
    description: 'Increases movement speed by 20',
    effect(p) {
        p.speed += 20;
        addEffect('speedUp', 10);
    }
}, {
    type: 'damageUp', emoji: 'ðŸ’ª', name: 'Damage Up', rarity: 'common', description: 'Increases damage by 2', effect(p) {
        p.damage += 2;
        addEffect('damageUp', 10);
    }
}, {
    type: 'attackSpeedUp',
    emoji: 'âš¡',
    name: 'Attack Speed Up',
    rarity: 'common',
    description: 'Increases attack speed by 0.15',
    effect(p) {
        p.attackSpeed += 0.15;
        addEffect('attackSpeedUp', 10);
    }
}, {
    type: 'rangeUp',
    emoji: 'ðŸ”­',
    name: 'Range Up',
    rarity: 'common',
    description: 'Increases attack and pickup range',
    effect(p) {
        p.attackRange += 30;
        p.pickupRange += 10;
        addEffect('rangeUp', 10);
    }
}, {
    type: 'vampirism',
    emoji: 'ðŸ§›',
    name: 'Vampirism',
    rarity: 'uncommon',
    description: 'Heal for 5% of damage dealt',
    effect(p) {
        if (!p.effects.vampirism) p.effects.vampirism = 0;
        p.effects.vampirism += 0.05;
        addEffect('vampirism');
        if (p.effects.burnAttack) {
            p.effects.burnAttack += 0.05;
            createFloatingText(p.x, p.y - 30, 'Synergy: Vampiric Fire!', '#FF6600', 18);
        }
    }
}, {
    type: 'poisonAttack',
    emoji: 'ðŸ§ª',
    name: 'Poison Attack',
    rarity: 'uncommon',
    description: '30% chance to poison enemies',
    effect(p) {
        if (!p.effects.poisonAttack) p.effects.poisonAttack = 0;
        p.effects.poisonAttack += 0.3;
        addEffect('poisonAttack');
        if (p.effects.freezeAttack) {
            p.damage += 3;
            createFloatingText(p.x, p.y - 30, 'Synergy: Chemical Frost!', '#00FFAA', 18);
        }
    }
}, {
    type: 'freezeAttack',
    emoji: 'â„ï¸',
    name: 'Freeze Attack',
    rarity: 'uncommon',
    description: '20% chance to freeze enemies',
    effect(p) {
        if (!p.effects.freezeAttack) p.effects.freezeAttack = 0;
        p.effects.freezeAttack += 0.2;
        addEffect('freezeAttack');
        if (p.effects.thornAura) {
            p.effects.thornAura += 0.1;
            createFloatingText(p.x, p.y - 30, 'Synergy: Frost Thorns!', '#66CCFF', 18);
        }
    }
}, {
    type: 'burnAttack',
    emoji: 'ðŸ”¥',
    name: 'Burn Attack',
    rarity: 'uncommon',
    description: '25% chance to burn enemies',
    effect(p) {
        if (!p.effects.burnAttack) p.effects.burnAttack = 0;
        p.effects.burnAttack += 0.25;
        addEffect('burnAttack');
        if (p.effects.multishot) {
            p.attackSpeed += 0.15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Rapid Fire!', '#FF4500', 18);
        }
    }
}, {
    type: 'magnet',
    emoji: 'ðŸ§²',
    name: 'Magnet',
    rarity: 'uncommon',
    description: 'Increases item pickup range by 50',
    effect(p) {
        p.pickupRange += 50;
        addEffect('magnet', 10);
        if (p.effects.luckyCharm) {
            p.pickupRange += 20;
            createFloatingText(p.x, p.y - 30, 'Synergy: Fortune Magnet!', '#FFD700', 18);
        }
    }
}, {
    type: 'shield', emoji: 'ðŸ›¡ï¸', name: 'Shield', rarity: 'rare', description: 'Reduces damage taken by 10%', effect(p) {
        if (!p.effects.shield) p.effects.shield = 0;
        p.effects.shield += 0.1;
        addEffect('shield');
        if (p.effects.regeneration) {
            p.maxHealth += 15;
            p.health += 15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Vital Shield!', '#5CCCCC', 18);
        }
    }
}, {
    type: 'luckyCharm',
    emoji: 'ðŸ€',
    name: 'Lucky Charm',
    rarity: 'rare',
    description: '+10% item drop chance, +3% crit chance',
    effect(p) {
        if (!p.effects.luckyCharm) p.effects.luckyCharm = 0;
        p.effects.luckyCharm += 0.1;
        p.critChance += 0.03;
        addEffect('luckyCharm');
    }
}, {
    type: 'regeneration',
    emoji: 'ðŸ”„',
    name: 'Regeneration',
    rarity: 'rare',
    description: 'Heal 1 health per second',
    effect(p) {
        if (!p.effects.regeneration) p.effects.regeneration = 0;
        p.effects.regeneration += 1;
        addEffect('regeneration');
    }
}, {
    type: 'thornAura',
    emoji: 'ðŸŒµ',
    name: 'Thorn Aura',
    rarity: 'rare',
    description: 'Damages nearby enemies',
    effect(p) {
        if (!p.effects.thornAura) p.effects.thornAura = 0;
        p.effects.thornAura += 0.3;
        addEffect('thornAura');
        if (p.effects.poisonAttack) {
            p.thornPoisonChance = 0.2;
            createFloatingText(p.x, p.y - 30, 'Synergy: Toxic Thorns!', '#00CC00', 18);
        }
    }
}, {
    type: 'multishot',
    emoji: 'ðŸŽ¯',
    name: 'Multishot',
    rarity: 'legendary',
    description: 'Fire an additional projectile',
    effect(p) {
        if (!p.effects.multishot) p.effects.multishot = 0;
        p.effects.multishot += 1;
        addEffect('multishot');
    }
}, {
    type: 'dashMastery',
    emoji: 'ðŸ’¨',
    name: 'Dash Mastery',
    rarity: 'legendary',
    description: 'Reduces dash cooldown by 25%',
    effect(p) {
        p.dashCooldownTime *= 0.75;
        addEffect('dashMastery');
        if (p.effects.speedUp) {
            p.dashSpeed += 50;
            createFloatingText(p.x, p.y - 30, 'Synergy: Rapid Dash!', '#00AAFF', 18);
        }
    }
}, {
    type: 'criticalStrike',
    emoji: 'âš”ï¸',
    name: 'Critical Strike',
    rarity: 'legendary',
    description: '+10% crit chance, +20% crit damage',
    effect(p) {
        p.critChance += 0.1;
        p.critMultiplier += 0.2;
        addEffect('criticalStrike');
        if (p.effects.multishot) {
            p.critMultiplier += 0.15;
            createFloatingText(p.x, p.y - 30, 'Synergy: Critical Barrage!', '#FF00AA', 18);
        }
    }
}, {
    type: 'nukeBomb',
    emoji: 'â˜¢ï¸',
    name: 'Nuke Bomb',
    rarity: 'legendary',
    description: 'Damages all enemies on screen',
    effect(p) {
        enemies.forEach(enemy => {
            const damage = p.damage * 3;
            enemy.health -= damage;
            createFloatingText(enemy.x, enemy.y, Math.round(damage), '#ff4d4d', 20);
        });
        createFloatingText(p.x, p.y, 'ðŸ’¥ BOOM!', '#ff4d4d', 36);
        screenShake = 15;
        for (let i = 0; i < 50; i++) {
            particles.push({
                x: CENTER_X + (Math.random() - 0.5) * GAME_WIDTH * 0.8,
                y: CENTER_Y + (Math.random() - 0.5) * GAME_HEIGHT * 0.8,
                size: Math.random() * 10 + 5,
                color: '#ff4d4d',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                life: 60,
            });
        }
    },
}, {
    type: 'orbital',
    emoji: 'ðŸ”®',
    name: 'Orbital',
    rarity: 'legendary',
    description: 'Creates a projectile that orbits you',
    effect(p) {
        if (!p.effects.orbital) p.effects.orbital = 0;
        p.effects.orbital += 1;
        addEffect('orbital');
        createFloatingText(p.x, p.y - 30, 'Orbital Protection', '#9966FF', 18);
    }
}, {
    type: 'rageMode',
    emoji: 'ðŸ˜¡',
    name: 'Rage Mode',
    rarity: 'legendary',
    description: 'Temporarily massively increases damage and speed',
    effect(p) {
        p.damage *= 1.5;
        p.speed *= 1.3;
        p.attackSpeed *= 1.3;
        addEffect('rageMode', 20);
        createFloatingText(p.x, p.y, 'RAGE MODE ACTIVATED!', '#FF0000', 30);
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: p.x,
                y: p.y,
                size: Math.random() * 10 + 5,
                color: '#FF0000',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8},
                life: 40,
            });
        }
    }
}];
const upgradeChoices = [{
    name: 'Health Boost', emoji: 'â¤ï¸', description: 'Increase max health by 25', effect() {
        player.maxHealth += 25;
        player.health += 25;
    }
}, {
    name: 'Attack Damage', emoji: 'ðŸ’ª', description: 'Increase damage by 20%', effect() {
        player.damage *= 1.2;
    }
}, {
    name: 'Attack Speed', emoji: 'âš¡', description: 'Increase attack speed by 0.5', effect() {
        player.attackSpeed += .5;
    }
}, {
    name: 'Movement Speed', emoji: 'ðŸ‘Ÿ', description: 'Increase movement speed by 25', effect() {
        player.speed += 25;
    }
}, {
    name: 'Attack Range', emoji: 'ðŸ”­', description: 'Increase attack range by 40', effect() {
        player.attackRange += 40;
    }
}, {
    name: 'Dash Power', emoji: 'ðŸ’¨', description: 'Reduce dash cooldown by 15%', effect() {
        player.dashCooldownTime *= 0.85;
    }
}, {
    name: 'Critical Strikes', emoji: 'âš”ï¸', description: 'Increase crit chance by 5%', effect() {
        player.critChance += 0.05;
    }
}, {
    name: 'Pickup Range', emoji: 'ðŸ§²', description: 'Increase item pickup range by 40', effect() {
        player.pickupRange += 40;
    }
}, {
    name: 'Regeneration', emoji: 'ðŸ”„', description: 'Regenerate 0.5 health per second', effect() {
        if (!player.effects.regeneration) player.effects.regeneration = 0;
        player.effects.regeneration += 0.5;
    }
}, {
    name: 'Vampiric Touch', emoji: 'ðŸ§›', description: 'Gain 3% lifesteal on hit', effect() {
        if (!player.effects.vampirism) player.effects.vampirism = 0;
        player.effects.vampirism += 0.03;
    }
}, {
    name: 'Toxic Attacks', emoji: 'ðŸ§ª', description: '15% chance to poison enemies', effect() {
        if (!player.effects.poisonAttack) player.effects.poisonAttack = 0;
        player.effects.poisonAttack += 0.15;
    }
}, {
    name: 'Icy Projectiles', emoji: 'â„ï¸', description: '15% chance to freeze enemies', effect() {
        if (!player.effects.freezeAttack) player.effects.freezeAttack = 0;
        player.effects.freezeAttack += 0.15;
    }
}, {
    name: 'Flame Aura', emoji: 'ðŸ”¥', description: '15% chance to burn enemies', effect() {
        if (!player.effects.burnAttack) player.effects.burnAttack = 0;
        player.effects.burnAttack += 0.15;
    }
}, {
    name: 'Shield Matrix', emoji: 'ðŸ›¡ï¸', description: 'Reduce damage taken by 7%', effect() {
        if (!player.effects.shield) player.effects.shield = 0;
        player.effects.shield += 0.07;
    }
}, {
    name: 'Lucky Strikes', emoji: 'ðŸ€', description: 'Increase crit damage by 15%', effect() {
        player.critMultiplier += 0.15;
    }
}, {
    name: 'Thorn Barrier', emoji: 'ðŸŒµ', description: 'Damage enemies that hit you', effect() {
        if (!player.effects.thornAura) player.effects.thornAura = 0;
        player.effects.thornAura += 0.15;
    }
}];
const achievements = [{
    id: 'firstKill',
    name: 'First Blood',
    description: 'Defeat your first enemy',
    unlocked: false,
    emoji: 'ðŸ©¸'
}, {
    id: 'tenKills',
    name: 'Beginner Slayer',
    description: 'Defeat 10 enemies',
    unlocked: false,
    emoji: 'âš”ï¸'
}, {
    id: 'hundredKills',
    name: 'Horde Destroyer',
    description: 'Defeat 100 enemies',
    unlocked: false,
    emoji: 'ðŸ’¥'
}, {
    id: 'firstBoss',
    name: 'Boss Slayer',
    description: 'Defeat your first boss',
    unlocked: false,
    emoji: 'ðŸ‘‘'
}, {
    id: 'maxCombo',
    name: 'Combo Master',
    description: 'Get a 15+ combo',
    unlocked: false,
    emoji: 'ðŸ”„'
}, {
    id: 'firstItem',
    name: 'Collector',
    description: 'Collect your first item',
    unlocked: false,
    emoji: 'ðŸŽ'
}, {
    id: 'firstLevelUp',
    name: 'Level Up',
    description: 'Reach level 2',
    unlocked: false,
    emoji: 'â­'
}, {
    id: 'threeMinutes',
    name: 'Survivor',
    description: 'Survive for 3 minutes',
    unlocked: false,
    emoji: 'â±ï¸'
}, {
    id: 'tenMinutes',
    name: 'Veteran',
    description: 'Survive for 10 minutes',
    unlocked: false,
    emoji: 'ðŸ†'
}, {id: 'endlessMode', name: 'Endless Warrior', description: 'Enter endless mode', unlocked: false, emoji: 'â™¾ï¸'}];
const player = {
    x: CENTER_X,
    y: CENTER_Y,
    size: 40,
    speed: 200,
    dashSpeed: 500,
    dashDuration: 300,
    dashCooldownTime: 2000,
    health: 100,
    maxHealth: 100,
    damage: 12,
    attackSpeed: 1.1,
    attackRange: 200,
    pickupRange: 120,
    critChance: 0.05,
    critMultiplier: 1.5,
    emoji: 'ðŸ˜Ž',
    direction: 1,
    isMoving: false,
    lastAttackTime: 0,
    effects: {},
    invulnerableTime: 0,
    kills: 0
};

function setupEmojiSelector() {
    emojiSelector.innerHTML = '';
    emojiOptions.forEach(emoji => {
        const div = document.createElement('div');
        div.className = 'emoji-option';
        div.textContent = emoji;
        if (emoji === selectedEmoji) {
            div.classList.add('selected');
        }
        div.addEventListener('click', () => {
            document.querySelectorAll('.emoji-option').forEach(el => el.classList.remove('selected'));
            div.classList.add('selected');
            selectedEmoji = emoji;
            emojiPreview.textContent = emoji;
            player.emoji = emoji;
        });
        emojiSelector.appendChild(div);
    });
}

function setupMobileControls() {
    if (isMobile) {
        dashButton.style.display = 'flex';
        dashButton.style.opacity = '0.5';
        dashButton.style.pointerEvents = 'none';
        gameCanvas.addEventListener('touchstart', handleTouchStart);
        gameCanvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        gameCanvas.addEventListener('touchend', handleTouchEnd);
        gameCanvas.addEventListener('touchcancel', handleTouchEnd);
    }
}

function handleTouchStart(e) {
    if (!isGameRunning || isPaused || isUpgrading) return;
    e.preventDefault();
    const touch = e.touches[0];
    touchPosition = {x: touch.clientX, y: touch.clientY};
    touchActive = true;
    const now = Date.now();
    const timeSinceLastTap = now - lastTap;
    if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
        triggerDash();
    }
    lastTap = now;
}

function handleTouchMove(e) {
    if (!touchActive || !isGameRunning || isPaused || isUpgrading) return;
    e.preventDefault();
    const touch = e.touches[0];
    touchPosition = {x: touch.clientX, y: touch.clientY};
}

function handleTouchEnd(e) {
    touchActive = false;
    touchPosition = {x: null, y: null};
}

function triggerDash() {
    if (dashCooldown <= 0 && !isDashing) {
        const moveX = touchPosition.x - player.x;
        const moveY = touchPosition.y - player.y;
        const touchDistance = Math.sqrt(moveX * moveX + moveY * moveY);
        if (touchDistance > 10) {
            isDashing = true;
            dashDirection = {x: moveX / touchDistance, y: moveY / touchDistance};
            dashCooldown = player.dashCooldownTime;
            player.invulnerableTime = player.dashDuration;
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    size: Math.random() * 6 + 3,
                    color: '#4da6ff',
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
                    life: 20
                });
            }
            setTimeout(() => {
                isDashing = false;
            }, player.dashDuration);
        }
    }
}

function createEnvironment() {
    environmentalElements = [];
    const rockCount = Math.floor(Math.random() * 10) + 10;
    for (let i = 0; i < rockCount; i++) {
        environmentalElements.push({
            type: 'rock',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 20 + 10,
            emoji: 'ðŸª¨'
        });
    }
    const flowerCount = Math.floor(Math.random() * 15) + 5;
    for (let i = 0; i < flowerCount; i++) {
        environmentalElements.push({
            type: 'flower',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 15 + 10,
            emoji: ['ðŸŒ¼', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»'][Math.floor(Math.random() * 4)]
        });
    }
    const treeCount = Math.floor(Math.random() * 5) + 3;
    for (let i = 0; i < treeCount; i++) {
        environmentalElements.push({
            type: 'tree',
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 30 + 20,
            emoji: 'ðŸŒ³'
        });
    }
}

function drawEnvironment() {
    environmentalElements.forEach(element => {
        gameCtx.save();
        gameCtx.globalAlpha = 0.6;
        gameCtx.font = `${element.size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(element.emoji, element.x, element.y);
        gameCtx.restore();
    });
}

const GRID_SIZE = 100;
let spatialGrid = {};

function updateSpatialGrid() {
    spatialGrid = {};
    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        const gridX = Math.floor(enemy.x / GRID_SIZE);
        const gridY = Math.floor(enemy.y / GRID_SIZE);
        const key = `${gridX},${gridY}`;
        if (!spatialGrid[key]) {
            spatialGrid[key] = [];
        }
        spatialGrid[key].push(enemy);
    }
}

function getNeighbors(entity) {
    const neighbors = [];
    const gridX = Math.floor(entity.x / GRID_SIZE);
    const gridY = Math.floor(entity.y / GRID_SIZE);
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            const key = `${gridX + x},${gridY + y}`;
            if (spatialGrid[key]) {
                neighbors.push(...spatialGrid[key]);
            }
        }
    }
    return neighbors;
}

function addEffect(effectName, duration = null) {
    if (duration) {
        effects[effectName] = {duration: duration, icon: getEffectIcon(effectName)};
    } else {
        effects[effectName] = {permanent: true, icon: getEffectIcon(effectName)};
    }
}

function getEffectIcon(effectName) {
    switch (effectName) {
        case 'healthUp':
            return 'â¤ï¸';
        case 'speedUp':
            return 'ðŸ‘Ÿ';
        case 'damageUp':
            return 'ðŸ’ª';
        case 'attackSpeedUp':
            return 'âš¡';
        case 'rangeUp':
            return 'ðŸ”­';
        case 'vampirism':
            return 'ðŸ§›';
        case 'poisonAttack':
            return 'ðŸ§ª';
        case 'freezeAttack':
            return 'â„ï¸';
        case 'burnAttack':
            return 'ðŸ”¥';
        case 'magnet':
            return 'ðŸ§²';
        case 'shield':
            return 'ðŸ›¡ï¸';
        case 'luckyCharm':
            return 'ðŸ€';
        case 'regeneration':
            return 'ðŸ”„';
        case 'thornAura':
            return 'ðŸŒµ';
        case 'multishot':
            return 'ðŸŽ¯';
        case 'dashMastery':
            return 'ðŸ’¨';
        case 'criticalStrike':
            return 'âš”ï¸';
        case 'orbital':
            return 'ðŸ”®';
        case 'rageMode':
            return 'ðŸ˜¡';
        default:
            return 'â“';
    }
}

function resizeCanvases() {
    gameCanvas.width = window.innerWidth;
    gameCanvas.height = window.innerHeight;
    uiCanvas.width = window.innerWidth;
    uiCanvas.height = window.innerHeight;
    createBackgroundPattern();
}

function createBackgroundPattern() {
    const patternCanvas = document.createElement('canvas');
    const patternContext = patternCanvas.getContext('2d');
    patternCanvas.width = 150;
    patternCanvas.height = 150;
    patternContext.fillStyle = '#121212';
    patternContext.fillRect(0, 0, 150, 150);
    patternContext.strokeStyle = '#1a1a1a';
    patternContext.lineWidth = 1;
    patternContext.beginPath();
    for (let i = 0; i <= 150; i += 20) {
        patternContext.moveTo(i, 0);
        patternContext.lineTo(i, 150);
        patternContext.moveTo(0, i);
        patternContext.lineTo(150, i);
    }
    patternContext.stroke();
    patternContext.fillStyle = '#222';
    for (let i = 0; i < 25; i++) {
        const x = Math.random() * 150;
        const y = Math.random() * 150;
        const radius = Math.random() * 2 + 1;
        patternContext.beginPath();
        patternContext.arc(x, y, radius, 0, Math.PI * 2);
        patternContext.fill();
    }
    for (let i = 0; i < obstacleParticles.length; i++) {
        const p = obstacleParticles[i];
        patternContext.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a})`;
        patternContext.beginPath();
        patternContext.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        patternContext.fill();
    }
    backgroundPattern = gameCtx.createPattern(patternCanvas, 'repeat');
}

function generateObstacleParticles() {
    obstacleParticles = [];
    for (let i = 0; i < 40; i++) {
        obstacleParticles.push({
            x: Math.random() * 150,
            y: Math.random() * 150,
            size: Math.random() * 3 + 1,
            r: Math.floor(Math.random() * 40) + 30,
            g: Math.floor(Math.random() * 40) + 30,
            b: Math.floor(Math.random() * 60) + 40,
            a: Math.random() * 0.3 + 0.1
        });
    }
}

function drawBackground() {
    gameCtx.fillStyle = backgroundPattern;
    gameCtx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    if (screenShake > 0) {
        gameCtx.save();
        const shakeX = (Math.random() - 0.5) * screenShake * 2;
        const shakeY = (Math.random() - 0.5) * screenShake * 2;
        gameCtx.translate(shakeX, shakeY);
    }
}

function spawnEnemy() {
    if (enemies.length >= MAX_ENEMIES) return;
    const spawnDistance = Math.max(GAME_WIDTH, GAME_HEIGHT) / 2 + 100;
    const angle = Math.random() * Math.PI * 2;
    const spawnX = CENTER_X + Math.cos(angle) * spawnDistance;
    const spawnY = CENTER_Y + Math.sin(angle) * spawnDistance;
    let typeIndex;
    const minutes = gameTime / 60000;
    const waveProgress = waveTimer / waveInterval;
    if (specialWave) {
        if (specialWave === 'ghost') {
            typeIndex = 7;
        } else if (specialWave === 'vampire') {
            typeIndex = 8;
        } else if (specialWave === 'teleporter') {
            typeIndex = 9;
        } else if (specialWave === 'swarm') {
            typeIndex = 10;
        } else {
            typeIndex = Math.floor(Math.random() * 5);
        }
    } else if (gameTime > ENDLESS_MODE_TIME) {
        if (Math.random() < 0.08) {
            typeIndex = 5;
        } else if (Math.random() < 0.2) {
            typeIndex = 6;
        } else if (Math.random() < 0.12) {
            typeIndex = 7;
        } else if (Math.random() < 0.12) {
            typeIndex = 8;
        } else if (Math.random() < 0.1) {
            typeIndex = 9;
        } else if (Math.random() < 0.1) {
            typeIndex = 10;
        } else {
            typeIndex = Math.floor(Math.random() * 5);
        }
    } else {
        if (minutes < 1) {
            typeIndex = 0;
        } else if (minutes < 3) {
            typeIndex = Math.random() < 0.75 ? 0 : 1;
        } else if (minutes < 6) {
            typeIndex = Math.floor(Math.random() * 3);
        } else if (minutes < 10) {
            typeIndex = Math.floor(Math.random() * 4);
        } else if (minutes < 15) {
            typeIndex = Math.floor(Math.random() * 5);
        } else {
            typeIndex = Math.floor(Math.random() * enemyTypes.length - 2);
        }
    }
    const shouldSpawnBoss = (waveNumber % 5 === 0 && waveProgress > 0.7 && enemies.filter(e => e.isBoss).length < 1);
    if (shouldSpawnBoss) {
        typeIndex = 5;
    }
    const shouldSpawnElite = (waveNumber % 3 === 0 && waveProgress > 0.5 && enemies.filter(e => e.isElite).length < 3);
    if (shouldSpawnElite && !shouldSpawnBoss && minutes > 5) {
        typeIndex = 6;
    }
    const type = enemyTypes[typeIndex];
    const waveMultiplier = 1 + (waveNumber - 1) * 0.08;
    const timeMultiplier = 1 + (minutes * 0.03);
    const endlessMultiplier = isEndlessMode ? 1 + ((gameTime - ENDLESS_MODE_TIME) / 1000 / 60) * 0.2 : 1;
    const healthMultiplier = waveMultiplier * timeMultiplier * endlessMultiplier;
    const damageMultiplier = waveMultiplier * endlessMultiplier;
    const enemy = {
        x: spawnX,
        y: spawnY,
        health: type.health * healthMultiplier,
        maxHealth: type.health * healthMultiplier,
        damage: type.damage * damageMultiplier,
        speed: type.speed,
        range: type.range || 0,
        size: type.size || 40,
        type: type.type,
        emoji: type.emoji,
        isBoss: type.isBoss || false,
        isElite: type.isElite || false,
        isGhost: type.isGhost || false,
        isVampire: type.isVampire || false,
        vampiricStrength: type.vampiricStrength || 0,
        lastAttackTime: 0,
        attackSpeed: type.attackSpeed || 1,
        projectileSpeed: type.projectileSpeed,
        explosionRange: type.explosionRange,
        pointValue: type.pointValue,
        dropChance: type.dropChance,
        collisionRadius: type.collisionRadius || 20,
        behavior: type.behavior || 'follow',
        behaviorTimer: 0,
        behaviorState: {},
        effects: {},
        specialAttack: type.specialAttack,
        specialAttackCooldown: type.specialAttackCooldown,
        lastSpecialAttack: 0,
        teleportCooldown: type.teleportCooldown,
        lastTeleport: 0,
    };
    enemies.push(enemy);
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: spawnX,
            y: spawnY,
            size: Math.random() * 5 + 5,
            color: enemy.isBoss ? '#ff4d4d' : (enemy.isElite ? '#9966ff' : (enemy.isGhost ? '#b8c0ff' : (enemy.isVampire ? '#800020' : '#4da6ff'))),
            alpha: 1,
            speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
            life: 20,
        });
    }
}

function drawEnemy(enemy) {
    let x = enemy.x;
    let y = enemy.y;
    const isFrozen = enemy.effects.frozen;
    gameCtx.save();
    if (isFrozen) {
        gameCtx.globalAlpha = 0.8;
        gameCtx.shadowColor = '#00BFFF';
        gameCtx.shadowBlur = 10;
    }
    if (enemy.isGhost) {
        gameCtx.globalAlpha = 0.7;
    }
    if (enemy.effects.burning) {
        if (Math.random() > 0.7) {
            particles.push({
                x: enemy.x + (Math.random() * enemy.size - enemy.size / 2),
                y: enemy.y + (Math.random() * enemy.size - enemy.size / 2),
                size: Math.random() * 5 + 5,
                color: '#FF4500',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 2},
                life: 30,
            });
        }
    }
    if (enemy.effects.poisoned) {
        if (Math.random() > 0.7) {
            particles.push({
                x: enemy.x + (Math.random() * enemy.size - enemy.size / 2),
                y: enemy.y + (Math.random() * enemy.size - enemy.size / 2),
                size: Math.random() * 5 + 3,
                color: '#00FF00',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 1},
                life: 20,
            });
        }
    }
    if (enemy.isBoss) {
        gameCtx.shadowColor = '#ff4d4d';
        gameCtx.shadowBlur = 15;
    } else if (enemy.isElite) {
        gameCtx.shadowColor = '#9966ff';
        gameCtx.shadowBlur = 10;
    } else if (enemy.isGhost) {
        gameCtx.shadowColor = '#b8c0ff';
        gameCtx.shadowBlur = 8;
    } else if (enemy.isVampire) {
        gameCtx.shadowColor = '#800020';
        gameCtx.shadowBlur = 12;
    } else if (enemy.type === 'teleporter') {
        gameCtx.shadowColor = '#FFDD00';
        gameCtx.shadowBlur = 10;
    }
    gameCtx.font = `${enemy.size}px Arial`;
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(enemy.emoji, x, y);
    if (enemy.health < enemy.maxHealth) {
        const healthBarWidth = enemy.size * 1.2;
        const healthBarHeight = 6;
        const healthPercent = enemy.health / enemy.maxHealth;
        gameCtx.fillStyle = '#333';
        gameCtx.fillRect(x - healthBarWidth / 2, y + enemy.size / 2 + 5, healthBarWidth, healthBarHeight);
        if (healthPercent > 0.6) {
            gameCtx.fillStyle = '#2ecc71';
        } else if (healthPercent > 0.3) {
            gameCtx.fillStyle = '#f39c12';
        } else {
            gameCtx.fillStyle = '#e74c3c';
        }
        gameCtx.fillRect(x - healthBarWidth / 2, y + enemy.size / 2 + 5, healthBarWidth * healthPercent, healthBarHeight);
    }
    gameCtx.restore();
}

function drawEnemies() {
    enemies.forEach(drawEnemy);
}

function moveEnemies() {
    updateSpatialGrid();
    enemies.forEach(enemy => {
        applyEnemyBehavior(enemy);
        if (!enemy.isGhost) {
            const neighbors = getNeighbors(enemy);
            neighbors.forEach(other => {
                if (enemy !== other && !other.isGhost) {
                    const dx = enemy.x - other.x;
                    const dy = enemy.y - other.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = enemy.collisionRadius + other.collisionRadius;
                    if (distance < minDistance && distance > 0) {
                        const angle = Math.atan2(dy, dx);
                        const pushFactor = 0.3;
                        const pushX = (minDistance - distance) * Math.cos(angle) * pushFactor;
                        const pushY = (minDistance - distance) * Math.sin(angle) * pushFactor;
                        enemy.x += pushX;
                        enemy.y += pushY;
                        other.x -= pushX;
                        other.y -= pushY;
                    }
                }
            });
        }
    });
}

function applyEnemyBehavior(enemy) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    let speedMultiplier = enemy.effects.frozen ? 0.3 : 1;
    const angle = Math.atan2(dy, dx);
    const now = Date.now();
    if (enemy.specialAttack === 'summon' && now - enemy.lastSpecialAttack >= enemy.specialAttackCooldown) {
        enemy.lastSpecialAttack = now;
        for (let i = 0; i < 3; i++) {
            if (enemies.length < MAX_ENEMIES) {
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnDistance = enemy.size * 1.5;
                const spawnX = enemy.x + Math.cos(spawnAngle) * spawnDistance;
                const spawnY = enemy.y + Math.sin(spawnAngle) * spawnDistance;
                const summonType = Math.random() < 0.5 ? enemyTypes[0] : enemyTypes[1];
                const summonedEnemy = {
                    x: spawnX,
                    y: spawnY,
                    health: summonType.health * 0.7,
                    maxHealth: summonType.health * 0.7,
                    damage: summonType.damage * 0.7,
                    speed: summonType.speed,
                    size: summonType.size || 40,
                    type: summonType.type,
                    emoji: summonType.emoji,
                    pointValue: Math.floor(summonType.pointValue * 0.5),
                    dropChance: 0,
                    collisionRadius: summonType.collisionRadius || 20,
                    behavior: 'follow',
                    effects: {},
                };
                enemies.push(summonedEnemy);
                createFloatingText(spawnX, spawnY, 'Summoned!', '#FF00FF', 16);
                for (let j = 0; j < 5; j++) {
                    particles.push({
                        x: spawnX,
                        y: spawnY,
                        size: Math.random() * 5 + 3,
                        color: '#FF00FF',
                        alpha: 0.8,
                        speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                        life: 15,
                    });
                }
            }
        }
        createFloatingText(enemy.x, enemy.y - 30, 'Summoning!', '#FF00FF', 22);
    }

    if (enemy.behavior === 'teleport' && now - enemy.lastTeleport >= enemy.teleportCooldown && distance < 300 && distance > 100) {
        enemy.lastTeleport = now;
        const oldX = enemy.x;
        const oldY = enemy.y;
        const teleportAngle = Math.random() * Math.PI * 2;
        const teleportDistance = Math.random() * 100 + 100;
        enemy.x = player.x + Math.cos(teleportAngle) * teleportDistance;
        enemy.y = player.y + Math.sin(teleportAngle) * teleportDistance;
        createFloatingText(oldX, oldY, 'Teleport!', '#FFDD00', 20);
        createFloatingText(enemy.x, enemy.y, 'âš¡', '#FFDD00', 30);
        for (let i = 0; i < 10; i++) {
            particles.push({
                x: oldX,
                y: oldY,
                size: Math.random() * 5 + 3,
                color: '#FFDD00',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                life: 15,
            });
            particles.push({
                x: enemy.x,
                y: enemy.y,
                size: Math.random() * 5 + 3,
                color: '#FFDD00',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                life: 15,
            });
        }
        return;
    }
    switch (enemy.behavior) {
        case 'follow':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'zigzag':
            enemy.behaviorTimer += deltaTime;
            const zigzagAngle = angle + Math.sin(enemy.behaviorTimer / 500) * 0.5;
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(zigzagAngle) * speed;
                enemy.y += Math.sin(zigzagAngle) * speed;
            }
            break;
        case 'keepDistance':
            const idealDistance = enemy.range * 0.7;
            if (distance < idealDistance - 20) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x -= Math.cos(angle) * speed;
                enemy.y -= Math.sin(angle) * speed;
            } else if (distance > idealDistance + 20) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 0.7;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'kamikaze':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 1.2;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'aggressive':
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000 * 1.1;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
            break;
        case 'flanking':
            if (!enemy.behaviorState.targetAngle) {
                enemy.behaviorState.targetAngle = angle + Math.PI / 2 * (Math.random() < 0.5 ? 1 : -1);
            }
            if (distance > 200) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            } else {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(enemy.behaviorState.targetAngle) * speed;
                enemy.y += Math.sin(enemy.behaviorState.targetAngle) * speed;
                enemy.behaviorTimer += deltaTime;
                if (enemy.behaviorTimer > 2000) {
                    enemy.behaviorTimer = 0;
                    enemy.behaviorState.targetAngle = angle + Math.PI / 2 * (Math.random() < 0.5 ? 1 : -1);
                }
            }
            break;
        case 'phasing':
            if (distance > enemy.size / 2 + player.size / 2) {
                if (!enemy.behaviorState.phasing && Math.random() < 0.01) {
                    enemy.behaviorState.phasing = true;
                    enemy.behaviorState.phaseDuration = Math.random() * 1000 + 500;
                    enemy.behaviorState.phaseTimer = 0;
                }
                if (enemy.behaviorState.phasing) {
                    enemy.behaviorState.phaseTimer += deltaTime;
                    if (enemy.behaviorState.phaseTimer >= enemy.behaviorState.phaseDuration) {
                        enemy.behaviorState.phasing = false;
                    }
                    const phaseAngle = Math.random() * Math.PI * 2;
                    const phaseSpeed = enemy.speed * 2 * deltaTime / 1000;
                    enemy.x += Math.cos(phaseAngle) * phaseSpeed;
                    enemy.y += Math.sin(phaseAngle) * phaseSpeed;
                    if (Math.random() > 0.7) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            size: Math.random() * 5 + 3,
                            color: '#b8c0ff',
                            alpha: 0.5,
                            speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2},
                            life: 10,
                        });
                    }
                } else {
                    const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                    enemy.x += Math.cos(angle) * speed;
                    enemy.y += Math.sin(angle) * speed;
                }
            }
            break;
        case 'swarm':
            enemy.behaviorTimer += deltaTime;
            if (!enemy.behaviorState.offset) {
                enemy.behaviorState.offset = {x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100};
                enemy.behaviorState.offsetTimer = 0;
            }
            enemy.behaviorState.offsetTimer += deltaTime;
            if (enemy.behaviorState.offsetTimer > 2000) {
                enemy.behaviorState.offset = {x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100};
                enemy.behaviorState.offsetTimer = 0;
            }
            if (distance > enemy.size / 2 + player.size / 2) {
                const targetX = player.x + enemy.behaviorState.offset.x;
                const targetY = player.y + enemy.behaviorState.offset.y;
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const swarmAngle = Math.atan2(dy, dx);
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(swarmAngle) * speed;
                enemy.y += Math.sin(swarmAngle) * speed;
            }
            break;
        default:
            if (distance > enemy.size / 2 + player.size / 2) {
                const speed = enemy.speed * speedMultiplier * deltaTime / 1000;
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
            }
    }
    if (Math.random() > 0.9) {
        particles.push({
            x: enemy.x,
            y: enemy.y + enemy.size / 2,
            size: 3,
            color: '#555',
            alpha: 0.5,
            speed: {x: 0, y: 0},
            life: 10
        });
    }
    if (enemy.type === 'explosive' && !enemy.isBoss && distance < enemy.size / 2 + player.size / 2) {
        enemy.health = 0;
        createExplosion(enemy.x, enemy.y, enemy.explosionRange, enemy.damage);
    }
}

function attackEnemies() {
    const now = Date.now();
    if (now - player.lastAttackTime >= 1000 / player.attackSpeed) {
        player.lastAttackTime = now;
        let nearestEnemy = null;
        let nearestDistance = Infinity;
        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.attackRange && distance < nearestDistance) {
                nearestDistance = distance;
                nearestEnemy = enemy;
            }
        });
        if (nearestEnemy) {
            const shotCount = player.effects.multishot ? 1 + player.effects.multishot : 1;
            for (let i = 0; i < shotCount; i++) {
                const angle = i === 0 ? Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x) : Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x) + (Math.random() - 0.5) * 0.5;
                const isCrit = Math.random() < player.critChance;
                const projectile = {
                    x: player.x,
                    y: player.y,
                    targetX: nearestEnemy.x,
                    targetY: nearestEnemy.y,
                    speed: 400,
                    size: 15,
                    angle: angle,
                    damage: isCrit ? player.damage * player.critMultiplier : player.damage,
                    isCrit: isCrit,
                    emoji: isCrit ? 'âš¡' : 'ðŸ”¹',
                    effects: {
                        poisoned: player.effects.poisonAttack > 0 && Math.random() < player.effects.poisonAttack,
                        frozen: player.effects.freezeAttack > 0 && Math.random() < player.effects.freezeAttack,
                        burning: player.effects.burnAttack > 0 && Math.random() < player.effects.burnAttack
                    }
                };
                projectiles.push(projectile);
                for (let j = 0; j < 3; j++) {
                    particles.push({
                        x: player.x + Math.cos(angle) * 20,
                        y: player.y + Math.sin(angle) * 20,
                        size: Math.random() * 4 + 2,
                        color: isCrit ? '#FFD700' : '#4da6ff',
                        alpha: 1,
                        speed: {
                            x: Math.cos(angle) * (Math.random() * 2 + 1),
                            y: Math.sin(angle) * (Math.random() * 2 + 1)
                        },
                        life: 10
                    });
                }
            }
        }
    }

    if (player.effects.orbital) {
        const now = Date.now();
        const orbitalCount = Math.min(player.effects.orbital, 3);
        for (let i = 0; i < orbitalCount; i++) {
            const angle = (now / 1000) * (1 + i * 0.2);
            const distance = player.size * 1.5;
            const x = player.x + Math.cos(angle) * distance;
            const y = player.y + Math.sin(angle) * distance;
            gameCtx.save();
            gameCtx.font = '20px Arial';
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.shadowColor = '#9966FF';
            gameCtx.shadowBlur = 10;
            gameCtx.fillText('ðŸ”®', x, y);
            gameCtx.restore();
            enemies.forEach(enemy => {
                const dx = x - enemy.x;
                const dy = y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < enemy.size / 2 + 10) {
                    const damage = player.damage * 0.4;
                    enemy.health -= damage;
                    if (Math.random() > 0.7) {
                        createFloatingText(enemy.x, enemy.y, Math.round(damage), '#9966FF');
                    }
                    for (let j = 0; j < 3; j++) {
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            size: Math.random() * 3 + 2,
                            color: '#9966FF',
                            alpha: 0.7,
                            speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                            life: 10
                        });
                    }
                }
            });
        }
    }
    const rangedEnemies = enemies.filter(e => e.range > 0);
    rangedEnemies.forEach(enemy => {
        const now = Date.now();
        if (now - enemy.lastAttackTime >= 1000 / enemy.attackSpeed) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < enemy.range) {
                enemy.lastAttackTime = now;
                const projectile = {
                    x: enemy.x,
                    y: enemy.y,
                    targetX: player.x,
                    targetY: player.y,
                    speed: enemy.projectileSpeed,
                    size: 15,
                    angle: Math.atan2(dy, dx),
                    damage: enemy.damage,
                    emoji: enemy.isElite ? 'ðŸ”®' : 'ðŸ”´',
                    isEnemyProjectile: true,
                };
                projectiles.push(projectile);
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        size: Math.random() * 5 + 3,
                        color: enemy.isElite ? '#9966ff' : '#ff4d4d',
                        alpha: 0.8,
                        speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                        life: 15,
                    });
                }
            }
        }
    });
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += Math.cos(p.angle) * p.speed * deltaTime / 1000;
        p.y += Math.sin(p.angle) * p.speed * deltaTime / 1000;
        if (p.x < -50 || p.x > GAME_WIDTH + 50 || p.y < -50 || p.y > GAME_HEIGHT + 50) {
            projectiles.splice(i, 1);
            continue;
        }
        if (!p.isEnemyProjectile) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const dx = p.x - enemy.x;
                const dy = p.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < enemy.collisionRadius) {
                    enemy.health -= p.damage;
                    if (p.effects.poisoned) {
                        enemy.effects.poisoned = {duration: 3000, damage: p.damage * 0.2};
                    }
                    if (p.effects.frozen) {
                        enemy.effects.frozen = {duration: 2000};
                    }
                    if (p.effects.burning) {
                        enemy.effects.burning = {duration: 2500, damage: p.damage * 0.15};
                    }
                    if (p.isCrit) {
                        createFloatingText(enemy.x, enemy.y, `${Math.round(p.damage)}!`, '#FFD700', 24);
                    } else {
                        createFloatingText(enemy.x, enemy.y, Math.round(p.damage), '#FFF');
                    }
                    if (player.effects.vampirism && player.health < player.maxHealth) {
                        const healAmount = p.damage * player.effects.vampirism;
                        player.health = Math.min(player.health + healAmount, player.maxHealth);
                        createFloatingText(player.x, player.y, `+${Math.round(healAmount)}`, '#6FFF6F');
                    }
                    if (enemy.isVampire && enemy.health > 0) {
                        const vampHeal = p.damage * enemy.vampiricStrength;
                        enemy.health = Math.min(enemy.health + vampHeal, enemy.maxHealth);
                        createFloatingText(enemy.x, enemy.y, `+${Math.round(vampHeal)}`, '#800020');
                    }
                    for (let k = 0; k < 5; k++) {
                        particles.push({
                            x: p.x,
                            y: p.y,
                            size: Math.random() * 3 + 2,
                            color: p.isCrit ? '#FFD700' : '#FFF',
                            alpha: 0.8,
                            speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
                            life: 15
                        });
                    }
                    projectiles.splice(i, 1);
                    break;
                }
            }
        } else {
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.size / 2 && player.invulnerableTime <= 0) {
                takeDamage(p.damage);
                for (let k = 0; k < 8; k++) {
                    particles.push({
                        x: p.x,
                        y: p.y,
                        size: Math.random() * 5 + 3,
                        color: '#ff4d4d',
                        alpha: 0.8,
                        speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
                        life: 20
                    });
                }
                projectiles.splice(i, 1);
                break;
            }
        }
    }
}

function drawProjectiles() {
    projectiles.forEach(p => {
        gameCtx.save();
        gameCtx.font = `${p.size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        if (p.isCrit) {
            gameCtx.shadowColor = '#FFD700';
            gameCtx.shadowBlur = 10;
        } else if (p.effects && p.effects.poisoned) {
            gameCtx.shadowColor = '#00FF00';
            gameCtx.shadowBlur = 8;
        } else if (p.effects && p.effects.frozen) {
            gameCtx.shadowColor = '#00BFFF';
            gameCtx.shadowBlur = 8;
        } else if (p.effects && p.effects.burning) {
            gameCtx.shadowColor = '#FF4500';
            gameCtx.shadowBlur = 8;
        } else if (p.isEnemyProjectile) {
            gameCtx.shadowColor = '#ff4d4d';
            gameCtx.shadowBlur = 6;
        }
        gameCtx.fillText(p.emoji, p.x, p.y);
        if (Math.random() > 0.7) {
            particles.push({
                x: p.x,
                y: p.y,
                size: Math.random() * 3 + 1,
                color: p.isEnemyProjectile ? '#ff4d4d' : (p.isCrit ? '#FFD700' : '#4da6ff'),
                alpha: 0.6,
                speed: {x: 0, y: 0},
                life: 10
            });
        }
        gameCtx.restore();
    });
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.health <= 0) {
            if (enemy.type === 'explosive') {
                createExplosion(enemy.x, enemy.y, enemy.explosionRange, enemy.damage);
            }
            score += enemy.pointValue;
            killCount++;
            player.kills++;
            comboCount++;
            comboTimer = 3000;
            if (comboCount > highestCombo) {
                highestCombo = comboCount;
            }
            createFloatingText(enemy.x, enemy.y, `+${enemy.pointValue}`, '#FFD700', 20);
            if (comboCount > 1) {
                createFloatingText(enemy.x, enemy.y - 25, `Combo x${comboCount}`, comboCount > 5 ? '#ff4d4d' : '#e9c46a', comboCount > 5 ? 24 : 18);
            }
            experience += enemy.pointValue;
            checkLevelUp();
            checkAchievements();
            if (Math.random() < enemy.dropChance * (player.effects.luckyCharm ? 1 + player.effects.luckyCharm : 1)) {
                dropItem(enemy);
            }
            const particleCount = enemy.isBoss ? 20 : (enemy.isElite ? 12 : 8);
            for (let j = 0; j < particleCount; j++) {
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: Math.random() * 5 + 3,
                    color: enemy.isBoss ? '#ff4d4d' : (enemy.isElite ? '#9966ff' : (enemy.isGhost ? '#b8c0ff' : (enemy.isVampire ? '#800020' : '#4da6ff'))),
                    alpha: 1,
                    speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                    life: 30
                });
            }
            enemies.splice(i, 1);
            if (enemy.isBoss) {
                unlockAchievement('firstBoss');
            }
            continue;
        }
        if (enemy.effects.poisoned) {
            enemy.effects.poisoned.duration -= deltaTime;
            if (enemy.effects.poisoned.duration > 0) {
                enemy.health -= enemy.effects.poisoned.damage * deltaTime / 1000;
                if (Math.random() > 0.8) {
                    createFloatingText(enemy.x + (Math.random() * 20 - 10), enemy.y + (Math.random() * 20 - 10), Math.round(enemy.effects.poisoned.damage * deltaTime / 1000), '#00FF00', 14);
                }
            } else {
                delete enemy.effects.poisoned;
            }
        }
        if (enemy.effects.frozen) {
            enemy.effects.frozen.duration -= deltaTime;
            if (enemy.effects.frozen.duration <= 0) {
                delete enemy.effects.frozen;
            }
        }
        if (enemy.effects.burning) {
            enemy.effects.burning.duration -= deltaTime;
            if (enemy.effects.burning.duration > 0) {
                enemy.health -= enemy.effects.burning.damage * deltaTime / 1000;
                if (Math.random() > 0.8) {
                    createFloatingText(enemy.x + (Math.random() * 20 - 10), enemy.y + (Math.random() * 20 - 10), Math.round(enemy.effects.burning.damage * deltaTime / 1000), '#FF4500', 14);
                }
            } else {
                delete enemy.effects.burning;
            }
        }
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < enemy.collisionRadius + player.size / 2 && enemy.range === 0 && player.invulnerableTime <= 0) {
            const now = Date.now();
            if (now - enemy.lastAttackTime >= 1000) {
                enemy.lastAttackTime = now;
                takeDamage(enemy.damage);
                if (enemy.isVampire) {
                    const vampHeal = enemy.damage * enemy.vampiricStrength;
                    enemy.health = Math.min(enemy.health + vampHeal, enemy.maxHealth);
                    createFloatingText(enemy.x, enemy.y, `+${Math.round(vampHeal)}`, '#800020');
                }
            }
        }
    }
}

function createExplosion(x, y, range, damage) {
    screenShake = 10;
    createFloatingText(x, y, "ðŸ’¥ BOOM!", '#ff4d4d', 28);
    for (let i = 0; i < 30; i++) {
        particles.push({
            x: x,
            y: y,
            size: Math.random() * 10 + 5,
            color: i % 2 === 0 ? '#FF4500' : '#FFD700',
            alpha: 1,
            speed: {x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10},
            life: 40,
        });
    }
    const dx = player.x - x;
    const dy = player.y - y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < range && player.invulnerableTime <= 0) {
        takeDamage(damage * (1 - distance / range));
    }
    enemies.forEach(enemy => {
        if (enemy.x !== x || enemy.y !== y) {
            const dx = enemy.x - x;
            const dy = enemy.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < range) {
                enemy.health -= damage * (1 - distance / range);
                createFloatingText(enemy.x, enemy.y, Math.round(damage * (1 - distance / range)), '#FF4500');
            }
        }
    })
}

function takeDamage(amount) {
    if (player.invulnerableTime > 0) return;
    const shieldReduction = player.effects.shield ? amount * player.effects.shield : 0;
    const finalDamage = amount - shieldReduction;
    player.health -= finalDamage;
    player.invulnerableTime = 500;
    screenShake = 5;
    comboCount = 0;
    comboTimer = 0;
    if (shieldReduction > 0) {
        createFloatingText(player.x, player.y - 20, `Shield: -${Math.round(shieldReduction)}`, '#3498DB');
    }
    createFloatingText(player.x, player.y, `-${Math.round(finalDamage)}`, '#E74C3C', 20);
    if (player.effects.thornAura) {
        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.size * 3) {
                const thornDamage = finalDamage * player.effects.thornAura;
                enemy.health -= thornDamage;
                createFloatingText(enemy.x, enemy.y, Math.round(thornDamage), '#8F8', 16);
                if (player.thornPoisonChance && Math.random() < player.thornPoisonChance) {
                    enemy.effects.poisoned = {duration: 2000, damage: thornDamage * 0.3};
                }
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: Math.random() * 5 + 3,
                    color: '#8F8',
                    alpha: 0.8,
                    speed: {x: 0, y: 0},
                    life: 15
                });
            }
        });
    }
    if (player.health <= 0) {
        gameOver();
    }
}

function dropItem(enemy) {
    let rarityRoll = Math.random();
    let itemPool;
    if (enemy.isBoss) {
        itemPool = itemTypes;
        rarityRoll *= 0.7;
    } else if (enemy.isElite) {
        itemPool = itemTypes;
        rarityRoll *= 0.8;
    } else if (rarityRoll < 0.6) {
        itemPool = itemTypes.filter(item => item.rarity === 'common');
    } else if (rarityRoll < 0.9) {
        itemPool = itemTypes.filter(item => item.rarity === 'uncommon');
    } else {
        itemPool = itemTypes.filter(item => item.rarity === 'rare');
        if (rarityRoll > 0.97) {
            itemPool = itemPool.concat(itemTypes.filter(item => item.rarity === 'legendary'));
        }
    }
    const randomItem = itemPool[Math.floor(Math.random() * itemPool.length)];
    items.push({
        x: enemy.x,
        y: enemy.y,
        size: 30,
        type: randomItem.type,
        emoji: randomItem.emoji,
        name: randomItem.name,
        description: randomItem.description,
        effect: randomItem.effect,
        rarity: randomItem.rarity,
        collectTime: 0,
        hoverTime: 0
    });
    for (let i = 0; i < 5; i++) {
        particles.push({
            x: enemy.x,
            y: enemy.y,
            size: Math.random() * 4 + 2,
            color: getRarityColor(randomItem.rarity),
            alpha: 0.8,
            speed: {x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 - 2},
            life: 20
        });
    }
}

function getRarityColor(rarity) {
    switch (rarity) {
        case 'common':
            return '#b9bbbe';
        case 'uncommon':
            return '#43b581';
        case 'rare':
            return '#4070ff';
        case 'legendary':
            return '#f1c40f';
        default:
            return '#FFF';
    }
}

function drawItems() {
    items.forEach(item => {
        gameCtx.save();
        gameCtx.shadowColor = getRarityColor(item.rarity);
        gameCtx.shadowBlur = 10;
        const scaleFactor = 1 + Math.sin(Date.now() / 200) * 0.1;
        const size = item.size * scaleFactor;
        gameCtx.font = `${size}px Arial`;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(item.emoji, item.x, item.y);
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < player.pickupRange * 1.5) {
            item.hoverTime = Math.min(item.hoverTime + deltaTime / 200, 1);
        } else {
            item.hoverTime = Math.max(item.hoverTime - deltaTime / 400, 0);
        }
        if (item.hoverTime > 0.1) {
            gameCtx.globalAlpha = item.hoverTime;
            gameCtx.font = '14px Arial';
            gameCtx.fillStyle = getRarityColor(item.rarity);
            gameCtx.fillText(item.name, item.x, item.y - 20);
            gameCtx.globalAlpha = 1;
        }
        gameCtx.restore();
    });
}

function checkItemPickup() {
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < player.pickupRange) {
            const vx = (player.x - item.x) * 5 * deltaTime / 1000;
            const vy = (player.y - item.y) * 5 * deltaTime / 1000;
            item.x += vx;
            item.y += vy;
        }
        if (distance < player.size / 2) {
            item.collectTime = Date.now();
            itemLabels.push({
                text: `${item.name}`,
                description: item.description,
                x: player.x,
                y: player.y - 40,
                life: 120,
                alpha: 1,
            });
            item.effect(player);
            createFloatingText(player.x, player.y - 20, item.name, getRarityColor(item.rarity), 16);
            unlockAchievement('firstItem');
            for (let j = 0; j < 10; j++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    size: Math.random() * 5 + 2,
                    color: getRarityColor(item.rarity),
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 - 1},
                    life: 20
                });
            }
            items.splice(i, 1);
        }
    }
}

function drawPlayer() {
    gameCtx.save();
    if (player.invulnerableTime > 0) {
        gameCtx.globalAlpha = 0.7;
        gameCtx.shadowColor = '#ccccff';
        gameCtx.shadowBlur = 15;
    }
    if (isDashing) {
        gameCtx.shadowColor = '#00ffff';
        gameCtx.shadowBlur = 20;
        for (let i = 0; i < 5; i++) {
            gameCtx.globalAlpha = 0.15 * (5 - i);
            gameCtx.font = `${player.size}px Arial`;
            gameCtx.textAlign = 'center';
            gameCtx.textBaseline = 'middle';
            gameCtx.fillText(player.emoji, player.x - dashDirection.x * (i * 10), player.y - dashDirection.y * (i * 10));
        }
        gameCtx.globalAlpha = 1;
    }
    if (effects.rageMode) {
        gameCtx.shadowColor = '#FF0000';
        gameCtx.shadowBlur = 20;
        if (Math.random() > 0.8) {
            particles.push({
                x: player.x + (Math.random() * player.size - player.size / 2),
                y: player.y + (Math.random() * player.size - player.size / 2),
                size: Math.random() * 5 + 3,
                color: '#FF0000',
                alpha: 0.8,
                speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 - 1},
                life: 15,
            });
        }
    }
    gameCtx.font = `${player.size}px Arial`;
    gameCtx.textAlign = 'center';
    gameCtx.textBaseline = 'middle';
    gameCtx.fillText(player.emoji, player.x, player.y);
    gameCtx.beginPath();
    gameCtx.arc(player.x, player.y, player.attackRange, 0, Math.PI * 2);
    gameCtx.strokeStyle = 'rgba(255,255,255,0.1)';
    gameCtx.stroke();
    if (player.effects.thornAura) {
        gameCtx.save();
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.size * 3, 0, Math.PI * 2);
        gameCtx.strokeStyle = `rgba(0,255,0,${0.3 * player.effects.thornAura})`;
        gameCtx.lineWidth = 2;
        gameCtx.stroke();
        gameCtx.restore();
    }
    if (dashCooldown > 0) {
        const dashReadyPercent = 1 - (dashCooldown / player.dashCooldownTime);
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.size * 0.8, -Math.PI / 2, -Math.PI / 2 + dashReadyPercent * Math.PI * 2);
        gameCtx.strokeStyle = dashReadyPercent < 1 ? 'rgba(100,100,255,0.5)' : 'rgba(100,255,100,0.5)';
        gameCtx.lineWidth = 3;
        gameCtx.stroke();
    }
    if (player.isMoving && Math.random() > 0.8) {
        particles.push({
            x: player.x,
            y: player.y + player.size / 3,
            size: Math.random() * 4 + 2,
            color: '#888',
            alpha: 0.5,
            speed: {x: (Math.random() - 0.5) * 1, y: (Math.random() - 0.5) * 1},
            life: 10
        });
    }
    gameCtx.restore();
}

function movePlayer() {
    if (isUpgrading || isPaused) return;
    if (dashCooldown > 0) {
        dashCooldown -= deltaTime;
    }
    if (isDashing) {
        player.x += dashDirection.x * player.dashSpeed * deltaTime / 1000;
        player.y += dashDirection.y * player.dashSpeed * deltaTime / 1000;
        if (Math.random() > 0.3) {
            particles.push({
                x: player.x - dashDirection.x * 10,
                y: player.y - dashDirection.y * 10,
                size: Math.random() * 5 + 3,
                color: '#4da6ff',
                alpha: 0.6,
                speed: {x: -dashDirection.x * (Math.random() * 2 + 1), y: -dashDirection.y * (Math.random() * 2 + 1)},
                life: 15
            });
        }
        return;
    }
    let moveX = 0;
    let moveY = 0;
    if (isMobile && useTouchControls && touchActive && touchPosition.x !== null) {
        moveX = touchPosition.x - player.x;
        moveY = touchPosition.y - player.y;
        const touchDistance = Math.sqrt(moveX * moveX + moveY * moveY);
        if (touchDistance > 10) {
            player.isMoving = true;
            const length = Math.sqrt(moveX * moveX + moveY * moveY);
            moveX /= length;
            moveY /= length;
            player.x += moveX * player.speed * deltaTime / 1000;
            player.y += moveY * player.speed * deltaTime / 1000;
            player.direction = moveX < 0 ? -1 : 1;
        } else {
            player.isMoving = false;
        }
    } else {
        if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;
        if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
        if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;
        if ((keys[' '] || keys['Space']) && dashCooldown <= 0 && (moveX !== 0 || moveY !== 0)) {
            isDashing = true;
            dashDirection = {
                x: moveX / Math.sqrt(moveX * moveX + moveY * moveY),
                y: moveY / Math.sqrt(moveX * moveX + moveY * moveY)
            };
            dashCooldown = player.dashCooldownTime;
            player.invulnerableTime = player.dashDuration;
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    size: Math.random() * 6 + 3,
                    color: '#4da6ff',
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4},
                    life: 20
                });
            }
            setTimeout(() => {
                isDashing = false;
            }, player.dashDuration);
            return;
        }
        if (moveX !== 0 || moveY !== 0) {
            player.isMoving = true;
            const length = Math.sqrt(moveX * moveX + moveY * moveY);
            moveX /= length;
            moveY /= length;
            player.x += moveX * player.speed * deltaTime / 1000;
            player.y += moveY * player.speed * deltaTime / 1000;
            player.direction = moveX < 0 ? -1 : 1;
        } else {
            player.isMoving = false;
        }
    }
    player.x = Math.max(player.size / 2, Math.min(player.x, GAME_WIDTH - player.size / 2));
    player.y = Math.max(player.size / 2, Math.min(player.y, GAME_HEIGHT - player.size / 2));
}

function createFloatingText(x, y, text, color = '#FFF', size = 16) {
    const textObj = {
        x: x,
        y: y,
        text: text,
        color: color,
        size: size,
        alpha: 1,
        life: 50,
        velocity: {x: (Math.random() - 0.5) * 2, y: -2}
    };
    floatingTexts.push(textObj);
}

function updateFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.life--;
        if (t.life <= 0) {
            floatingTexts.splice(i, 1);
            continue;
        }
        t.y += t.velocity.y;
        t.x += t.velocity.x;
        t.alpha = t.life / 50;
    }
}

function drawFloatingTexts() {
    floatingTexts.forEach(t => {
        gameCtx.save();
        gameCtx.globalAlpha = t.alpha;
        gameCtx.font = `${t.size}px Arial`;
        gameCtx.fillStyle = t.color;
        gameCtx.textAlign = 'center';
        gameCtx.textBaseline = 'middle';
        gameCtx.fillText(t.text, t.x, t.y);
        gameCtx.restore();
    });
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life--;
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        p.x += p.speed.x;
        p.y += p.speed.y;
        p.size *= 0.95;
        p.alpha = p.life / 40;
    }
}

function drawParticles() {
    particles.forEach(p => {
        gameCtx.save();
        gameCtx.globalAlpha = p.alpha;
        gameCtx.fillStyle = p.color;
        gameCtx.beginPath();
        gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        gameCtx.fill();
        gameCtx.restore();
    });
}

function drawUI() {
    uiCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    uiCtx.font = '24px Arial';
    uiCtx.fillStyle = '#FFF';
    uiCtx.textAlign = 'left';
    uiCtx.fillText(`Score: ${score}`, 20, 30);
    uiCtx.fillText(`Level: ${level}`, 20, 60);
    const timeString = formatTime(gameTime);
    uiCtx.fillText(timeString, 20, 90);
    uiCtx.font = '24px Arial';
    uiCtx.fillStyle = '#f4a261';
    if (specialWave) {
        uiCtx.fillText(`Wave ${waveNumber} - ${specialWave.toUpperCase()}`, 20, 130);
    } else {
        uiCtx.fillText(`Wave ${waveNumber}`, 20, 130);
    }
    uiCtx.fillStyle = '#444';
    uiCtx.fillRect(20, 140, 200, 10);
    uiCtx.fillStyle = '#f4a261';
    uiCtx.fillRect(20, 140, 200 * (waveTimer / waveInterval), 10);

    if (comboCount > 1) {
        uiCtx.save();
        uiCtx.font = comboCount > 5 ? 'bold 24px Arial' : '20px Arial';
        uiCtx.fillStyle = comboCount > 10 ? '#ff4d4d' : (comboCount > 5 ? '#e76f51' : '#e9c46a');

        if (comboCount > 5) {
            uiCtx.shadowColor = '#000';
            uiCtx.shadowBlur = 3;
        }

        uiCtx.fillText(`Combo: ${comboCount}x`, 20, 180);
        uiCtx.restore();
    }

    if (isEndlessMode) {
        uiCtx.fillStyle = '#e76f51';
        uiCtx.font = 'bold 20px Arial';
        uiCtx.fillText('ENDLESS MODE', 20, 210);
    }

    uiCtx.fillStyle = '#264653';
    uiCtx.fillRect(20, GAME_HEIGHT - 40, 300, 20);

    const healthPercent = player.health / player.maxHealth;
    if (healthPercent > 0.6) {
        uiCtx.fillStyle = '#2ecc71';
    } else if (healthPercent > 0.3) {
        uiCtx.fillStyle = '#f39c12';
    } else {
        uiCtx.fillStyle = '#e74c3c';
    }
    uiCtx.fillRect(20, GAME_HEIGHT - 40, 300 * healthPercent, 20);

    uiCtx.fillStyle = '#FFF';
    uiCtx.font = '16px Arial';
    uiCtx.fillText(`${Math.ceil(player.health)}/${player.maxHealth}`, 30, GAME_HEIGHT - 28);

    uiCtx.fillStyle = '#264653';
    uiCtx.fillRect(20, GAME_HEIGHT - 80, 300, 10);
    uiCtx.fillStyle = '#e9c46a';
    const expPercentage = experience / experienceToNextLevel;
    uiCtx.fillRect(20, GAME_HEIGHT - 80, 300 * expPercentage, 10);

    if (dashCooldown > 0) {
        uiCtx.fillStyle = '#264653';
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150, 10);
        uiCtx.fillStyle = '#4da6ff';
        const dashReadyPercent = 1 - (dashCooldown / player.dashCooldownTime);
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150 * dashReadyPercent, 10);
        uiCtx.fillStyle = '#FFF';
        uiCtx.font = '12px Arial';
        uiCtx.fillText(`Dash: ${(dashCooldown / 1000).toFixed(1)}s`, 30, GAME_HEIGHT - 65);
    } else {
        uiCtx.fillStyle = '#2ecc71';
        uiCtx.fillRect(20, GAME_HEIGHT - 60, 150, 10);
        uiCtx.fillStyle = '#FFF';
        uiCtx.font = '12px Arial';
        uiCtx.fillText(`Dash: Ready!`, 30, GAME_HEIGHT - 65);
    }

    let row = 0;
    let col = 0;
    Object.keys(effects).forEach(effectName => {
        const effect = effects[effectName];
        if (effect) {
            const x = GAME_WIDTH - 70 - col * 40;
            const y = 30 + row * 40;
            uiCtx.font = '24px Arial';
            uiCtx.fillText(effect.icon, x, y);

            if (!effect.permanent) {
                uiCtx.font = '12px Arial';
                uiCtx.fillStyle = '#FFF';
                uiCtx.fillText(Math.ceil(effect.duration), x - 5, y + 15);
            }

            col++;
            if (col >= 3) {
                col = 0;
                row++;
            }
        }
    });

    itemLabels.forEach((label, index) => {
        label.life--;
        label.alpha = label.life / 120;

        if (label.life <= 0) {
            itemLabels.splice(index, 1);
        } else {
            uiCtx.save();
            uiCtx.globalAlpha = label.alpha;
            uiCtx.font = 'bold 18px Arial';
            uiCtx.fillStyle = '#FFD700';
            uiCtx.textAlign = 'center';
            uiCtx.fillText(label.text, label.x, label.y);
            uiCtx.font = '14px Arial';
            uiCtx.fillStyle = '#FFF';
            uiCtx.fillText(label.description, label.x, label.y + 20);
            uiCtx.restore();
        }
    });

    drawMinimap();
    updateStatsPanel();

    if (isMobile && useTouchControls && isGameRunning && !isPaused && !isUpgrading) {
        dashButton.style.display = 'flex';
    } else {
        dashButton.style.display = 'none';
    }
}

function drawMinimap() {
    const mapSize = 150;
    const mapX = GAME_WIDTH - mapSize - 20;
    const mapY = 20;

    uiCtx.fillStyle = 'rgba(0,0,0,0.5)';
    uiCtx.fillRect(mapX, mapY, mapSize, mapSize);
    uiCtx.strokeStyle = '#444';
    uiCtx.lineWidth = 2;
    uiCtx.strokeRect(mapX, mapY, mapSize, mapSize);

    const scale = 0.1;
    const visibleRadius = Math.min(GAME_WIDTH, GAME_HEIGHT) / 2;

    const playerMapX = mapX + mapSize / 2;
    const playerMapY = mapY + mapSize / 2;

    uiCtx.fillStyle = '#4da6ff';
    uiCtx.beginPath();
    uiCtx.arc(playerMapX, playerMapY, 4, 0, Math.PI * 2);
    uiCtx.fill();

    enemies.forEach(enemy => {
        const relX = enemy.x - player.x;
        const relY = enemy.y - player.y;
        const distance = Math.sqrt(relX * relX + relY * relY);

        if (distance < visibleRadius * 1.5) {
            const enemyMapX = playerMapX + relX * scale;
            const enemyMapY = playerMapY + relY * scale;

            if (enemyMapX > mapX && enemyMapX < mapX + mapSize && enemyMapY > mapY && enemyMapY < mapY + mapSize) {
                if (enemy.isBoss) {
                    uiCtx.fillStyle = '#ff4d4d';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 3, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isElite) {
                    uiCtx.fillStyle = '#9966ff';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2.5, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isGhost) {
                    uiCtx.fillStyle = '#b8c0ff';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                } else if (enemy.isVampire) {
                    uiCtx.fillStyle = '#800020';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                } else {
                    uiCtx.fillStyle = '#e74c3c';
                    uiCtx.beginPath();
                    uiCtx.arc(enemyMapX, enemyMapY, 2, 0, Math.PI * 2);
                    uiCtx.fill();
                }
            }
        }
    });

    items.forEach(item => {
        const relX = item.x - player.x;
        const relY = item.y - player.y;
        const distance = Math.sqrt(relX * relX + relY * relY);

        if (distance < visibleRadius * 1.5) {
            const itemMapX = playerMapX + relX * scale;
            const itemMapY = playerMapY + relY * scale;

            if (itemMapX > mapX && itemMapX < mapX + mapSize && itemMapY > mapY && itemMapY < mapY + mapSize) {
                uiCtx.fillStyle = getRarityColor(item.rarity);
                uiCtx.fillRect(itemMapX - 1.5, itemMapY - 1.5, 3, 3);
            }
        }
    });
}

function updateStatsPanel() {
    statsPanel.innerHTML = `
    <h3>Player Stats</h3>
    <p>â¤ï¸ Health: ${Math.floor(player.health)}/${player.maxHealth}</p>
    <p>ðŸ’ª Damage: ${player.damage.toFixed(1)}</p>
    <p>âš¡ Attack Speed: ${player.attackSpeed.toFixed(2)}/s</p>
    <p>ðŸ”­ Attack Range: ${Math.floor(player.attackRange)}</p>
    <p>ðŸ‘Ÿ Speed: ${Math.floor(player.speed)}</p>
    <p>ðŸ§² Pickup Range: ${Math.floor(player.pickupRange)}</p>
    <p>âš”ï¸ Crit Chance: ${Math.floor(player.critChance * 100)}%</p>
    <p>ðŸŽ¯ Crit Damage: ${Math.floor(player.critMultiplier * 100)}%</p>
    <p>ðŸ’¨ Dash Cooldown: ${(player.dashCooldownTime / 1000).toFixed(1)}s</p>
    <h3>Effects</h3>
    ${player.effects.vampirism ? `<p>ðŸ§› Vampirism: ${Math.floor(player.effects.vampirism * 100)}%</p>` : ''}
    ${player.effects.regeneration ? `<p>ðŸ”„ Regeneration: ${player.effects.regeneration.toFixed(1)}/s</p>` : ''}
    ${player.effects.shield ? `<p>ðŸ›¡ï¸ Shield: ${Math.floor(player.effects.shield * 100)}%</p>` : ''}
    ${player.effects.thornAura ? `<p>ðŸŒµ Thorn Aura: ${Math.floor(player.effects.thornAura * 100)}%</p>` : ''}
    ${player.effects.poisonAttack ? `<p>ðŸ§ª Poison: ${Math.floor(player.effects.poisonAttack * 100)}%</p>` : ''}
    ${player.effects.freezeAttack ? `<p>â„ï¸ Freeze: ${Math.floor(player.effects.freezeAttack * 100)}%</p>` : ''}
    ${player.effects.burnAttack ? `<p>ðŸ”¥ Burn: ${Math.floor(player.effects.burnAttack * 100)}%</p>` : ''}
    ${player.effects.multishot ? `<p>ðŸŽ¯ Multishot: +${player.effects.multishot}</p>` : ''}
    ${player.effects.luckyCharm ? `<p>ðŸ€ Luck: +${Math.floor(player.effects.luckyCharm * 100)}%</p>` : ''}
    ${player.effects.orbital ? `<p>ðŸ”® Orbitals: ${player.effects.orbital}</p>` : ''}
`;

    if (player.thornPoisonChance) {
        statsPanel.innerHTML += `<p>ðŸŒµðŸ§ª Thorn Poison: ${Math.floor(player.thornPoisonChance * 100)}%</p>`;
    }
}

function formatTime(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function checkLevelUp() {
    if (experience >= experienceToNextLevel) {
        experience -= experienceToNextLevel;
        experienceToNextLevel = Math.floor(experienceToNextLevel * 1.15);
        level++;
        isUpgrading = true;
        isPaused = true;
        showUpgradeOptions();
        createFloatingText(player.x, player.y - 40, 'LEVEL UP!', '#3498DB', 28);
        unlockAchievement('firstLevelUp');

        for (let i = 0; i < 20; i++) {
            particles.push({
                x: player.x,
                y: player.y,
                size: Math.random() * 8 + 4,
                color: i % 2 === 0 ? '#3498DB' : '#2ECC71',
                alpha: 1,
                speed: {x: (Math.random() - 0.5) * 6, y: (Math.random() - 0.5) * 6},
                life: 50
            });
        }
    }
}

function showUpgradeOptions() {
    upgradeOptionsElement.innerHTML = '';

    const shuffled = [...upgradeChoices].sort(() => 0.5 - Math.random());
    const selected = shuffled.slice(0, 3);

    selected.forEach((option, index) => {
        const div = document.createElement('div');
        div.className = 'upgrade-option';
        div.innerHTML = `
        <div style="font-size:36px;">${option.emoji}</div>
        <h3>${option.name}</h3>
        <p>${option.description}</p>
    `;

        div.addEventListener('click', () => {
            option.effect();
            closeUpgradeMenu();
            createFloatingText(player.x, player.y - 30, `Upgraded: ${option.name}!`, '#2ECC71', 20);
        });

        upgradeOptionsElement.appendChild(div);
    });

    upgradeMenu.style.display = 'flex';
}

function closeUpgradeMenu() {
    upgradeMenu.style.display = 'none';
    isUpgrading = false;
    isPaused = false;
}

function unlockAchievement(id) {
    const achievement = achievements.find(a => a.id === id);
    if (achievement && !achievement.unlocked) {
        achievement.unlocked = true;

        achievementPopup.style.display = 'block';
        achievementPopup.classList.add('pulse');
        achievementName.textContent = `${achievement.emoji} ${achievement.name}`;

        setTimeout(() => {
            achievementPopup.classList.remove('pulse');
            setTimeout(() => {
                achievementPopup.style.display = 'none';
            }, 500);
        }, 2500);
    }
}

function checkAchievements() {
    if (killCount >= 1) unlockAchievement('firstKill');
    if (killCount >= 10) unlockAchievement('tenKills');
    if (killCount >= 100) unlockAchievement('hundredKills');
    if (comboCount >= 15) unlockAchievement('maxCombo');
    if (gameTime >= 3 * 60 * 1000) unlockAchievement('threeMinutes');
    if (gameTime >= 10 * 60 * 1000) unlockAchievement('tenMinutes');
    if (isEndlessMode) unlockAchievement('endlessMode');
}

function startGame() {
    isGameRunning = true;
    isGameOver = false;
    isEndlessMode = false;
    isPaused = false;
    isUpgrading = false;

    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    pauseMenu.style.display = 'none';
    statsPanel.style.display = 'none';

    gameTime = 0;
    lastTime = Date.now();
    score = 0;
    level = 1;
    experience = 0;
    experienceToNextLevel = 75;
    enemySpawnTimer = 0;
    spawnInterval = SPAWN_INTERVAL_BASE;
    waveNumber = 1;
    waveTimer = 0;
    waveInterval = 30000;
    comboCount = 0;
    comboTimer = 0;
    highestCombo = 0;
    screenShake = 0;
    killCount = 0;
    dashCooldown = 0;
    isDashing = false;
    specialWave = false;

    enemies.length = 0;
    items.length = 0;
    projectiles.length = 0;
    particles.length = 0;
    floatingTexts.length = 0;
    effects = {};
    itemLabels = [];

    player.x = CENTER_X;
    player.y = CENTER_Y;
    player.health = 100;
    player.maxHealth = 100;
    player.speed = 200;
    player.damage = 50;
    player.attackSpeed = 2.0;
    player.attackRange = 200;
    player.pickupRange = 120;
    player.critChance = 0.05;
    player.critMultiplier = 1.5;
    player.dashSpeed = 500;
    player.dashDuration = 300;
    player.dashCooldownTime = 2000;
    player.direction = 1;
    player.effects = {};
    player.invulnerableTime = 0;
    player.kills = 0;
    player.thornPoisonChance = 0;
    player.emoji = selectedEmoji;

    achievements.forEach(a => a.unlocked = false);

    generateObstacleParticles();
    createEnvironment();

    setTimeout(() => {
        statsPanel.style.display = 'block';
    }, 2000);

    gameLoop();
}

function gameOver() {
    isGameOver = true;
    isGameRunning = false;

    gameOverScreen.style.display = 'flex';
    statsPanel.style.display = 'none';
    dashButton.style.display = 'none';

    finalTimeSpan.textContent = formatTime(gameTime);
    finalScoreSpan.textContent = score;
    finalKillsSpan.textContent = killCount;
    finalComboSpan.textContent = highestCombo;

    for (let i = 0; i < 30; i++) {
        particles.push({
            x: CENTER_X + (Math.random() - 0.5) * 100,
            y: CENTER_Y + (Math.random() - 0.5) * 100,
            size: Math.random() * 10 + 5,
            color: '#e74c3c',
            alpha: 0.8,
            speed: {x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3},
            life: 40,
        });
    }
}

function updateGameTime() {
    const timeScale = 1;
    const currentTime = Date.now();
    deltaTime = (currentTime - lastTime) * timeScale;

    if (deltaTime > 100 * timeScale) deltaTime = 100 * timeScale;

    gameTime += deltaTime;
    waveTimer += deltaTime;

    if (waveTimer >= waveInterval) {
        waveTimer = 0;
        waveNumber++;
        createFloatingText(CENTER_X, 150, `Wave ${waveNumber}!`, '#f4a261', 32);

        if (waveNumber % 10 === 0) {
            specialWave = 'ghost';
            createFloatingText(CENTER_X, 200, 'Ghost Wave!', '#b8c0ff', 28);
        } else if (waveNumber % 7 === 0) {
            specialWave = 'vampire';
            createFloatingText(CENTER_X, 200, 'Vampire Wave!', '#800020', 28);
        } else if (waveNumber % 9 === 0) {
            specialWave = 'teleporter';
            createFloatingText(CENTER_X, 200, 'Teleporter Wave!', '#FFDD00', 28);
        } else if (waveNumber % 8 === 0) {
            specialWave = 'swarm';
            createFloatingText(CENTER_X, 200, 'Swarm Wave!', '#FFA500', 28);
        } else {
            specialWave = false;
        }

        const waveStartCount = Math.min(5 + Math.floor(waveNumber / 2), 15);
        for (let i = 0; i < waveStartCount; i++) {
            setTimeout(() => {
                spawnEnemy();
            }, i * 300);
        }
    }

    if (gameTime >= ENDLESS_MODE_TIME && !isEndlessMode) {
        isEndlessMode = true;
        createFloatingText(CENTER_X, CENTER_Y - 100, 'ENDLESS MODE ACTIVATED!', '#e76f51', 36);
        unlockAchievement('endlessMode');

        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                particles.push({
                    x: CENTER_X + (Math.random() - 0.5) * GAME_WIDTH * 0.8,
                    y: CENTER_Y + (Math.random() - 0.5) * GAME_HEIGHT * 0.8,
                    size: Math.random() * 10 + 5,
                    color: '#e76f51',
                    alpha: 0.8,
                    speed: {x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5},
                    life: 60
                });
            }, i * 50);
        }
    }

    if (comboTimer > 0) {
        comboTimer -= deltaTime;
        if (comboTimer <= 0) {
            comboCount = 0;
        }
    }

    lastTime = currentTime;
}

function updateEnemySpawns() {
    if (isPaused || isUpgrading) return;

    enemySpawnTimer += deltaTime;

    if (isEndlessMode) {
        spawnInterval = SPAWN_INTERVAL_BASE / (1 + (gameTime - ENDLESS_MODE_TIME) / 1000 / 60 * 0.3);
    } else {
        const minutes = gameTime / 60000;
        spawnInterval = SPAWN_INTERVAL_BASE / (1 + minutes * 0.15);
    }

    spawnInterval = Math.max(spawnInterval, 200);

    if (enemySpawnTimer >= spawnInterval) {
        enemySpawnTimer = 0;

        const baseWaveSize = Math.min(1 + Math.floor(gameTime / 60000 * 0.5), 4);
        const waveMultiplier = isEndlessMode ? 1.5 : 1;
        const waveSize = Math.ceil(baseWaveSize * waveMultiplier);

        for (let i = 0; i < waveSize; i++) {
            if (enemies.length < MAX_ENEMIES) {
                spawnEnemy();
            }
        }
    }
}

function updateEffects() {
    Object.keys(effects).forEach(key => {
        if (effects[key] && !effects[key].permanent) {
            effects[key].duration -= deltaTime / 1000;
            if (effects[key].duration <= 0) {
                delete effects[key];
            }
        }
    });

    if (player.effects.regeneration && player.health < player.maxHealth) {
        player.health = Math.min(player.health + player.effects.regeneration * deltaTime / 1000, player.maxHealth);
    }

    if (player.invulnerableTime > 0) {
        player.invulnerableTime -= deltaTime;
    }

    if (screenShake > 0) {
        screenShake -= deltaTime / 50;
        if (screenShake < 0) screenShake = 0;
    }

    updateFPS();
}

function togglePause() {
    if (isGameOver || isUpgrading) return;

    isPaused = !isPaused;

    if (isPaused) {
        pauseMenu.style.display = 'flex';
        dashButton.style.display = 'none';
    } else {
        pauseMenu.style.display = 'none';
        if (isMobile && useTouchControls) {
            dashButton.style.display = 'flex';
        }
        lastTime = Date.now();
    }
}

function toggleStats() {
    if (statsPanel.style.display === 'none' || statsPanel.style.display === '') {
        statsPanel.style.display = 'block';
    } else {
        statsPanel.style.display = 'none';
    }
}

function updateFPS() {
    frameCount++;
    const now = Date.now();

    if (now - lastFpsUpdate > 1000) {
        fps = (frameCount * 1000) / (now - lastFpsUpdate);
        frameCount = 0;
        lastFpsUpdate = now;
        fpsCounter.textContent = `FPS: ${Math.round(fps)}`;
    }
}

function gameLoop() {
    if (!isGameRunning) return;

    frameCount++;

    if (Date.now() - lastFpsUpdate > 1000) {
        fps = Math.round((frameCount * 1000) / (Date.now() - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = Date.now();
        fpsCounter.textContent = `FPS: ${fps}`;
    }

    if (!isPaused && !isUpgrading) {
        updateGameTime();
        updateEnemySpawns();
        movePlayer();
        updateEffects();
        moveEnemies();
        attackEnemies();
        updateProjectiles();
        checkItemPickup();
        updateEnemies();
        updateParticles();
        updateFloatingTexts();
        checkAchievements();
    }

    gameCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    drawBackground();
    drawEnvironment();
    drawItems();
    drawEnemies();
    drawProjectiles();
    drawPlayer();
    drawParticles();
    drawFloatingTexts();
    drawUI();

    if (screenShake > 0) {
        gameCtx.restore();
    }

    if (!isGameOver) {
        requestAnimationFrame(gameLoop);
    }
}

function setupEventListeners() {
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            tabContents.forEach(content => {
                content.classList.remove('active');
                if (content.getAttribute('data-tab') === tab.getAttribute('data-tab')) {
                    content.classList.add('active');
                }
            });
        });
    });

    backToGameButton.addEventListener('click', () => {
        tabs[0].click();
    });

    window.addEventListener('keydown', e => {
        keys[e.key] = true;

        if (e.key === 'Escape' && isGameRunning) {
            togglePause();
        }

        if (e.key === 'Tab' && isGameRunning) {
            e.preventDefault();
            toggleStats();
        }
    });

    window.addEventListener('keyup', e => {
        keys[e.key] = false;
    });

    window.addEventListener('mousemove', e => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    window.addEventListener('resize', () => {
        resizeCanvases();
        if (isMobile !== (window.innerWidth <= 800)) {
            isMobile = window.innerWidth <= 800;
        }
    });

    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
    resumeButton.addEventListener('click', togglePause);

    quitButton.addEventListener('click', () => {
        isPaused = false;
        isGameRunning = false;
        startScreen.style.display = 'flex';
        pauseMenu.style.display = 'none';
        statsPanel.style.display = 'none';
        dashButton.style.display = 'none';
    });
}

function initialize() {
    resizeCanvases();
    generateObstacleParticles();
    createEnvironment();
    setupEmojiSelector();
    setupEventListeners();
    setupMobileControls();

    if (isMobile) {
        useTouchControls = true;
    }
}

window.onload = initialize;
</script>
</body>
</html>